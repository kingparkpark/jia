<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ç›å¡å·´å¡ç•™è¨€æ¿</title>
  <style>
    :root{ 
      --bg: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      --bg-secondary: #f8fafc;
      --card: #ffffff; 
      --card-hover: #ffffff;
      --line: #e2e8f0; 
      --text: #1e293b; 
      --text-light: #64748b;
      --muted: #64748b; 
      --accent: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      --accent-hover: linear-gradient(135deg, #5a67d8 0%, #6b46c1 100%);
      --success: #10b981;
      --error: #ef4444;
      --warning: #f59e0b;
      --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      --shadow-lg: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
    }
    
    * { box-sizing: border-box; }
    
    body { 
      font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'PingFang SC', 'Noto Sans SC', sans-serif; 
      margin: 0; 
      background: var(--bg);
      background-attachment: fixed;
      color: var(--text); 
      line-height: 1.6;
      overflow-x: hidden;
    }
    
    .wrap { 
      max-width: 900px; 
      margin: 32px auto; 
      padding: 20px; 
    }
    
    .card { 
      background: var(--card); 
      border: 1px solid var(--line); 
      border-radius: 16px; 
      padding: 24px; 
      box-shadow: var(--shadow); 
      margin-bottom: 24px; 
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      backdrop-filter: blur(10px);
      position: relative;
      overflow: hidden;
    }
    
    .card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 2px;
      background: var(--accent);
      transform: scaleX(0);
      transition: transform 0.3s ease;
    }
    
    .card:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }
    
    .card:hover::before {
      transform: scaleX(1);
    }
    
    header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px; }
    
    h2, h3 { 
      margin: 0; 
      background: var(--accent);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      font-weight: 700;
    }
    
    .userbox { display: flex; align-items: center; gap: 16px; }
    
    .avatar { 
      width: 48px; 
      height: 48px; 
      border-radius: 12px; 
      display: grid; 
      place-items: center; 
      font-size: 24px; 
      background: linear-gradient(135deg, #fef3c7 0%, #fcd34d 100%);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      transition: transform 0.2s ease;
    }
    
    .avatar:hover {
      transform: scale(1.05);
    }
    
    .name { 
      font-weight: 600; 
      font-size: 16px;
      color: var(--text);
    }
    
    .muted { 
      color: var(--muted); 
      font-size: 13px; 
      font-weight: 400;
    }
    
    .row { display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }
    
    .presence { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; margin-top: 12px; }
    
    .presence .pill { 
      display: flex; 
      align-items: center; 
      gap: 8px; 
      padding: 8px 12px; 
      border: 1px solid var(--line); 
      border-radius: 20px; 
      background: var(--card);
      transition: all 0.2s ease;
      cursor: default;
    }
    
    .presence .pill:hover {
      background: var(--bg-secondary);
      transform: translateY(-1px);
    }
    
    .presence .pill .dot { 
      width: 8px; 
      height: 8px; 
      border-radius: 50%; 
      background: var(--success);
      box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.2);
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    
    .composer { 
      display: flex; 
      gap: 12px; 
      align-items: flex-end;
    }
    
    textarea { 
      flex: 1; 
      min-height: 80px; 
      max-height: 200px;
      padding: 16px; 
      border: 2px solid var(--line); 
      border-radius: 12px; 
      outline: none; 
      font-size: 15px; 
      background: var(--card);
      transition: all 0.3s ease;
      resize: none;
      font-family: inherit;
      line-height: 1.5;
    }
    
    textarea:focus {
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      background: #fafbfc;
    }
    
    button { 
      padding: 12px 20px; 
      border: 0; 
      border-radius: 12px; 
      background: var(--accent); 
      color: #fff; 
      cursor: pointer; 
      white-space: nowrap;
      font-weight: 600;
      font-size: 14px;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }
    
    button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: left 0.5s;
    }
    
    button:hover::before {
      left: 100%;
    }
    
    button:hover {
      background: var(--accent-hover);
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
    }
    
    button:active {
      transform: translateY(0);
    }
    
    button:disabled { 
      opacity: 0.6; 
      cursor: not-allowed; 
      transform: none;
      box-shadow: none;
    }
    
    ul#list { list-style: none; padding: 0; margin: 20px 0 0 0; }
    
    li.msg { 
      display: flex; 
      gap: 12px; 
      padding: 16px; 
      border: 1px solid var(--line); 
      border-radius: 16px; 
      background: var(--card); 
      margin-bottom: 12px;
      transition: all 0.3s ease;
      animation: slideIn 0.5s ease-out;
    }
    
    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateX(-20px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }
    
    li.msg:hover {
      background: var(--bg-secondary);
      transform: translateX(4px);
    }
    
    .bubble { flex: 1; }
    
    .meta { 
      font-size: 12px; 
      color: var(--muted); 
      margin: 8px 0 0; 
      display: flex; 
      gap: 12px; 
      flex-wrap: wrap; 
    }

    /* ç™»å½•æ¡†ä¼˜åŒ– */
    .login { 
      max-width: 400px; 
      margin: 100px auto;
      animation: fadeInUp 0.8s ease-out;
    }
    
    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    .login .card {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    .login h3 { 
      margin: 0 0 20px; 
      text-align: center; 
      font-size: 24px;
      font-weight: 700;
    }
    
    .login .field { display: flex; gap: 12px; align-items: stretch; }
    
    input[type=password] { 
      flex: 1; 
      padding: 14px 16px; 
      border: 2px solid var(--line); 
      border-radius: 12px; 
      outline: none;
      font-size: 15px;
      transition: all 0.3s ease;
      background: var(--card);
    }
    
    input[type=password]:focus {
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }
    
    .error { 
      color: var(--error); 
      font-size: 13px; 
      margin-top: 12px; 
      min-height: 20px; 
      font-weight: 500;
    }
    
    .topbar { display: flex; align-items: center; justify-content: space-between; gap: 16px; }
    .actions { display: flex; gap: 12px; }
    
    .logout { 
      background: var(--card); 
      color: var(--text); 
      border: 2px solid var(--line);
    }
    
    .logout:hover {
      background: var(--bg-secondary);
      border-color: var(--error);
      color: var(--error);
    }

    .config { 
      background: var(--card); 
      color: var(--text); 
      border: 2px solid var(--line);
    }
    
    .config:hover {
      background: var(--bg-secondary);
      border-color: #667eea;
      color: #667eea;
    }

    /* å¼€å¥–æ¨¡å—ä¼˜åŒ– */
    select { 
      padding: 10px 12px; 
      font-size: 14px; 
      margin-bottom: 16px;
      border: 2px solid var(--line);
      border-radius: 8px;
      background: var(--card);
      transition: all 0.3s ease;
      cursor: pointer;
    }
    
    select:focus {
      border-color: #667eea;
      outline: none;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }
    
    /* å¼€å¥–ä¿¡æ¯å¸ƒå±€ */
    .lottery-container {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    
    .lottery-main {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 16px;
      color: white;
      box-shadow: 0 8px 32px rgba(102, 126, 234, 0.3);
    }
    
    .lottery-issue {
      font-size: 16px;
      font-weight: 500;
      opacity: 0.9;
      margin-bottom: 8px;
    }
    
    .lottery-numbers {
      font-size: 32px;
      font-weight: 800;
      letter-spacing: 2px;
      text-shadow: 0 2px 8px rgba(0,0,0,0.3);
      margin: 8px 0;
      line-height: 1.2;
    }
    
    .lottery-numbers .number {
      display: inline-block;
      background: rgba(255,255,255,0.2);
      padding: 8px 12px;
      margin: 0 4px;
      border-radius: 12px;
      min-width: 50px;
      text-align: center;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.3);
    }
    
    .lottery-zodiac {
      font-size: 18px;
      margin-top: 12px;
      padding: 12px 16px;
      background: rgba(255,255,255,0.15);
      border-radius: 12px;
      backdrop-filter: blur(10px);
    }
    
    .lottery-next {
      font-size: 14px;
      opacity: 0.8;
      margin-top: 8px;
    }
    
    .lottery-history {
      background: var(--card);
      border-radius: 12px;
      padding: 16px;
      border: 2px solid var(--line);
    }
    
    .lottery-history h4 {
      margin: 0 0 12px 0;
      color: var(--text);
      font-size: 16px;
      font-weight: 600;
    }
    
    .lottery-history ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    
    .lottery-history li {
      padding: 12px 0;
      border-bottom: 1px solid var(--line);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .lottery-history li:last-child {
      border-bottom: none;
    }
    
    .history-issue {
      font-weight: 600;
      color: var(--accent);
    }
    
    .history-numbers {
      font-size: 18px;
      font-weight: 700;
      color: var(--text);
      letter-spacing: 1px;
    }
    
    .zodiac { 
      font-size: 16px; 
      margin-top: 6px;
    }
    
    .countdown { 
      font-weight: 600; 
      color: var(--error); 
      margin-top: 12px;
      padding: 12px;
      background: rgba(239, 68, 68, 0.1);
      border-radius: 8px;
      border-left: 4px solid var(--error);
    }
    
    /* AIé¢„æµ‹åŠŸèƒ½æ ·å¼ */
    .ai-prediction-section {
      margin-top: 24px;
      padding: 20px;
      background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
      border-radius: 12px;
      border: 1px solid #0ea5e9;
    }
    
    .ai-prediction-section h4 {
      margin: 0 0 12px 0;
      color: #0369a1;
      font-size: 18px;
    }
    
    .prediction-disclaimer {
      font-size: 12px;
      color: #64748b;
      margin: 0 0 16px 0;
      font-style: italic;
    }
    
    /* é¢„æµ‹å½©ç§é€‰æ‹©æ ·å¼ */
    .prediction-type-selector {
      margin-bottom: 20px;
    }
    
    .prediction-type-selector label {
      display: block;
      font-size: 14px;
      font-weight: 600;
      color: #0c4a6e;
      margin-bottom: 8px;
    }
    
    .prediction-tabs {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
    }
    
    .prediction-tab {
      flex: 1;
      padding: 12px 16px;
      border: 2px solid #0ea5e9;
      background: white;
      color: #0369a1;
      border-radius: 12px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }
    
    .prediction-tab:hover {
      background: #f0f9ff;
      transform: translateY(-1px);
    }
    
    .prediction-tab.active {
      background: linear-gradient(135deg, #0ea5e9 0%, #0284c7 100%);
      color: white;
      box-shadow: 0 4px 12px rgba(14, 165, 233, 0.3);
    }
    
    .prediction-panel {
      display: none;
      animation: fadeIn 0.3s ease-in-out;
    }
    
    .prediction-panel.active {
      display: block;
    }
    
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    .predict-btn {
      background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
    }
    
    .predict-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(59, 130, 246, 0.4);
    }
    
    .predict-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }
    
    .prediction-loading {
      text-align: center;
      padding: 20px;
    }
    
    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 4px solid #e5e7eb;
      border-top: 4px solid #3b82f6;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .prediction-info {
      background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
      border: 1px solid #cbd5e1;
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 15px;
      font-size: 14px;
    }
    
    .prediction-info > div {
      margin-bottom: 6px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .prediction-info > div:last-child {
      margin-bottom: 0;
    }
    
    .prediction-info span {
      font-weight: 600;
      color: #1e40af;
    }
    
    .accuracy-rate span {
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 12px;
    }
    
    .accuracy-high {
      background: #dcfce7;
      color: #166534;
    }
    
    .accuracy-medium {
      background: #fef3c7;
      color: #92400e;
    }
    
    .accuracy-low {
      background: #fee2e2;
      color: #991b1b;
    }
    
    .prediction-history {
      margin-top: 20px;
      border-top: 1px solid #e5e7eb;
      padding-top: 15px;
    }
    
    .prediction-history h5 {
      margin: 0 0 10px 0;
      color: #374151;
      font-size: 14px;
    }
    
    .history-list {
      max-height: 200px;
      overflow-y: auto;
    }
    
    .history-item {
      background: #f9fafb;
      border: 1px solid #e5e7eb;
      border-radius: 6px;
      padding: 8px 10px;
      margin-bottom: 8px;
      font-size: 12px;
    }
    
    .history-item:last-child {
      margin-bottom: 0;
    }
    
    .history-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;
    }
    
    .history-period {
      font-weight: 600;
      color: #1f2937;
    }
    
    .history-status {
      padding: 1px 6px;
      border-radius: 8px;
      font-size: 10px;
      font-weight: 600;
    }
    
    .status-pending {
      background: #dbeafe;
      color: #1e40af;
    }
    
    .status-correct {
      background: #dcfce7;
      color: #166534;
    }
    
    .status-incorrect {
      background: #fee2e2;
      color: #991b1b;
    }
    
    .history-numbers {
      color: #6b7280;
      margin-bottom: 2px;
    }
    
    .history-result {
      color: #374151;
      font-size: 11px;
    }
    
    .strategy-indicator {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 5px;
    }
    
    .strategy-ai {
      background: #3b82f6;
    }
    
    .strategy-statistical {
      background: #10b981;
    }
    
    .strategy-trend {
      background: #f59e0b;
    }
    
    .strategy-ml {
      background: #8b5cf6;
    }
    
    .strategy-hybrid {
      background: linear-gradient(45deg, #f59e0b, #10b981, #3b82f6, #8b5cf6);
      background-size: 400% 400%;
      animation: gradient-shift 3s ease-in-out infinite;
    }
    
    @keyframes gradient-shift {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }
    
    .accuracy-high {
      color: #059669;
      font-weight: 600;
    }
    
    .accuracy-medium {
      color: #d97706;
      font-weight: 600;
    }
    
    .accuracy-low {
      color: #dc2626;
      font-weight: 600;
    }
    
    .loading-spinner {
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 12px;
    }
    
    .result-verification {
      margin-top: 20px;
      padding: 15px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .result-verification h6 {
      margin: 0 0 12px 0;
      color: #fbbf24;
      font-size: 14px;
      font-weight: 600;
    }
    
    .verification-form {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    .period-input, .result-input {
      padding: 8px 12px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 6px;
      background: rgba(255, 255, 255, 0.1);
      color: white;
      font-size: 13px;
    }
    
    .period-input::placeholder, .result-input::placeholder {
      color: rgba(255, 255, 255, 0.6);
    }
    
    .verify-btn {
      padding: 8px 16px;
      background: linear-gradient(135deg, #10b981, #059669);
      color: white;
      border: none;
      border-radius: 6px;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .verify-btn:hover {
      background: linear-gradient(135deg, #059669, #047857);
      transform: translateY(-1px);
    }
    
    .result-comparison {
      margin-top: 8px;
      padding: 8px;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 4px;
      font-size: 12px;
    }
    
    .match-info {
      margin-top: 4px;
      color: #9ca3af;
    }
    
    .accuracy-info {
      color: #fbbf24;
      font-weight: 600;
    }
    
    .strategy-selector {
      margin: 10px 0;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .strategy-selector label {
      font-weight: bold;
      color: #333;
      min-width: 80px;
    }
    
    .strategy-selector select {
      padding: 8px 12px;
      border: 2px solid #ddd;
      border-radius: 8px;
      background: white;
      font-size: 14px;
      color: #333;
      cursor: pointer;
      transition: all 0.3s ease;
      min-width: 150px;
    }
    
    .strategy-selector select:hover {
      border-color: #007bff;
      box-shadow: 0 2px 8px rgba(0,123,255,0.2);
    }
    
    .strategy-selector select:focus {
      outline: none;
      border-color: #007bff;
      box-shadow: 0 0 0 3px rgba(0,123,255,0.1);
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .prediction-result {
      margin-top: 16px;
      padding: 20px;
      background: white;
      border-radius: 8px;
      border: 1px solid #e5e7eb;
    }
    
    .prediction-numbers {
      display: flex;
      gap: 8px;
      justify-content: center;
      margin: 16px 0;
      flex-wrap: wrap;
    }
    
    .prediction-number {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      color: white;
      font-size: 16px;
      animation: fadeInUp 0.5s ease;
    }
    
    .prediction-number.red { background: #ef4444; }
    .prediction-number.blue { background: #3b82f6; }
    .prediction-number.green { background: #10b981; }
    
    .prediction-zodiac {
      text-align: center;
      font-size: 24px;
      margin: 12px 0;
    }
    
    .prediction-confidence {
      text-align: center;
      font-size: 14px;
      color: #64748b;
      margin-top: 12px;
    }
    
    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    /* å“åº”å¼ä¼˜åŒ– */
    @media (max-width: 768px) {
      .lottery-numbers {
        font-size: 24px;
      }
      
      .lottery-numbers .number {
        padding: 6px 8px;
        margin: 0 2px;
        min-width: 40px;
      }
      
      .lottery-main {
        padding: 16px;
      }
    }

    /* Toast é€šçŸ¥æ ·å¼ */
    .toast {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 16px 20px;
      border-radius: 12px;
      color: white;
      font-weight: 500;
      z-index: 1000;
      transform: translateX(400px);
      transition: transform 0.3s ease;
      box-shadow: var(--shadow-lg);
    }
    
    .toast.show {
      transform: translateX(0);
    }
    
    .toast.success { background: var(--success); }
    .toast.error { background: var(--error); }
    .toast.warning { background: var(--warning); }

    /* å“åº”å¼ä¼˜åŒ– */
    @media (max-width: 768px) {
      .wrap { margin: 16px; padding: 16px; }
      .card { padding: 16px; margin-bottom: 16px; }
      .composer { flex-direction: column; align-items: stretch; }
      .login { margin: 60px auto; }
      .userbox { gap: 12px; }
      .avatar { width: 40px; height: 40px; font-size: 20px; }
    }
  </style>
</head>
<body>

  <!-- ç™»å½•è§†å›¾ -->
  <div id="loginView" class="wrap">
    <div class="card login">
      <h3>ç›å¡å·´å¡ç•™è¨€æ¿ Â· å¯†ç ç™»å½•</h3>
      <div class="muted" style="margin-bottom:10px;">â­=â­=â­=â­=â­=â­=â­=â­=â­=â­=â­=â­=â­</div>
      <div class="field">
        <input id="pwd" type="password" placeholder="è¾“å…¥å¯†ç ï¼Œä¾‹å¦‚ï¼šå¤©ä¸Šæœ‰å‡ é¢—æ˜Ÿæ˜Ÿï¼Ÿ" />
        <button id="loginBtn">è¿›å…¥</button>
      </div>
      <div id="loginErr" class="error"></div>
    </div>
  </div>

  <!-- ä¸»è§†å›¾ -->
  <div id="mainView" class="wrap" style="display:none;">
    <!-- ç”¨æˆ·ä¿¡æ¯ -->
    <div class="card">
      <div class="topbar">
        <div class="userbox">
          <div id="meAvatar" class="avatar">ğŸ™‚</div>
          <div>
            <div id="meName" class="name">æœªçŸ¥</div>
            <div class="muted">ç•™è¨€ä¼šåœ¨ 48 å°æ—¶åè‡ªåŠ¨æ¸…é™¤</div>
          </div>
        </div>
        <div class="actions">
          <button id="configBtn" class="config" onclick="openConfigPanel()">âš™ï¸ é…ç½®</button>
          <button id="logoutBtn" class="logout">é€€å‡º</button>
        </div>
      </div>
    </div>

    <!-- åœ¨çº¿åˆ—è¡¨ -->
    <div class="card">
      <div class="row" style="justify-content:space-between;">
        <div class="name">å½“å‰åœ¨çº¿</div>
        <div class="muted">1 åˆ†é’Ÿå†…æ´»è·ƒè§†ä¸ºåœ¨çº¿</div>
      </div>
      <div id="presence" class="presence" style="margin-top:8px;"></div>
    </div>

    <!-- å¼€å¥–èµ„è®¯æ¨¡å— -->
    <div class="card">
      <h3>ğŸ§§ å¼€å¥–èµ„è®¯</h3>
      <label for="gameSelect">é€‰æ‹©æ¸¸æˆï¼š</label>
      <select id="gameSelect">
        <option value="1">é¦™æ¸¯</option>
        <option value="4">æ–°æ¾³é—¨</option>
      </select>
      <div id="lotteryInfo">è½½å…¥ä¸­...</div>
      <div id="countdown" class="countdown"></div>
      
      <!-- AIé¢„æµ‹åŠŸèƒ½ -->
      <div class="ai-prediction-section">
        <h4>ğŸ¤– AIæ™ºèƒ½é¢„æµ‹</h4>
        <p class="prediction-disclaimer">âš ï¸ ä»…ä¾›å¨±ä¹å‚è€ƒï¼Œä¸æ„æˆæŠ•æ³¨å»ºè®®</p>
        
        <!-- é¢„æµ‹å½©ç§é€‰æ‹© -->
        <div class="prediction-type-selector">
          <label>é€‰æ‹©é¢„æµ‹å½©ç§ï¼š</label>
          <div class="prediction-tabs">
            <button id="hkPredictTab" class="prediction-tab active" data-type="hk">ğŸ‡­ğŸ‡° é¦™æ¸¯æ•°å­—é¢„æµ‹</button>
                <button id="macauPredictTab" class="prediction-tab" data-type="macau">ğŸ‡²ğŸ‡´ æ¾³é—¨æ•°å­—é¢„æµ‹</button>
          </div>
        </div>
        
        <!-- é¦™æ¸¯æ•°å­—é¢„æµ‹ -->
        <div id="hkPrediction" class="prediction-panel active">
          <div class="prediction-info">
            <div class="current-period">å½“å‰é¢„æµ‹æœŸå·: <span id="hkCurrentPeriod">-</span></div>
            <div class="prediction-strategy">å½“å‰ç­–ç•¥: <span id="hkCurrentStrategy">AIæ™ºèƒ½åˆ†æ</span></div>
            <div class="accuracy-rate">å†å²å‡†ç¡®ç‡: <span id="hkAccuracyRate">-</span></div>
          </div>
          <button id="hkPredictBtn" class="predict-btn">ğŸ”® é¢„æµ‹é¦™æ¸¯æ•°å­—</button>
          <div id="hkPredictionResult" class="prediction-result" style="display: none;"></div>
          <div id="hkPredictionLoading" class="prediction-loading" style="display: none;">
            <div class="loading-spinner"></div>
            <p>AIæ­£åœ¨åˆ†æé¦™æ¸¯æ•°å­—å†å²æ•°æ®...</p>
          </div>
          <div class="prediction-history">
            <h5>ğŸ“Š é¢„æµ‹å†å²è®°å½•</h5>
            <div id="hkPredictionHistory" class="history-list"></div>
            <div class="auto-verification-info">
              <h6>ğŸ¤– è‡ªåŠ¨å¼€å¥–éªŒè¯</h6>
              <p style="color: #666; font-size: 12px; margin: 8px 0;">
                ç³»ç»Ÿä¼šè‡ªåŠ¨è·å–å®˜æ–¹å¼€å¥–ç»“æœè¿›è¡ŒéªŒè¯ï¼Œæ— éœ€æ‰‹åŠ¨è¾“å…¥
              </p>
              <div id="hkAutoVerificationStatus" class="verification-status">
                ç­‰å¾…è‡ªåŠ¨éªŒè¯...
              </div>
            </div>
          </div>
        </div>
        
        <!-- æ¾³é—¨æ•°å­—é¢„æµ‹ -->
        <div id="macauPrediction" class="prediction-panel" style="display: none;">
          <div class="prediction-info">
            <div class="current-period">å½“å‰é¢„æµ‹æœŸå·: <span id="macauCurrentPeriod">-</span></div>
            <div class="prediction-strategy">å½“å‰ç­–ç•¥: <span id="macauCurrentStrategy">AIæ™ºèƒ½åˆ†æ</span></div>
            <div class="accuracy-rate">å†å²å‡†ç¡®ç‡: <span id="macauAccuracyRate">-</span></div>
          </div>
          <button id="macauPredictBtn" class="predict-btn">ğŸ”® é¢„æµ‹æ¾³é—¨æ•°å­—</button>
          <div id="macauPredictionResult" class="prediction-result" style="display: none;"></div>
          <div id="macauPredictionLoading" class="prediction-loading" style="display: none;">
            <div class="loading-spinner"></div>
            <p>AIæ­£åœ¨åˆ†ææ¾³é—¨æ•°å­—å†å²æ•°æ®...</p>
          </div>
          <div class="prediction-history">
            <h5>ğŸ“Š é¢„æµ‹å†å²è®°å½•</h5>
            <div id="macauPredictionHistory" class="history-list"></div>
            <div class="auto-verification-info">
              <h6>ğŸ¤– è‡ªåŠ¨å¼€å¥–éªŒè¯</h6>
              <p style="color: #666; font-size: 12px; margin: 8px 0;">
                ç³»ç»Ÿä¼šè‡ªåŠ¨è·å–å®˜æ–¹å¼€å¥–ç»“æœè¿›è¡ŒéªŒè¯ï¼Œæ— éœ€æ‰‹åŠ¨è¾“å…¥
              </p>
              <div id="macauAutoVerificationStatus" class="verification-status">
                ç­‰å¾…è‡ªåŠ¨éªŒè¯...
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- ç•™è¨€è¾“å…¥ -->
    <div class="card">
      <form id="form" class="composer" autocomplete="off">
        <textarea id="text" placeholder="å†™ä¸‹ä½ æƒ³è¯´çš„è¯ï¼ˆä¸é™åˆ¶å­—æ•°ï¼‰"></textarea>
        <button id="send" type="submit">å‘é€</button>
      </form>
    </div>

    <!-- ç•™è¨€åˆ—è¡¨ -->
    <ul id="list"></ul>
  </div>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>
  <script>
    // â€”â€” ç”¨æˆ· & å¯†ç æ˜ å°„ â€”â€”
    const USERS = {
      horse:  { id:'horse',  name:'é©¬',   avatar:'ğŸ' },
      sheep:  { id:'sheep',  name:'ç¾Š',   avatar:'ğŸ‘' },
      mouse:  { id:'mouse',  name:'è€é¼ ', avatar:'ğŸ­' },
      rabbit: { id:'rabbit', name:'å…”å­', avatar:'ğŸ‡' },
      monkey: { id:'monkey', name:'çŒ´å­', avatar:'ğŸ’' },
      snake:  { id:'snake',  name:'è›‡',   avatar:'ğŸ' }
    };
    const PASSWORDS = {
      'ma123':'horse',
      'yang123':'sheep',
      'shu123':'mouse',
      'tu123':'rabbit',
      'hou123':'monkey',
      'she123':'snake'
    };

    // Toast ç»„ä»¶
    function showToast(msg, type='success', duration=2000){
      const t = document.createElement('div');
      t.className = `toast ${type}`;
      t.textContent = msg;
      document.body.appendChild(t);
      requestAnimationFrame(() => t.classList.add('show'));
      setTimeout(() => {
        t.classList.remove('show');
        setTimeout(() => t.remove(), 300);
      }, duration);
    }

    // è‡ªé€‚åº”æ–‡æœ¬åŸŸé«˜åº¦
    function autoResizeTextarea(el){
      if(!el) return;
      const resize = () => { el.style.height = 'auto'; el.style.height = Math.min(el.scrollHeight, 200) + 'px'; };
      el.addEventListener('input', resize);
      resize();
    }

    // â€”â€” Firebase é…ç½® â€”â€”
    const firebaseConfig = {
      apiKey: "AIzaSyDTsjNPdZntfabyVn0q-9y39l9a1ur_cEw",
      authDomain: "jiatingliuyanban-635f9.firebaseapp.com",
      databaseURL: "https://jiatingliuyanban-635f9-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "jiatingliuyanban-635f9",
      storageBucket: "jiatingliuyanban-635f9.appspot.com",
      messagingSenderId: "196518556157",
      appId: "1:196518556157:web:f710ec71f8acb4eb79a994"
    };

    // â€”â€” å¸¸é‡ â€”â€”
    const EXP_MS = 48 * 3600 * 1000;       // ç•™è¨€è¿‡æœŸ 48h
    const ONLINE_WINDOW = 60 * 1000;      // åœ¨çº¿åˆ¤å®š 1min
    const COUNTDOWN_INTERVAL = 60000;     // ç•™è¨€å€’è®¡æ—¶åˆ·æ–° 1min

    // â€”â€” å¼€å¥–APIé…ç½® â€”â€”
    const LOTTERY_APIS = [
      {
        name: 'é¦™æ¸¯API',
        url: (gameid) => `https://api.166001.com/lottery/get/${gameid}`,
        parser: (json) => json.data
      },
      {
        name: 'æ–°æ¾³é—¨API',
        url: (gameid) => `https://macaumarksix.com/api/macaujc2.com`,
        parser: (json) => {
          if (!json || !Array.isArray(json) || json.length === 0) return null;
          const data = json[0];
          return {
            currentIssue: data.expect,
            currentResult: data.openCode,
            currentZodiac: data.zodiac,
            nextIssue: '',
            nextTime: '',
            resultsOfLastThreeIssues: []
          };
        }
      },
      {
        name: 'å¤‡ç”¨API1', 
        url: (gameid) => `https://api.jisuapi.com/caipiao/query?appkey=demo&caipiaoid=${gameid}`,
        parser: (json) => {
          if(json.status !== 0) return null;
          const r = json.result;
          return {
            currentIssue: r.issueno,
            currentResult: r.number,
            currentZodiac: '',
            nextIssue: '',
            nextTime: '',
            resultsOfLastThreeIssues: []
          };
        }
      },
      {
        name: 'å¤‡ç”¨API2',
        url: (gameid) => `https://open.liupai.net/lottery/query?appkey=demo&cpid=${gameid}`,
        parser: (json) => {
          if(json.status !== '200') return null;
          const r = json.result;
          return {
            currentIssue: r.issueno,
            currentResult: r.number,
            currentZodiac: '',
            nextIssue: '',
            nextTime: '',
            resultsOfLastThreeIssues: []
          };
        }
      }
    ];

    // â€”â€” ç”Ÿè‚– emoji æ˜ å°„ â€”â€” 
    const zodiacEmoji = {
      // åäºŒç”Ÿè‚–å®Œæ•´æ˜ å°„ï¼ˆæ”¯æŒç¹ç®€ä½“åŠå¸¸è§å˜ä½“ï¼‰
      "é¼ ":"ğŸ­","è€é¼ ":"ğŸ­","å­é¼ ":"ğŸ­",
      "ç‰›":"ğŸ®","ä¸‘ç‰›":"ğŸ®","æ°´ç‰›":"ğŸ®","é»„ç‰›":"ğŸ®",
      "è™":"ğŸ¯","å¯…è™":"ğŸ¯","è€è™":"ğŸ¯","ç™½è™":"ğŸ¯",
      "å…”":"ğŸ°","å¯å…”":"ğŸ°","å…”å­":"ğŸ°","ç‰å…”":"ğŸ°",
      "é¾™":"ğŸ²","é¾":"ğŸ²","è¾°é¾™":"ğŸ²","è¾°é¾":"ğŸ²","é’é¾™":"ğŸ²","é’é¾":"ğŸ²",
      "è›‡":"ğŸ","å·³è›‡":"ğŸ","é•¿è›‡":"ğŸ","é’è›‡":"ğŸ",
      "é©¬":"ğŸ´","é¦¬":"ğŸ´","åˆé©¬":"ğŸ´","åˆé¦¬":"ğŸ´","ç™½é©¬":"ğŸ´","ç™½é¦¬":"ğŸ´",
      "ç¾Š":"ğŸ‘","æœªç¾Š":"ğŸ‘","å±±ç¾Š":"ğŸ‘","ç»µç¾Š":"ğŸ‘",
      "çŒ´":"ğŸµ","ç”³çŒ´":"ğŸµ","çŒ´å­":"ğŸµ","é‡‘çŒ´":"ğŸµ",
      "é¸¡":"ğŸ”","é›":"ğŸ”","é…‰é¸¡":"ğŸ”","é…‰é›":"ğŸ”","å…¬é¸¡":"ğŸ”","å…¬é›":"ğŸ”",
      "ç‹—":"ğŸ¶","æˆŒç‹—":"ğŸ¶","å°ç‹—":"ğŸ¶","é»„ç‹—":"ğŸ¶",
      "çŒª":"ğŸ·","è±¬":"ğŸ·","äº¥çŒª":"ğŸ·","äº¥è±¬":"ğŸ·","é‡çŒª":"ğŸ·","é‡è±¬":"ğŸ·"
    };

    // â€”â€” DOM å¼•ç”¨ â€”â€”
    const loginView  = document.getElementById('loginView');
    const mainView   = document.getElementById('mainView');
    const pwdInput   = document.getElementById('pwd');
    const loginBtn   = document.getElementById('loginBtn');
    const loginErr   = document.getElementById('loginErr');
    const meAvatar   = document.getElementById('meAvatar');
    const meName     = document.getElementById('meName');
    const logoutBtn  = document.getElementById('logoutBtn');
    const form       = document.getElementById('form');
    const textInput  = document.getElementById('text');
    const sendBtn    = document.getElementById('send');
    const listEl     = document.getElementById('list');
    const presenceEl = document.getElementById('presence');
    const gameSelect = document.getElementById('gameSelect');
    const lotteryInfo= document.getElementById('lotteryInfo');
    const countdownEl= document.getElementById('countdown');
    const predictBtn = document.getElementById('predictBtn');
    const predictionResult = document.getElementById('predictionResult');
    const predictionLoading = document.getElementById('predictionLoading');

    // â€”â€” çŠ¶æ€å˜é‡ â€”â€”
    let currentUser = null;
    let db, messagesRef, statusRef, statusAllRef, connectedRef;
    let messageTimer = null;

    // â€”â€” è‡ªåŠ¨ç™»å½•æ£€æµ‹ â€”â€”
    const savedRole = sessionStorage.getItem('roleId');
    if (savedRole && USERS[savedRole]) {
      currentUser = USERS[savedRole];
      showMain();
    }

    // â€”â€” ç™»å½•äº‹ä»¶ â€”â€”
    loginBtn.addEventListener('click', () => {
      const pwd = (pwdInput.value || '').trim();
      const roleId = PASSWORDS[pwd];
      if (!roleId || !USERS[roleId]) {
        loginErr.textContent = 'å¯†ç é”™è¯¯ï¼Œè¯·é‡è¯•';
        showToast('å¯†ç é”™è¯¯', 'error');
        return;
      }
      currentUser = USERS[roleId];
      sessionStorage.setItem('roleId', currentUser.id);
      showMain();
      showToast('ç™»å½•æˆåŠŸ', 'success');
    });

    // æ”¯æŒå›è½¦é”®ç™»å½•
    pwdInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        loginBtn.click();
      }
    });

    // â€”â€” é€€å‡ºäº‹ä»¶ â€”â€”
    logoutBtn.addEventListener('click', () => {
      try { statusRef && statusRef.remove(); } catch(e){}
      sessionStorage.removeItem('roleId');
      mainView.style.display = 'none';
      loginView.style.display = 'block';
      if (messageTimer) clearInterval(messageTimer);
      showToast('å·²é€€å‡ºç™»å½•', 'warning');
    });

    // â€”â€” æ˜¾ç¤ºä¸»ç•Œé¢ & åˆå§‹åŒ– Firebase & ç›‘å¬æ¶ˆæ¯ & åœ¨çº¿ & å¼€å¥– â€”â€” 
    function showMain(){
      loginView.style.display = 'none';
      mainView.style.display = 'block';
      meAvatar.textContent = currentUser.avatar;
      meName.textContent   = currentUser.name;

      // UI åˆå§‹åŒ–
      autoResizeTextarea(textInput);

      if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
      db            = firebase.database();
      messagesRef   = db.ref('messages');
      statusRef     = db.ref('status/' + currentUser.id);
      statusAllRef  = db.ref('status');
      connectedRef  = db.ref('.info/connected');

      // â€”â€” åœ¨çº¿çŠ¶æ€å¿ƒè·³ â€”â€”
      connectedRef.on('value', snap => {
        if (snap.val() === true) {
          statusRef.onDisconnect().remove();
          statusRef.set({ uid:currentUser.id, name:currentUser.name,
                          avatar:currentUser.avatar,
                          lastSeen:firebase.database.ServerValue.TIMESTAMP });
        }
      });
      setInterval(() => {
        statusRef.update({ lastSeen: firebase.database.ServerValue.TIMESTAMP });
      }, 30000);

      // â€”â€” æ¸²æŸ“åœ¨çº¿ç”¨æˆ· â€”â€”
      statusAllRef.on('value', snap => {
        const now = Date.now();
        const online = [];
        snap.forEach(ch => {
          const v = ch.val();
          if (v.lastSeen && (now - v.lastSeen) < ONLINE_WINDOW) {
            online.push(v);
          }
        });
        presenceEl.innerHTML = online.length
          ? online.map(v => `<span class="pill"><span class="dot"></span><span>${v.avatar}</span><b>${v.name}</b></span>`).join('')
          : '<span class="muted">å½“å‰æ— äººåœ¨çº¿</span>';
      });

      // â€”â€” å‘é€æ¶ˆæ¯ â€”â€”
      form.addEventListener('submit', async e => {
        e.preventDefault();
        const txt = (textInput.value||'').trim();
        if (!txt) return;
        sendBtn.disabled = true;
        sendBtn.textContent = 'å‘é€ä¸­...';
        try {
          await messagesRef.push({ userId:currentUser.id,
                                   text:txt,
                                   ts:firebase.database.ServerValue.TIMESTAMP });
          textInput.value = '';
          textInput.dispatchEvent(new Event('input'));
          showToast('å‘é€æˆåŠŸ', 'success');
        } catch (err) {
          console.error(err);
          showToast('å‘é€å¤±è´¥ï¼Œè¯·é‡è¯•', 'error');
        } finally {
          sendBtn.disabled = false;
          sendBtn.textContent = 'å‘é€';
        }
      });

      // Ctrl/Cmd + Enter å‘é€
      textInput.addEventListener('keydown', (e) => {
        if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
          e.preventDefault();
          form.requestSubmit();
        }
      });

      // â€”â€” æ¸…ç† & ç›‘å¬ & æ¸²æŸ“ç•™è¨€ â€”â€”
      cleanupExpired();
      messageTimer = setInterval(cleanupExpired, 10*60*1000);

      const since = Date.now() - EXP_MS;
      messagesRef.orderByChild('ts').startAt(since).limitToLast(500)
        .on('child_added', snap => renderMessage(snap.key, snap.val()));
      messagesRef.on('child_removed', snap => {
        const el = document.getElementById('msg-'+snap.key);
        if(el) el.remove();
      });

      // â€”â€” ç•™è¨€å€’è®¡æ—¶æ›´æ–° â€”â€”
      setInterval(updateAllMessageCountdowns, COUNTDOWN_INTERVAL);

      // â€”â€” åˆå§‹åŒ– & ç›‘å¬å¼€å¥–æ¨¡å— â€”â€”
      gameSelect.addEventListener('change', () => loadLottery(gameSelect.value));
      loadLottery(gameSelect.value);
    }

    // â€”â€” æ¸²æŸ“å•æ¡ç•™è¨€ â€”â€”
    function renderMessage(id, m){
      if(!m || !m.ts) return;
      const age = Date.now() - m.ts;
      if(age >= EXP_MS) return;
      let li = document.getElementById('msg-'+id);
      if(!li){
        li = document.createElement('li');
        li.id = 'msg-'+id; li.className='msg';
        li.innerHTML = `
          <div class="avatar">${USERS[m.userId]?.avatar||'ğŸ™‚'}</div>
          <div class="bubble">
            <div><strong>${USERS[m.userId]?.name||'æœªçŸ¥'}ï¼š</strong><span class="content"></span></div>
            <div class="meta"><span class="time"></span> <span class="remain"></span></div>
          </div>`;
        listEl.prepend(li);
      }
      li.querySelector('.content').textContent = m.text;
      li.dataset.ts = m.ts;
      li.querySelector('.time').textContent = new Date(m.ts).toLocaleString();
      updateMessageCountdown(li);
    }

    // â€”â€” æ›´æ–°æ‰€æœ‰ç•™è¨€å‰©ä½™æ—¶é•¿ â€”â€”
    function updateAllMessageCountdowns(){
      document.querySelectorAll('li.msg').forEach(updateMessageCountdown);
    }
    function updateMessageCountdown(li){
      const ts = Number(li.dataset.ts);
      const remain = ts + EXP_MS - Date.now();
      if(remain <= 0){ li.remove(); return; }
      const s = Math.floor(remain/1000);
      const h = String(Math.floor(s/3600)).padStart(2,'0');
      const m = String(Math.floor((s%3600)/60)).padStart(2,'0');
      li.querySelector('.remain').textContent = `å‰©ä½™ ${h}å°æ—¶${m}åˆ†é’Ÿ`;
    }

    // â€”â€” å®¢æˆ·ç«¯æ¸…ç†è¿‡æœŸç•™è¨€ â€”â€”
    function cleanupExpired(){
      const cutoff = Date.now() - EXP_MS;
      messagesRef.orderByChild('ts').endAt(cutoff)
        .once('value', snap => snap.forEach(ch => ch.ref.remove()));
    }

    // â€”â€” å¸¦è¶…æ—¶çš„fetchè¯·æ±‚ â€”â€”
    async function fetchWithTimeout(url, timeout = 8000) {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), timeout);
      try {
        const response = await fetch(url, { signal: controller.signal });
        clearTimeout(timeoutId);
        return response;
      } catch (error) {
        clearTimeout(timeoutId);
        throw error;
      }
    }

    // â€”â€” åŠ è½½å¼€å¥–æ•°æ® & æ¸²æŸ“ï¼ˆå¢å¼ºç‰ˆï¼‰â€”â€”
    async function loadLottery(gameid){
      lotteryInfo.textContent = 'è½½å…¥ä¸­...';
      
      // å°è¯•æ‰€æœ‰APIæº
      for (let i = 0; i < LOTTERY_APIS.length; i++) {
        const api = LOTTERY_APIS[i];
        try {
          showToast(`æ­£åœ¨å°è¯•${api.name}...`, 'warning', 1500);
          
          const res = await fetchWithTimeout(api.url(gameid));
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          
          const json = await res.json();
          const d = api.parser(json);
          
          if (!d) {
            throw new Error('æ•°æ®è§£æå¤±è´¥');
          }

          // æ¸²æŸ“æˆåŠŸçš„æ•°æ®
          const zodiacHtml = d.currentZodiac
            ? d.currentZodiac.split(',').map(z => `${zodiacEmoji[z]||''}${z}`).join(', ')
            : '';
          
          // æ ¼å¼åŒ–å¼€å¥–å·ç ï¼Œä¸ºæ¯ä¸ªæ•°å­—æ·»åŠ æ ·å¼
          const formatNumbers = (numbers) => {
            if (!numbers || numbers === 'â€”') return 'â€”';
            return numbers.split(/[,ï¼Œ+]/).map(num => 
              `<span class="number">${num.trim()}</span>`
            ).join('');
          };
          
          const last3 = (d.resultsOfLastThreeIssues || []).map(r => {
            const zs = r.zodiac
              ? r.zodiac.split(',').map(z => `${zodiacEmoji[z]||''}${z}`).join(', ')
              : '';
            return `<li>
              <div>
                <div class="history-issue">${r.issue}</div>
                <div class="history-numbers">${formatNumbers(r.result)}</div>
                ${zs?`<div class="zodiac">${zs}</div>`:''}
              </div>
              <div class="muted">${r.creatTime}</div>
            </li>`;
          }).join('');

          lotteryInfo.innerHTML = `
            <div class="lottery-container">
              <div class="lottery-main">
                <div style="flex: 1;">
                  <div class="lottery-issue">ç¬¬ ${d.currentIssue||'â€”'} æœŸ</div>
                  <div class="lottery-numbers">${formatNumbers(d.currentResult)}</div>
                  ${zodiacHtml?`<div class="lottery-zodiac">${zodiacHtml}</div>`:''}
                  <div class="lottery-next">ä¸‹æœŸï¼š${d.nextIssue||'â€”'}${d.nextTime?` â€¢ ${d.nextTime}`:''}</div>
                </div>
              </div>
              ${last3?`
                <div class="lottery-history">
                  <h4>ğŸ“Š æœ€è¿‘ä¸‰æœŸå¼€å¥–</h4>
                  <ul>${last3}</ul>
                </div>
              `:''}
              <div class="muted" style="text-align: center; margin-top: 8px;">æ•°æ®æ¥æºï¼š${api.name}</div>
            </div>
          `;
          
          // å¯åŠ¨å€’è®¡æ—¶ï¼ˆå›ºå®šæ¯æ™š21:30å¼€å¥–ï¼‰
          startLotteryCountdown();
          
          showToast(`${api.name}åŠ è½½æˆåŠŸ`, 'success');
          return; // æˆåŠŸåé€€å‡ºå¾ªç¯
          
        } catch(e) {
          console.warn(`${api.name}å¤±è´¥:`, e.message);
          
          // å¦‚æœæ˜¯æœ€åä¸€ä¸ªAPIä¹Ÿå¤±è´¥äº†
          if (i === LOTTERY_APIS.length - 1) {
            lotteryInfo.innerHTML = `
              <div class="error">âš ï¸ æ‰€æœ‰æ•°æ®æºå‡æ— æ³•è®¿é—®</div>
              <div class="muted">å¯èƒ½çš„åŸå› ï¼š</div>
              <ul style="padding-left:16px; margin:8px 0;">
                <li>ç½‘ç»œè¿æ¥é—®é¢˜</li>
                <li>APIæœåŠ¡æš‚æ—¶ä¸å¯ç”¨</li>
                <li>è·¨åŸŸè®¿é—®é™åˆ¶</li>
              </ul>
              <button onclick="loadLottery(${gameid})" style="margin-top:8px;">ğŸ”„ é‡æ–°åŠ è½½</button>
            `;
            showToast('æ‰€æœ‰æ•°æ®æºåŠ è½½å¤±è´¥', 'error', 3000);
          }
        }
      }
    }

    // â€”â€” å¼€å¥–å€’è®¡æ—¶ â€”â€”
    let lotteryTimer = null;
    function startLotteryCountdown(){
      if(lotteryTimer) clearTimeout(lotteryTimer);
      function tick(){
        const now = new Date();
        const today = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 21, 30, 0); // ä»Šå¤©21:30
        let target = today;
        
        // å¦‚æœä»Šå¤©21:30å·²è¿‡ï¼Œåˆ™è®¡ç®—æ˜å¤©21:30
        if (now > today) {
          target = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1, 21, 30, 0);
        }
        
        const diff = target.getTime() - now.getTime();
        if(diff <= 0){
          countdownEl.textContent = 'ğŸ‰ æ­£åœ¨å¼€å¥–ä¸­ï¼';
          // å¼€å¥–å1åˆ†é’Ÿé‡æ–°è®¡ç®—ä¸‹æœŸæ—¶é—´
          lotteryTimer = setTimeout(tick, 60000);
        } else {
          const h = Math.floor(diff / 3600000);
          const m = Math.floor((diff % 3600000) / 60000);
          const s = Math.floor((diff % 60000) / 1000);
          
          if (h > 0) {
            countdownEl.textContent = `â³ è·ç¦»å¼€å¥–ï¼š${h}å°æ—¶${m}åˆ†${s}ç§’`;
          } else {
            countdownEl.textContent = `â³ è·ç¦»å¼€å¥–ï¼š${m}åˆ†${s}ç§’`;
          }
          lotteryTimer = setTimeout(tick, 1000);
        }
      }
      tick();
    }
    
    // â€”â€” AIé¢„æµ‹åŠŸèƒ½ â€”â€”
    const OPENROUTER_API_KEY = localStorage.getItem('OPENROUTER_API_KEY') || ''; // ä¼˜å…ˆä½¿ç”¨æœ¬åœ°å­˜å‚¨çš„APIå¯†é’¥
    const OPENROUTER_API_URL = 'https://openrouter.ai/api/v1/chat/completions';
    const OPENROUTER_MODEL_ID = 'deepseek/deepseek-chat'; // ä½¿ç”¨å¯ç”¨çš„æ¨¡å‹
    
    // â€”â€” OpenRouter Key ç®¡ç†ä¸ç»Ÿä¸€è¯·æ±‚å°è£… â€”â€”
    function getOpenRouterKey() {
      const keyFromStorage = localStorage.getItem('OPENROUTER_API_KEY');
      const keyFromWindow = window.OPENROUTER_API_KEY;
      const key = (keyFromStorage || keyFromWindow || OPENROUTER_API_KEY || '').trim();
      if (!key) {
        throw new Error('æœªé…ç½® OpenRouter API Keyï¼Œè¯·å…ˆåœ¨é¡µé¢ä¸­é…ç½®æˆ–é€šè¿‡ window.OPENROUTER_API_KEY æ³¨å…¥');
      }
      return key;
    }
    
    // â€”â€” AI é…ç½®ï¼ˆæ¸©åº¦ã€çª—å£ç­‰ï¼‰ â€”â€”
    function getAIConfig() {
      const stored = localStorage.getItem('AI_CONFIG');
      const defaults = {
        temperature: 0.7,
        max_tokens: 800,
        windowSize: 10,      // æœ€è¿‘éªŒè¯çª—å£å¤§å°
        minWinRate: 50,      // ä½äºæ­¤é˜ˆå€¼åˆ™è°ƒæ•´å‚æ•°
        adjustMode: 'conservative', // è°ƒæ•´æ–¹å¼ï¼šconservative/aggressive
        reasoningDepth: 4    // æ¨ç†æ­¥éª¤æœŸæœ›æ•°é‡
      };
      try {
        return stored ? { ...defaults, ...JSON.parse(stored) } : defaults;
      } catch {
        return defaults;
      }
    }

    function saveAIConfig(cfg) {
      localStorage.setItem('AI_CONFIG', JSON.stringify(cfg));
    }
    
    async function callOpenRouter(prompt) {
      console.log('ğŸ¤– AIè°ƒç”¨å¼€å§‹ - callOpenRouter');
      console.log('ğŸ“‹ æç¤ºè¯é•¿åº¦:', prompt.length, 'å­—ç¬¦');
      
      const key = getOpenRouterKey();
      console.log('ğŸ”‘ APIå¯†é’¥çŠ¶æ€:', key ? 'å·²é…ç½®' : 'æœªé…ç½®');
      
      const cfg = getAIConfig();
      console.log('âš™ï¸ AIé…ç½®:', cfg);
      
      console.log('ğŸŒ æ­£åœ¨è°ƒç”¨OpenRouter API...');
      const response = await fetch(OPENROUTER_API_URL, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${key}`,
          'Content-Type': 'application/json',
          'HTTP-Referer': window.location.origin,
          'X-Title': 'AI Number Prediction System'
        },
        body: JSON.stringify({
          model: OPENROUTER_MODEL_ID,
          messages: [{ role: 'user', content: prompt }],
          temperature: Math.max(0, Math.min(1, cfg.temperature)),
          max_tokens: Math.max(300, Math.min(2000, cfg.max_tokens))
        })
      });
      
      console.log('ğŸ“¡ APIå“åº”çŠ¶æ€:', response.status);
      
      if (!response.ok) {
        const text = await response.text().catch(() => '');
        console.error('âŒ OpenRouter APIè°ƒç”¨å¤±è´¥:', response.status, text);
        throw new Error(`OpenRouter è¯·æ±‚å¤±è´¥: ${response.status} ${text}`);
      }
      
      const data = await response.json();
      const result = data?.choices?.[0]?.message?.content || '';
      console.log('âœ… AIè°ƒç”¨æˆåŠŸï¼Œè¿”å›å†…å®¹é•¿åº¦:', result.length, 'å­—ç¬¦');
      console.log('ğŸ“ AIè¿”å›å†…å®¹é¢„è§ˆ:', result.substring(0, 200) + '...');
      
      return result;
    }
    
    function promptAndSaveOpenRouterKey() {
      const current = localStorage.getItem('OPENROUTER_API_KEY') || '';
      const input = prompt('è¯·è¾“å…¥ OpenRouter API Keyï¼ˆå°†ä¿å­˜åœ¨æœ¬åœ°æµè§ˆå™¨ï¼‰', current);
      if (input && input.trim()) {
        localStorage.setItem('OPENROUTER_API_KEY', input.trim());
        showToast('API å¯†é’¥å·²ä¿å­˜', 'success');
      }
    }
    
    function openConfigPanel() {
      const hasApiKey = localStorage.getItem('OPENROUTER_API_KEY');
      if (!hasApiKey) {
        const shouldConfig = confirm('æ‚¨è¿˜æ²¡æœ‰é…ç½®APIå¯†é’¥ï¼Œæ˜¯å¦ç°åœ¨é…ç½®ï¼Ÿ\n\nç‚¹å‡»ç¡®å®šå°†è·³è½¬åˆ°é…ç½®é¢æ¿ï¼Œç‚¹å‡»å–æ¶ˆå°†ç›´æ¥æ‰“å¼€é…ç½®é¢æ¿ã€‚');
        if (shouldConfig) {
          promptAndSaveOpenRouterKey();
          return;
        }
      }
      window.open('config_panel.html', '_blank');
    }
    
    // ç”Ÿè‚–æ•°ç»„
    const zodiacAnimals = ['é¼ ', 'ç‰›', 'è™', 'å…”', 'é¾™', 'è›‡', 'é©¬', 'ç¾Š', 'çŒ´', 'é¸¡', 'ç‹—', 'çŒª'];
    
    // é¢„æµ‹è®°å½•ç³»ç»Ÿ
    const PREDICTION_STORAGE_KEY = 'lottery_predictions';
    const ACCURACY_STORAGE_KEY = 'prediction_accuracy';
    
    // é¢„æµ‹ç­–ç•¥é…ç½®ï¼ˆæ‰©å±•å¤šç§ç­–ç•¥ï¼‰
    const PREDICTION_STRATEGIES = {
      ai: {
        name: 'AIæ™ºèƒ½åˆ†æ',
        description: 'åŸºäºæ·±åº¦å­¦ä¹ æ¨¡å‹çš„æ™ºèƒ½é¢„æµ‹',
        indicator: 'strategy-ai',
        useAI: true,
        confidence: 0.85,
        algorithm: 'neural_network',
        weight: 0.4
      },
      statistical: {
        name: 'ç»Ÿè®¡åˆ†æ',
        description: 'åŸºäºå†å²æ•°æ®ç»Ÿè®¡åˆ†æ',
        indicator: 'strategy-stat',
        useAI: false,
        confidence: 0.7,
        algorithm: 'frequency_analysis',
        weight: 0.25
      },
      trend: {
        name: 'è¶‹åŠ¿åˆ†æ',
        description: 'åŸºäºå·ç è¶‹åŠ¿å’Œæ¨¡å¼è¯†åˆ«',
        indicator: 'strategy-trend',
        useAI: false,
        confidence: 0.65,
        algorithm: 'pattern_recognition',
        weight: 0.2
      },
      hybrid: {
        name: 'æ··åˆç­–ç•¥',
        description: 'ç»“åˆå¤šç§ç®—æ³•çš„ç»¼åˆé¢„æµ‹',
        indicator: 'strategy-hybrid',
        useAI: true,
        confidence: 0.8,
        algorithm: 'ensemble',
        weight: 0.3
      },
      ml: {
        name: 'æœºå™¨å­¦ä¹ ',
        description: 'åŸºäºæœºå™¨å­¦ä¹ æ¨¡å‹çš„é¢„æµ‹',
        indicator: 'strategy-ml',
        useAI: true,
        confidence: 0.75,
        algorithm: 'random_forest',
        weight: 0.35
      }
    };
    
    // å½“å‰ç­–ç•¥é…ç½®
    let currentStrategy = {
      hk: 'ai',
      macau: 'ai'
    };
    
    // è·å–å½“å‰æœŸå·
    function getCurrentPeriod(type) {
      const now = new Date();
      const year = now.getFullYear();
      
      if (type === 'hk') {
        // é¦™æ¸¯æ•°å­—ï¼šæ¯å‘¨äºŒã€å››ã€å…­å¼€å¥–
        // é‡æ–°æ ¡å‡†ï¼š2025å¹´11æœˆ7æ—¥ï¼ˆå‘¨äº”ï¼‰å¯¹åº”æœŸå·
        // åŸºäºå®é™…å¼€å¥–è®°å½•ï¼Œ2025å¹´ç¬¬118æœŸï¼ˆéœ€è¦å‡†ç¡®è®¡ç®—ï¼‰
        
        // è·å–å½“å‰å¹´ä»½çš„1æœˆ1æ—¥
        const yearStart = new Date(year, 0, 1);
        const daysSinceYearStart = Math.floor((now - yearStart) / (1000 * 60 * 60 * 24));
        
        // è®¡ç®—ä»å¹´åˆåˆ°ç°åœ¨çš„å¼€å¥–æœŸæ•°ï¼ˆæ¯å‘¨3æœŸï¼šå‘¨äºŒã€å››ã€å…­ï¼‰
        let periodCount = 0;
        
        // éå†ä»å¹´åˆåˆ°ç°åœ¨çš„æ¯ä¸€å¤©ï¼Œè®¡ç®—å¼€å¥–æ—¥
        for (let i = 0; i <= daysSinceYearStart; i++) {
          const currentDate = new Date(yearStart);
          currentDate.setDate(yearStart.getDate() + i);
          const dayOfWeek = currentDate.getDay(); // 0=å‘¨æ—¥, 1=å‘¨ä¸€, ..., 6=å‘¨å…­
          
          // å‘¨äºŒã€å››ã€å…­ä¸ºå¼€å¥–æ—¥
          if (dayOfWeek === 2 || dayOfWeek === 4 || dayOfWeek === 6) {
            periodCount++;
          }
        }
        
        // æ ¡å‡†ï¼š2025å¹´11æœˆ7æ—¥åº”è¯¥æ˜¯ç¬¬118æœŸ
        // æ ¹æ®å®é™…å¼€å¥–è®°å½•è°ƒæ•´è®¡ç®—ç»“æœ
        const baseDate = new Date(2025, 10, 7); // 2025å¹´11æœˆ7æ—¥
        const basePeriod = 118; // å·²çŸ¥11æœˆ7æ—¥å¯¹åº”ç¬¬118æœŸ
        
        if (now.getTime() >= baseDate.getTime()) {
          // å¦‚æœå½“å‰æ—¥æœŸåœ¨11æœˆ7æ—¥æˆ–ä¹‹åï¼Œä»118æœŸå¼€å§‹è®¡ç®—
          const daysSinceBase = Math.floor((now - baseDate) / (1000 * 60 * 60 * 24));
          let additionalPeriods = 0;
          
          // è®¡ç®—ä»11æœˆ7æ—¥åˆ°å½“å‰æ—¥æœŸçš„é¢å¤–æœŸæ•°
          for (let i = 1; i <= daysSinceBase; i++) {
            const currentDate = new Date(baseDate);
            currentDate.setDate(baseDate.getDate() + i);
            const dayOfWeek = currentDate.getDay();
            
            if (dayOfWeek === 2 || dayOfWeek === 4 || dayOfWeek === 6) {
              additionalPeriods++;
            }
          }
          
          periodCount = basePeriod + additionalPeriods;
        } else {
          // å¦‚æœå½“å‰æ—¥æœŸåœ¨11æœˆ7æ—¥ä¹‹å‰ï¼ŒæŒ‰æ¯”ä¾‹è°ƒæ•´
          const calculatedPeriod = periodCount;
          const adjustment = basePeriod - 118; // æ ¹æ®å®é™…è®°å½•è°ƒæ•´
          periodCount = calculatedPeriod + adjustment;
        }
        
        // ç¡®ä¿æœŸå·å‡†ç¡®ï¼Œæœ€å°ä¸º1
        periodCount = Math.max(1, periodCount);
        
        return `${year}${String(periodCount).padStart(3, '0')}`;
      } else {
        // æ¾³é—¨æ•°å­—ï¼šåŸºäºå®é™…å¼€å¥–è®°å½•æ ¡å‡†
        // å·²çŸ¥æ˜¨å¤©ï¼ˆ11æœˆ6æ—¥ï¼‰å¼€è¿‡310æœŸï¼Œä»Šå¤©ï¼ˆ11æœˆ7æ—¥ï¼‰åº”è¯¥æ˜¯311æœŸ
        const baseDate = new Date(2025, 10, 6); // 2025å¹´11æœˆ6æ—¥
        const basePeriod = 310; // å·²çŸ¥11æœˆ6æ—¥å¯¹åº”ç¬¬310æœŸ
        
        const now = new Date();
        const daysSinceBase = Math.floor((now - baseDate) / (1000 * 60 * 60 * 24));
        
        // è®¡ç®—ä»åŸºå‡†æ—¥æœŸåˆ°ä»Šå¤©çš„æœŸæ•°å¢é‡
        // å‡è®¾æ¾³é—¨å½©ç¥¨æœ‰å›ºå®šçš„å¼€å¥–é¢‘ç‡ï¼ˆéœ€è¦æ ¹æ®å®é™…æƒ…å†µè°ƒæ•´ï¼‰
        let periodIncrement = 0;
        
        for (let i = 1; i <= daysSinceBase; i++) {
          const currentDate = new Date(baseDate);
          currentDate.setDate(baseDate.getDate() + i);
          
          // è¿™é‡Œéœ€è¦æ ¹æ®æ¾³é—¨å½©ç¥¨çš„å®é™…å¼€å¥–é¢‘ç‡æ¥è°ƒæ•´
          // æš‚æ—¶å‡è®¾æ¯å¤©éƒ½æœ‰å¼€å¥–ï¼Œä½†éœ€è¦æ ¡å‡†åŸºå‡†
          periodIncrement++;
        }
        
        const currentPeriod = basePeriod + periodIncrement;
        const result = `${year}${String(currentPeriod).padStart(3, '0')}`;
        console.log(`æ¾³é—¨æœŸå·è®¡ç®—ç»“æœ: ${result} (åŸºå‡†æ—¥æœŸ: 2025-11-06=310æœŸ, ä»Šå¤©å¢åŠ ${periodIncrement}æœŸ)`);
        return result;
      }
    }
    
    // è·å–ä¸‹ä¸€æœŸæœŸå·ï¼ˆç”¨äºé¢„æµ‹ï¼‰
    function getNextPeriod(type) {
      const currentPeriod = getCurrentPeriod(type);
      const periodNumber = parseInt(currentPeriod.slice(-3));
      const year = currentPeriod.slice(0, 4);
      
      // ä¸‹ä¸€æœŸæœŸå· = å½“å‰æœŸå· + 1
      const nextPeriodNumber = periodNumber + 1;
      return `${year}${String(nextPeriodNumber).padStart(3, '0')}`;
    }
    
    // ä¿å­˜é¢„æµ‹è®°å½•
    function savePredictionRecord(type, period, prediction, strategy) {
      // è·å–å½“å‰å†å²è®°å½•
      const history = getPredictionHistory(type);
      
      // è·å–å‰ä¸€æ¬¡çš„ç­–ç•¥ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
      const previousStrategy = history.length > 0 ? history[0].strategy : 'none';
      
      const record = {
        period: period,
        prediction: prediction,
        strategy: strategy,
        previousStrategy: previousStrategy, // è®°å½•å‰ä¸€æ¬¡ç­–ç•¥
        timestamp: Date.now(),
        status: 'pending',
        accuracy: null,
        actualResult: null,
        numbers: prediction.numbers || [],
        zodiac: prediction.zodiac || ''
      };
      
      // æ·»åŠ åˆ°å†å²è®°å½•å¼€å¤´
      history.unshift(record);
      
      // åªä¿ç•™æœ€è¿‘50æ¡è®°å½•
      if (history.length > 50) {
        history.splice(50);
      }
      
      // ä¿å­˜æ›´æ–°åçš„å†å²è®°å½•
      savePredictionHistory(type, history);
      updatePredictionHistory(type);
    }
    
    // æ›´æ–°é¢„æµ‹å†å²æ˜¾ç¤º
    function updatePredictionHistory(type) {
      const history = getPredictionHistory(type);
      const historyDiv = document.getElementById(`${type}PredictionHistory`);
      
      if (history.length === 0) {
        historyDiv.innerHTML = '<div style="text-align: center; color: #9ca3af; padding: 20px;">æš‚æ— é¢„æµ‹è®°å½•</div>';
        return;
      }
      
      const html = history.slice(0, 10).map(record => {
        const statusClass = record.status === 'pending' ? 'status-pending' : 
                           record.status === 'correct' ? 'status-correct' : 'status-incorrect';
        const statusText = record.status === 'pending' ? 'å¾…å¼€å¥–' : 
                          record.status === 'correct' ? 'é¢„æµ‹æ­£ç¡®' : 'é¢„æµ‹é”™è¯¯';
        
        const strategyInfo = PREDICTION_STRATEGIES[record.strategy] || { name: record.strategy, indicator: 'indicator-default' };
        const numbersText = record.numbers && record.numbers.length > 0 ? record.numbers.join(', ') : 'æš‚æ— æ•°æ®';
        
        // å‡†ç¡®åº¦æ˜¾ç¤º
        const accuracyDisplay = record.accuracy !== undefined ? 
          `<span class="accuracy-info">(å‡†ç¡®åº¦: ${record.accuracy}%)</span>` : '';
        
        // å‰ä¸€æ¬¡ç­–ç•¥æ˜¾ç¤º
        const previousStrategyText = record.previousStrategy && record.previousStrategy !== 'none' ? 
          `<span class="previous-strategy">å‰ç­–ç•¥: ${record.previousStrategy}</span>` : '';
        
        // å¼€å¥–ç»“æœå¯¹æ¯”
        let resultDisplay = '';
        if (record.actualResult) {
          const actualText = record.actualResult.join(', ');
          const correctNumbers = record.numbers.filter(num => record.actualResult.includes(num));
          const correctCount = correctNumbers.length;
          resultDisplay = `
            <div class="result-comparison">
              <div>å¼€å¥–: ${actualText}</div>
              <div class="match-info">å‘½ä¸­ ${correctCount}/7 ä¸ªå·ç  ${accuracyDisplay}</div>
            </div>
          `;
        } else {
          resultDisplay = '<div class="result-comparison">ç­‰å¾…å¼€å¥–ç»“æœ</div>';
        }
        
        return `
          <div class="history-item">
            <div class="history-header">
              <span class="history-period">æœŸå·: ${record.period}</span>
              <span class="history-status ${statusClass}">${statusText}</span>
            </div>
            <div class="history-numbers">
              <span class="strategy-indicator ${strategyInfo.indicator}"></span>
              é¢„æµ‹: ${numbersText}
            </div>
            <div class="strategy-info">
              ç­–ç•¥: ${strategyInfo.name} ${previousStrategyText}
            </div>
            ${resultDisplay}
          </div>
        `;
      }).join('');
      
      historyDiv.innerHTML = html;
    }
    
    // è®¡ç®—å‡†ç¡®ç‡
    function calculateAccuracy(type) {
      const records = JSON.parse(localStorage.getItem(PREDICTION_STORAGE_KEY) || '{}');
      const typeRecords = records[type] || [];
      const completedRecords = typeRecords.filter(r => r.status !== 'pending');
      
      if (completedRecords.length === 0) return null;
      
      const correctCount = completedRecords.filter(r => r.status === 'correct').length;
      return Math.round((correctCount / completedRecords.length) * 100);
    }
    
    // æ›´æ–°å‡†ç¡®ç‡æ˜¾ç¤º
    function updateAccuracyDisplay(type) {
      const accuracy = calculateAccuracy(type);
      const accuracySpan = document.getElementById(`${type}AccuracyRate`);
      
      if (accuracy === null) {
        accuracySpan.textContent = '-';
        accuracySpan.className = '';
      } else {
        accuracySpan.textContent = `${accuracy}%`;
        if (accuracy >= 70) {
          accuracySpan.className = 'accuracy-high';
        } else if (accuracy >= 50) {
          accuracySpan.className = 'accuracy-medium';
        } else {
          accuracySpan.className = 'accuracy-low';
        }
        
        // æ ¹æ®å‡†ç¡®ç‡è¯„ä¼°å¹¶è‡ªåŠ¨è°ƒæ•´ AI é…ç½®
        evaluateAndAdjustAIConfig(type, accuracy);
      }
    }
    
    // è·å–é¢„æµ‹å†å²è®°å½•
    function getPredictionHistory(type) {
      try {
        const key = `${PREDICTION_STORAGE_KEY}_${type}`;
        const data = localStorage.getItem(key);
        return data ? JSON.parse(data) : [];
      } catch (error) {
        console.error('è·å–é¢„æµ‹å†å²è®°å½•å¤±è´¥:', error);
        return [];
      }
    }
    
    // ä¿å­˜é¢„æµ‹å†å²è®°å½•
    function savePredictionHistory(type, history) {
      try {
        const key = `${PREDICTION_STORAGE_KEY}_${type}`;
        localStorage.setItem(key, JSON.stringify(history));
      } catch (error) {
        console.error('ä¿å­˜é¢„æµ‹å†å²è®°å½•å¤±è´¥:', error);
      }
    }
    
    // è‡ªåŠ¨ç­–ç•¥åˆ‡æ¢å‡½æ•°
    function autoSwitchStrategy(type) {
      const history = getPredictionHistory(type);
      const verifiedRecords = history.filter(r => r.status !== 'pending' && typeof r.accuracy === 'number');
      
      if (verifiedRecords.length < 3) return false; // éœ€è¦è‡³å°‘3æ¡éªŒè¯è®°å½•
      
      // è·å–æœ€è¿‘3æ¡è®°å½•çš„å‡†ç¡®ç‡
      const recentRecords = verifiedRecords.slice(-3);
      const avgAccuracy = recentRecords.reduce((sum, r) => sum + r.accuracy, 0) / recentRecords.length;
      
      // å¦‚æœå‡†ç¡®ç‡ä½äº50%ï¼Œåˆ‡æ¢ç­–ç•¥
      if (avgAccuracy < 50) {
        const currentStrat = currentStrategy[type]; // é¿å…å˜é‡åå†²çª
        const strategies = Object.keys(PREDICTION_STRATEGIES);
        const currentIndex = strategies.indexOf(currentStrat);
        
        // åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªç­–ç•¥
        const nextIndex = (currentIndex + 1) % strategies.length;
        const newStrategy = strategies[nextIndex];
        
        currentStrategy[type] = newStrategy;
        
        // ä¿å­˜å½“å‰ç­–ç•¥åˆ°localStorage
        localStorage.setItem(`${type}_current_strategy`, newStrategy);
        
        showToast(`${type === 'hk' ? 'é¦™æ¸¯' : 'æ¾³é—¨'}é¢„æµ‹å‡†ç¡®ç‡è¿‡ä½(${avgAccuracy.toFixed(1)}%)ï¼Œè‡ªåŠ¨åˆ‡æ¢ç­–ç•¥ä¸º: ${PREDICTION_STRATEGIES[newStrategy].name}`, 'warning', 4000);
        
        return true;
      }
      
      return false;
    }
    
    // è¯„ä¼°å¹¶è‡ªåŠ¨è°ƒæ•´ AI é…ç½®ï¼ˆåŒ…å«ç­–ç•¥åˆ‡æ¢ï¼‰
    function evaluateAndAdjustAIConfig(type, latestAccuracy) {
      const cfg = getAIConfig();
      // è¯»å–æœ€è¿‘éªŒè¯è®°å½•çª—å£
      const history = getPredictionHistory(type) || [];
      const verified = history.filter(r => r.status !== 'pending' && typeof r.accuracy === 'number');
      const window = Math.max(3, cfg.windowSize);
      const recent = verified.slice(-window);
      if (recent.length === 0) return; // æ— éªŒè¯æ•°æ®ä¸è°ƒæ•´
      const avg = Math.round(recent.reduce((s, r) => s + r.accuracy, 0) / recent.length);
      
      let changed = false;
      let strategyChanged = false;
      
      // é¦–å…ˆæ£€æŸ¥æ˜¯å¦éœ€è¦åˆ‡æ¢ç­–ç•¥
      if (avg < 50 && recent.length >= 3) {
        strategyChanged = autoSwitchStrategy(type);
      }
      
      // ä½äºé˜ˆå€¼æ—¶è°ƒæ•´ï¼šæé«˜æ¢ç´¢æˆ–åŠ å¼ºæ¨ç†
      if (avg < cfg.minWinRate) {
        if (cfg.adjustMode === 'aggressive') {
          cfg.temperature = Math.min(0.95, cfg.temperature + 0.15);
          cfg.reasoningDepth = Math.min(8, (cfg.reasoningDepth || 4) + 2);
        } else {
          cfg.temperature = Math.min(0.9, cfg.temperature + 0.1);
          cfg.reasoningDepth = Math.min(6, (cfg.reasoningDepth || 4) + 1);
        }
        changed = true;
      } else if (avg >= cfg.minWinRate + 15) {
        // è¡¨ç°è¾ƒå¥½æ—¶é™ä½æ¸©åº¦ï¼Œè¶‹äºç¨³å®šï¼›å‡å°‘æ¨ç†æ·±åº¦ä»¥æé€Ÿ
        cfg.temperature = Math.max(0.4, cfg.temperature - 0.1);
        cfg.reasoningDepth = Math.max(2, (cfg.reasoningDepth || 4) - 1);
        changed = true;
      }
      
      if (changed) {
        saveAIConfig(cfg);
        const strategyText = strategyChanged ? 'ï¼Œç­–ç•¥å·²åˆ‡æ¢' : '';
        showToast(`${type === 'hk' ? 'é¦™æ¸¯' : 'æ¾³é—¨'}AIå‚æ•°å·²è‡ªåŠ¨è°ƒæ•´ï¼šæ¸©åº¦=${cfg.temperature.toFixed(2)}ï¼Œæ¨ç†æ·±åº¦=${cfg.reasoningDepth}${strategyText}`, 'info', 3000);
      }
    }
    
    // è·å–å†å²å¼€å¥–æ•°æ®ç”¨äºç®—æ³•ä¼˜åŒ–
    async function fetchHistoricalData(type, count = 50) {
      try {
        const historicalData = [];
        const currentPeriod = parseInt(getCurrentPeriod(type));
        
        // è·å–æœ€è¿‘countæœŸçš„å†å²æ•°æ®
        for (let i = 0; i < count; i++) {
          const period = currentPeriod - i;
          if (period <= 0) break;
          
          const result = await fetchRealLotteryResults(type, period.toString());
          if (result) {
            historicalData.push({
              period: result.period,
              numbers: result.numbers,
              zodiac: result.zodiac,
              drawDate: result.drawDate,
              dataSource: result.dataSource
            });
          }
          
          // æ·»åŠ å»¶è¿Ÿé¿å…APIé™æµ
          if (i > 0 && i % 10 === 0) {
            await new Promise(resolve => setTimeout(resolve, 1000));
          }
        }
        
        return historicalData;
      } catch (error) {
        console.error('è·å–å†å²æ•°æ®å¤±è´¥:', error);
        return [];
      }
    }
    
    // åˆ†æå†å²æ•°æ®æ¨¡å¼
    function analyzeHistoricalPatterns(historicalData) {
      const patterns = {
        frequency: {}, // å·ç å‡ºç°é¢‘ç‡
        hotNumbers: [], // çƒ­å·
        coldNumbers: [], // å†·å·
        zodiacFrequency: {}, // ç”Ÿè‚–é¢‘ç‡
        consecutivePatterns: [], // è¿å·æ¨¡å¼
        oddEvenRatio: [], // å¥‡å¶æ¯”
        sumTrend: [], // å’Œå€¼è¶‹åŠ¿
        rangeDistribution: [] // åŒºé—´åˆ†å¸ƒ
      };
      
      if (historicalData.length === 0) return patterns;
      
      // ç»Ÿè®¡å·ç é¢‘ç‡
      const numberFrequency = {};
      const zodiacFrequency = {};
      const oddEvenCounts = { odd: 0, even: 0 };
      const sumValues = [];
      const rangeCounts = { low: 0, mid: 0, high: 0 }; // 1-16, 17-33, 34-49
      
      historicalData.forEach(draw => {
        draw.numbers.forEach((num, index) => {
          // å·ç é¢‘ç‡
          numberFrequency[num] = (numberFrequency[num] || 0) + 1;
          
          // å¥‡å¶ç»Ÿè®¡
          if (num % 2 === 0) {
            oddEvenCounts.even++;
          } else {
            oddEvenCounts.odd++;
          }
          
          // åŒºé—´ç»Ÿè®¡
          if (num <= 16) rangeCounts.low++;
          else if (num <= 33) rangeCounts.mid++;
          else rangeCounts.high++;
          
          // è¿å·æ£€æµ‹ï¼ˆåªæ£€æµ‹å‰6ä¸ªå·ç ï¼‰
          if (index < 6) {
            const nextNum = draw.numbers[index + 1];
            if (nextNum && Math.abs(num - nextNum) === 1) {
              patterns.consecutivePatterns.push([num, nextNum]);
            }
          }
        });
        
        // ç”Ÿè‚–é¢‘ç‡
        if (draw.zodiac) {
          zodiacFrequency[draw.zodiac] = (zodiacFrequency[draw.zodiac] || 0) + 1;
        }
        
        // å’Œå€¼
        const sum = draw.numbers.reduce((a, b) => a + b, 0);
        sumValues.push(sum);
      });
      
      // æ’åºè·å–çƒ­å·å’Œå†·å·
      const sortedFrequency = Object.entries(numberFrequency)
        .sort((a, b) => b[1] - a[1]);
      
      patterns.frequency = numberFrequency;
      patterns.hotNumbers = sortedFrequency.slice(0, 10).map(([num]) => parseInt(num));
      patterns.coldNumbers = sortedFrequency.slice(-10).map(([num]) => parseInt(num));
      patterns.zodiacFrequency = zodiacFrequency;
      patterns.oddEvenRatio = {
        odd: Math.round((oddEvenCounts.odd / (historicalData.length * 7)) * 100),
        even: Math.round((oddEvenCounts.even / (historicalData.length * 7)) * 100)
      };
      patterns.sumTrend = {
        average: Math.round(sumValues.reduce((a, b) => a + b, 0) / sumValues.length),
        min: Math.min(...sumValues),
        max: Math.max(...sumValues)
      };
      patterns.rangeDistribution = {
        low: Math.round((rangeCounts.low / (historicalData.length * 7)) * 100),
        mid: Math.round((rangeCounts.mid / (historicalData.length * 7)) * 100),
        high: Math.round((rangeCounts.high / (historicalData.length * 7)) * 100)
      };
      
      return patterns;
    }
    
    // è·å–çœŸå®å¼€å¥–ç»“æœAPI
    async function fetchRealLotteryResults(type, period) {
      try {
        // æ¨èçš„APIæ•°æ®æºæä¾›å•†ï¼š
        // 1. èšåˆæ•°æ® (https://www.juhe.cn/docs/api/id/235) - é¦™æ¸¯å…­åˆå½©API
        // 2. æ˜“æºæ•°æ® (https://www.showapi.com/api/lookPoint/441) - å½©ç¥¨å¼€å¥–API
        // 3. å½©ç¥¨å¼€å¥–ç½‘ (https://www.kaijiang.org/api/) - å…è´¹å¼€æºAPI
        // 4. é˜¿é‡Œäº‘å¸‚åœº - æä¾›å¤šç§å½©ç¥¨æ•°æ®API
        
        // é¦™æ¸¯å…­åˆå½©APIæ¥å£
        if (type === 'hk') {
          // ç¤ºä¾‹ï¼šä½¿ç”¨é¦™æ¸¯å…­åˆå½©å®˜æ–¹APIæˆ–ç¬¬ä¸‰æ–¹æ•°æ®æä¾›å•†
          // å®é™…ä½¿ç”¨æ—¶éœ€è¦æ›¿æ¢ä¸ºçœŸå®çš„APIå¯†é’¥å’Œæ¥å£
          const apiUrls = [
            `https://www.juhe.cn/api/lottery/hk6?key=YOUR_JUHE_KEY&period=${period}`, // èšåˆæ•°æ®
            `https://route.showapi.com/44-1?showapi_appid=YOUR_APPID&showapi_sign=YOUR_SIGN&code=hk6&expect=${period}`, // æ˜“æºæ•°æ®
            `https://www.kaijiang.org/api/lottery?code=hk6&period=${period}`, // å½©ç¥¨å¼€å¥–ç½‘
            `https://api.example.com/hk-lottery/${period}`, // è‡ªå®šä¹‰API
          ];
          
          // å¯ç”¨çœŸå®APIè°ƒç”¨è·å–å¼€å¥–ç»“æœ
        for (const url of apiUrls) {
          try {
            const response = await fetch(url, {
              headers: {
                'Authorization': 'Bearer YOUR_API_KEY',
                'Content-Type': 'application/json',
                'User-Agent': 'Lottery-Prediction-Tool/1.0'
              },
              timeout: 10000 // 10ç§’è¶…æ—¶
            });
            
            if (response.ok) {
              const data = await response.json();
              
              // è§£æä¸åŒAPIçš„æ•°æ®æ ¼å¼
              if (data.result && data.result.lotteryNumber) {
                // èšåˆæ•°æ®æ ¼å¼
                return {
                  period: data.result.lotteryNo,
                  numbers: data.result.lotteryNumber.split(',').map(Number),
                  zodiac: data.result.zodiac || '',
                  drawDate: data.result.lotteryDate,
                  dataSource: 'juhe'
                };
              } else if (data.showapi_res_body && data.showapi_res_body.code === 0) {
                // æ˜“æºæ•°æ®æ ¼å¼
                const result = data.showapi_res_body.result;
                return {
                  period: result.expect,
                  numbers: result.openCode.split(',').map(Number),
                  zodiac: result.zodiac || '',
                  drawDate: result.openTime,
                  dataSource: 'showapi'
                };
              } else if (data.code === 0 && data.data) {
                // å½©ç¥¨å¼€å¥–ç½‘æ ¼å¼
                return {
                  period: data.data.period,
                  numbers: data.data.numbers,
                  zodiac: data.data.zodiac || '',
                  drawDate: data.data.drawDate,
                  dataSource: 'kaijiang'
                };
              }
            }
          } catch (apiError) {
            console.warn(`APIè°ƒç”¨å¤±è´¥: ${url}`, apiError);
            continue;
          }
        }
        }
        
        // æ¾³é—¨å½©ç¥¨APIæ¥å£
        if (type === 'macau') {
          // æ¾³é—¨å½©ç¥¨æ•°æ®æºç›¸å¯¹è¾ƒå°‘ï¼Œå¯èƒ½éœ€è¦ä½¿ç”¨ç»¼åˆå½©ç¥¨API
          const apiUrls = [
            `https://route.showapi.com/44-1?showapi_appid=YOUR_APPID&showapi_sign=YOUR_SIGN&code=mc6&expect=${period}`, // æ˜“æºæ•°æ®
            `https://www.kaijiang.org/api/lottery?code=mc6&period=${period}`, // å½©ç¥¨å¼€å¥–ç½‘
            `https://api.lottery.com/macau/${period}`, // è‡ªå®šä¹‰API
          ];
          
          // å¯ç”¨çœŸå®APIè°ƒç”¨è·å–æ¾³é—¨å½©ç¥¨å¼€å¥–ç»“æœ
          for (const url of apiUrls) {
            try {
              const response = await fetch(url, {
                headers: {
                  'Authorization': 'Bearer YOUR_API_KEY',
                  'Content-Type': 'application/json',
                  'User-Agent': 'Lottery-Prediction-Tool/1.0'
                },
                timeout: 10000 // 10ç§’è¶…æ—¶
              });
              
              if (response.ok) {
                const data = await response.json();
                
                // è§£æä¸åŒAPIçš„æ•°æ®æ ¼å¼
                if (data.showapi_res_body && data.showapi_res_body.code === 0) {
                  // æ˜“æºæ•°æ®æ ¼å¼
                  const result = data.showapi_res_body.result;
                  return {
                    period: result.expect,
                    numbers: result.openCode.split(',').map(Number),
                    zodiac: result.zodiac || '',
                    drawDate: result.openTime,
                    dataSource: 'showapi'
                  };
                } else if (data.code === 0 && data.data) {
                  // å½©ç¥¨å¼€å¥–ç½‘æ ¼å¼
                  return {
                    period: data.data.period,
                    numbers: data.data.numbers,
                    zodiac: data.data.zodiac || '',
                    drawDate: data.data.drawDate,
                    dataSource: 'kaijiang'
                  };
                }
              }
            } catch (apiError) {
              console.warn(`APIè°ƒç”¨å¤±è´¥: ${url}`, apiError);
              continue;
            }
          }
        }
        
        // å¦‚æœæ²¡æœ‰è·å–åˆ°çœŸå®æ•°æ®ï¼Œè¿”å›null
        return null;
        
      } catch (error) {
        console.error('è·å–å¼€å¥–ç»“æœå¤±è´¥:', error);
        return null;
      }
    }
    
    // è‡ªåŠ¨è·å–å¼€å¥–ç»“æœå¹¶éªŒè¯
    async function autoVerifyResults(type) {
      try {
        const currentPeriod = getCurrentPeriod(type);
        
        // é¦–å…ˆå°è¯•è·å–çœŸå®å¼€å¥–ç»“æœ
        let result = await fetchRealLotteryResults(type, currentPeriod);
        
        // å¦‚æœæ²¡æœ‰è·å–åˆ°çœŸå®æ•°æ®ï¼Œä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®ï¼ˆå¼€å‘æµ‹è¯•ç”¨ï¼‰
        if (!result) {
          console.log(`æœªè·å–åˆ°æœŸå· ${currentPeriod} çš„çœŸå®å¼€å¥–ç»“æœï¼Œä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®`);
          console.log(`æç¤º: å½“å‰æ¾³é—¨æœŸå·æ˜¾ç¤ºä¸º${currentPeriod}ï¼Œä½†æœªèƒ½è·å–åˆ°çœŸå®å¼€å¥–è®°å½•`);
          console.log(`å»ºè®®: è¯·æ£€æŸ¥æ¾³é—¨å½©ç¥¨APIé…ç½®æˆ–æä¾›æ­£ç¡®çš„å¼€å¥–æ•°æ®æº`);
          
          // æ¨¡æ‹ŸAPIè°ƒç”¨è·å–å¼€å¥–ç»“æœï¼ˆå®é™…ä½¿ç”¨æ—¶æ›¿æ¢ä¸ºçœŸå®APIï¼‰
          const mockResults = {
            hk: {
              period: currentPeriod,
              numbers: [5, 12, 23, 28, 35, 41, 48],
              zodiac: 'é¾™',
              dataSource: 'mock'
            },
            macau: {
              period: currentPeriod,
              numbers: [3, 15, 22, 29, 33, 38, 45],
              zodiac: 'è™',
              dataSource: 'mock'
            }
          };
          
          result = mockResults[type];
        } else {
          console.log(`æˆåŠŸè·å–åˆ°æœŸå· ${currentPeriod} çš„çœŸå®å¼€å¥–ç»“æœï¼Œæ•°æ®æ¥æº: ${result.dataSource || 'unknown'}`);
          console.log(`å¼€å¥–å·ç : ${result.numbers.join(', ')}`);
        }
        
        if (!result || result.period !== currentPeriod) {
          console.log(`æœŸå· ${currentPeriod} çš„å¼€å¥–ç»“æœå°šæœªå…¬å¸ƒ`);
          return;
        }
        
        // æŸ¥æ‰¾å¯¹åº”æœŸå·çš„é¢„æµ‹è®°å½•
        const history = getPredictionHistory(type);
        const predictionRecord = history.find(record => record.period === currentPeriod);
        
        if (!predictionRecord) {
          console.log(`æœªæ‰¾åˆ°æœŸå· ${currentPeriod} çš„é¢„æµ‹è®°å½•`);
          return;
        }
        
        // å¦‚æœå·²ç»éªŒè¯è¿‡ï¼Œè·³è¿‡
        if (predictionRecord.status !== 'pending') {
          return;
        }
        
        // è®¡ç®—å‡†ç¡®åº¦
        const predictedNumbers = predictionRecord.numbers;
        const actualNumbers = result.numbers;
        const correctCount = predictedNumbers.filter(num => actualNumbers.includes(num)).length;
        const accuracy = Math.round((correctCount / 7) * 100);
        
        // æ›´æ–°è®°å½•çŠ¶æ€
        predictionRecord.actualResult = actualNumbers;
        predictionRecord.accuracy = accuracy;
        predictionRecord.status = accuracy >= 50 ? 'correct' : 'incorrect';
        predictionRecord.verifiedAt = new Date().toISOString();
        predictionRecord.autoVerified = true; // æ ‡è®°ä¸ºè‡ªåŠ¨éªŒè¯
        predictionRecord.dataSource = result.dataSource || 'mock'; // è®°å½•æ•°æ®æ¥æº
        
        // ä¿å­˜æ›´æ–°åçš„å†å²è®°å½•
        savePredictionHistory(type, history);
        
        // æ›´æ–°æ˜¾ç¤º
        updatePredictionHistory(type);
        updateAccuracyDisplay(type);
        
        // è‡ªåŠ¨ç­–ç•¥åˆ‡æ¢ï¼šå¦‚æœå‡†ç¡®åº¦ä½äº50%ï¼Œåˆ‡æ¢ç­–ç•¥
        if (accuracy < 50) {
          // å»¶è¿Ÿæ‰§è¡Œç­–ç•¥åˆ‡æ¢ï¼Œç¡®ä¿æ˜¾ç¤ºæ›´æ–°å®Œæˆ
          setTimeout(() => {
            const strategyChanged = autoSwitchStrategy(type);
            if (strategyChanged) {
              // æ›´æ–°ç­–ç•¥æ˜¾ç¤º
              const newStrategy = currentStrategy[type];
              document.getElementById(`${type === 'hk' ? 'hk' : 'macau'}CurrentStrategy`).textContent = 
                PREDICTION_STRATEGIES[newStrategy].name;
            }
          }, 1000);
        }
        
        // æ˜¾ç¤ºéªŒè¯ç»“æœ
        const statusText = accuracy >= 50 ? 'é¢„æµ‹æˆåŠŸ' : 'é¢„æµ‹å¤±è´¥';
        const sourceText = result.dataSource === 'api' ? 'çœŸå®æ•°æ®' : 'æ¨¡æ‹Ÿæ•°æ®';
        const strategyWarning = accuracy < 50 ? ' å‡†ç¡®åº¦ä½äº50%ï¼Œå·²è‡ªåŠ¨åˆ‡æ¢ç­–ç•¥' : '';
        showToast(`æœŸå· ${currentPeriod} è‡ªåŠ¨éªŒè¯å®Œæˆ: ${statusText} (å‡†ç¡®åº¦: ${accuracy}%) [${sourceText}]${strategyWarning}`, accuracy >= 50 ? 'success' : 'warning', 3000);
        
      } catch (error) {
        console.error('è‡ªåŠ¨éªŒè¯å¤±è´¥:', error);
      }
    }
    
    // è·å–æ¾³é—¨å½©ç¥¨æœ€è¿‘å¼€å¥–è®°å½•ç”¨äºåˆ†æå¼€å¥–é¢‘ç‡
    async function fetchMacauRecentResults() {
      try {
        console.log('æ­£åœ¨è·å–æ¾³é—¨å½©ç¥¨æœ€è¿‘å¼€å¥–è®°å½•...');
        
        const recentResults = [];
        const apiUrls = [
          `https://www.kaijiang.org/api/lottery?code=mc6&period=2025310`, // æ˜¨å¤©310æœŸ
          `https://www.kaijiang.org/api/lottery?code=mc6&period=2025309`, // å‰å¤©309æœŸ
          `https://www.kaijiang.org/api/lottery?code=mc6&period=2025308`, // å¤§å‰å¤©308æœŸ
        ];
        
        for (const url of apiUrls) {
          try {
            const response = await fetch(url, {
              headers: {
                'Content-Type': 'application/json',
                'User-Agent': 'Lottery-Prediction-Tool/1.0'
              },
              timeout: 10000
            });
            
            if (response.ok) {
              const data = await response.json();
              if (data.code === 0 && data.data) {
                recentResults.push({
                  period: data.data.period,
                  drawDate: data.data.drawDate,
                  numbers: data.data.numbers
                });
                console.log(`è·å–åˆ°å¼€å¥–è®°å½•: æœŸå·${data.data.period}, å¼€å¥–æ—¥æœŸ: ${data.data.drawDate}, å·ç : ${data.data.numbers}`);
              }
            }
          } catch (error) {
            console.warn(`è·å–å¼€å¥–è®°å½•å¤±è´¥: ${url}`, error.message);
          }
        }
        
        // åˆ†æå¼€å¥–é¢‘ç‡
        if (recentResults.length >= 2) {
          console.log('æ¾³é—¨å½©ç¥¨æœ€è¿‘å¼€å¥–è®°å½•åˆ†æ:');
          recentResults.forEach(result => {
            console.log(`æœŸå·: ${result.period}, å¼€å¥–æ—¥æœŸ: ${result.drawDate}`);
          });
          
          // è®¡ç®—å¼€å¥–é—´éš”
          if (recentResults.length >= 2) {
            const date1 = new Date(recentResults[0].drawDate);
            const date2 = new Date(recentResults[1].drawDate);
            const dayDiff = Math.floor((date1 - date2) / (1000 * 60 * 60 * 24));
            console.log(`æœ€è¿‘ä¸¤æœŸå¼€å¥–é—´éš”: ${dayDiff} å¤©`);
          }
        } else {
          console.log('è­¦å‘Š: æœªèƒ½è·å–åˆ°æ¾³é—¨å½©ç¥¨æœ€è¿‘å¼€å¥–è®°å½•ï¼Œç³»ç»Ÿå°†ä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®');
          console.log('å»ºè®®: è¯·æä¾›å®é™…çš„æ¾³é—¨å½©ç¥¨å¼€å¥–APIæˆ–å†å²å¼€å¥–æ•°æ®');
        }
        
        return recentResults;
      } catch (error) {
        console.error('è·å–æ¾³é—¨å½©ç¥¨æœ€è¿‘å¼€å¥–è®°å½•å¤±è´¥:', error);
        return [];
      }
    }
    
    // å¯åŠ¨è‡ªåŠ¨éªŒè¯å®šæ—¶å™¨
    function startAutoVerification() {
      // æ¯30åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡å¼€å¥–ç»“æœ
      setInterval(() => {
        autoVerifyResults('hk');
        autoVerifyResults('macau');
      }, 30 * 60 * 1000);
      
      // é¡µé¢åŠ è½½æ—¶ç«‹å³æ£€æŸ¥ä¸€æ¬¡
      setTimeout(() => {
        autoVerifyResults('hk');
        autoVerifyResults('macau');
        
        // è·å–æ¾³é—¨æœ€è¿‘å¼€å¥–è®°å½•ç”¨äºåˆ†æ
        fetchMacauRecentResults();
      }, 5000);
    }
    
    // éªŒè¯é¢„æµ‹ç»“æœ
    // å·²åˆ é™¤æ‰‹åŠ¨éªŒè¯åŠŸèƒ½ - æ‰€æœ‰éªŒè¯éƒ½é€šè¿‡autoVerifyResultsè‡ªåŠ¨å®Œæˆ
    
    // æ›´æ–°æœŸå·æ˜¾ç¤º
    function updatePeriodDisplay() {
      document.getElementById('hkCurrentPeriod').textContent = getCurrentPeriod('hk');
      document.getElementById('macauCurrentPeriod').textContent = getCurrentPeriod('macau');
    }
    
    // å·²ç§»é™¤ç­–ç•¥åˆ‡æ¢ï¼ˆä»…ä¿ç•™ AIï¼‰ï¼Œä¿ç•™å½“å‰ç­–ç•¥æ˜¾ç¤ºå³å¯
    
    // è·å–å·ç é¢œè‰²ç±»
    function getNumberColor(num) {
      if ([1, 2, 7, 8, 12, 13, 18, 19, 23, 24, 29, 30, 34, 35, 40, 45, 46].includes(num)) return 'red';
      if ([3, 4, 9, 10, 14, 15, 20, 25, 26, 31, 36, 37, 41, 42, 47, 48].includes(num)) return 'blue';
      return 'green';
    }
    
    // AIé¢„æµ‹å‡½æ•°ï¼ˆä»…ä¿ç•™AIç­–ç•¥ï¼‰
    async function predictLotteryNumbers() {
      try {
        predictBtn.disabled = true;
        predictionResult.style.display = 'none';
        predictionLoading.style.display = 'block';
        
        const currentGame = gameSelect.value === '1' ? 'é¦™æ¸¯æ•°å­—' : 'æ¾³é—¨æ•°å­—';
        const gameType = gameSelect.value === '1' ? 'hk' : 'macau';
        
        let prediction;
        const dateSeed = new Date().getDate() + new Date().getMonth() * 31;
        
        // ç»Ÿä¸€ä½¿ç”¨AIé¢„æµ‹
        prediction = await generateAIPrediction(currentGame);
        
        // éªŒè¯å’Œä¿®æ­£é¢„æµ‹ç»“æœ
        prediction = validateAndFixPrediction(prediction, gameSelect.value, dateSeed);
        
        // æ˜¾ç¤ºé¢„æµ‹ç»“æœ
        displayPredictionResult(prediction);
        
      } catch (error) {
        console.error('é¢„æµ‹å¤±è´¥:', error);
        showToast('é¢„æµ‹å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•', 'error');
        
        // æ˜¾ç¤ºæ™ºèƒ½é¢„æµ‹ç»“æœ
        const intelligentPrediction = generateIntelligentPrediction(gameSelect.value, 'intelligent', dateSeed);
        displayPredictionResult(intelligentPrediction);
        
      } finally {
        predictBtn.disabled = false;
        predictionLoading.style.display = 'none';
      }
    }
    
    // AIé¢„æµ‹ç®—æ³•
    async function generateAIPrediction(currentGame) {
        console.log('ğŸ¯ AIé¢„æµ‹ç®—æ³•å¼€å§‹ - generateAIPrediction');
        console.log('ğŸ® å½“å‰æ¸¸æˆ:', currentGame);
        
        // æ„å»ºAIæç¤ºè¯
        const cfg = getAIConfig();
        console.log('âš™ï¸ ä½¿ç”¨AIé…ç½®:', cfg);
        
        const prompt = `ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„æ•°å­—æ•°æ®åˆ†æå¸ˆã€‚è¯·åŸºäºç»Ÿè®¡å­¦åŸç†å’Œå†å²æ•°æ®æ¨¡å¼ï¼Œä¸º${currentGame}é¢„æµ‹æœ€å¯èƒ½çš„7ä¸ªå·ç ï¼ˆ1-49ï¼‰å’Œå¯¹åº”çš„ç”Ÿè‚–ã€‚

è¯·è€ƒè™‘ä»¥ä¸‹å› ç´ ï¼Œå¹¶æŒ‰ä¸å°‘äº ${cfg.reasoningDepth} æ­¥è¿›è¡Œæ¸…æ™°çš„æ¨ç†ï¼š
1. å·ç å‡ºç°é¢‘ç‡ç»Ÿè®¡
2. å†·çƒ­å·ç åˆ†æ
3. å·ç é—´éš”å’Œåˆ†å¸ƒè§„å¾‹
4. å¥‡å¶æ•°æ¯”ä¾‹
5. å¤§å°æ•°æ¯”ä¾‹
6. è¿å·å‡ºç°æ¦‚ç‡

è¯·ç›´æ¥è¿”å›JSONæ ¼å¼çš„é¢„æµ‹ç»“æœï¼Œæ ¼å¼å¦‚ä¸‹ï¼š
{
  "numbers": [1, 15, 23, 28, 35, 42, 49],
  "zodiac": "é¾™",
  "confidence": "75%",
  "analysis": "åŸºäºç»Ÿè®¡åˆ†æçš„ç®€è¦è¯´æ˜",
  "reasoning": [
    "åŸºäºå†å²é¢‘ç‡ç­›é€‰ç§å­é›†",
    "å¹³è¡¡å¥‡å¶ä¸å¤§å°æ¯”ä¾‹",
    "é¿å…é‡å¤å¹¶æ§åˆ¶è¿å·æ•°",
    "ç»¼åˆè¶‹åŠ¿ä¸åˆ†å¸ƒä¼˜åŒ–æœ€ç»ˆé›†åˆ"
  ]
}

æ³¨æ„ï¼š
- 7ä¸ªå·ç å¿…é¡»åœ¨1-49èŒƒå›´å†…ä¸”ä¸é‡å¤
- ç”Ÿè‚–å¿…é¡»æ˜¯åäºŒç”Ÿè‚–ä¹‹ä¸€
- ç½®ä¿¡åº¦ç”¨ç™¾åˆ†æ¯”è¡¨ç¤º
- è¿™ä»…ä¾›å¨±ä¹å‚è€ƒï¼Œä¸æ„æˆæŠ•æ³¨å»ºè®®`;
        
        console.log('ğŸ“‹ æ„å»ºçš„æç¤ºè¯é•¿åº¦:', prompt.length, 'å­—ç¬¦');
        
        let aiResponse;
        try {
          aiResponse = await callOpenRouter(prompt);
          console.log('âœ… æˆåŠŸè·å–AIå“åº”ï¼Œé•¿åº¦:', aiResponse.length, 'å­—ç¬¦');
        } catch (error) {
          console.error('âŒ AIè°ƒç”¨å¤±è´¥:', error);
          throw error;
        }
        
        // è§£æAIè¿”å›çš„JSON
        try {
          console.log('ğŸ” å¼€å§‹è§£æAIè¿”å›çš„JSON...');
          // å°è¯•æå–JSONéƒ¨åˆ†
          const jsonMatch = aiResponse.match(/\{[\s\S]*\}/);
          if (jsonMatch) {
            const result = JSON.parse(jsonMatch[0]);
            console.log('âœ… JSONè§£ææˆåŠŸ:', result);
            return result;
          } else {
            console.warn('âš ï¸ æœªæ‰¾åˆ°JSONæ ¼å¼ï¼Œå°è¯•ç›´æ¥è§£æ...');
            const result = JSON.parse(aiResponse);
            console.log('âœ… ç›´æ¥è§£ææˆåŠŸ:', result);
            return result;
          }
        } catch (parseError) {
          // å¦‚æœJSONè§£æå¤±è´¥ï¼Œä½¿ç”¨æ™ºèƒ½é¢„æµ‹ç®—æ³•
          console.error('âŒ JSONè§£æå¤±è´¥ï¼Œä½¿ç”¨å›é€€ç®—æ³•:', parseError);
          console.log('ğŸ“ AIåŸå§‹å“åº”:', aiResponse);
          const fallback = generateIntelligentPrediction('1', 'ai_fallback');
          console.log('ğŸ”„ ä½¿ç”¨å›é€€é¢„æµ‹:', fallback);
          return fallback;
        }
    }
    
    // ç»Ÿè®¡å­¦é¢„æµ‹ç®—æ³•
    function generateStatisticalPrediction(gameType, dateSeed = new Date().getDate() + new Date().getMonth() * 31) {
      const history = historicalData[gameType] || [];
      const frequency = {};
      
      // åˆå§‹åŒ–é¢‘ç‡ç»Ÿè®¡
      for (let i = 1; i <= 49; i++) {
        frequency[i] = 0;
      }
      
      // ç»Ÿè®¡å·ç å‡ºç°é¢‘ç‡
      history.forEach(draw => {
        draw.forEach(num => {
          frequency[num] = (frequency[num] || 0) + 1;
        });
      });
      
      // æŒ‰é¢‘ç‡æ’åºå¹¶é€‰æ‹©å‰7ä¸ª
      const sortedNumbers = Object.keys(frequency)
        .map(num => ({ num: parseInt(num), freq: frequency[num] }))
        .sort((a, b) => b.freq - a.freq)
        .slice(0, 7)
        .map(item => item.num)
        .sort((a, b) => a - b);
      
      console.log(`ç»Ÿè®¡å­¦ç­–ç•¥(${gameType}):`, sortedNumbers);
      
      return {
        numbers: sortedNumbers.length >= 7 ? sortedNumbers : generateRandomNumbers(dateSeed),
        zodiac: getRandomZodiac(dateSeed),
        confidence: "68%",
        analysis: `åŸºäºå†å²æ•°æ®é¢‘ç‡ç»Ÿè®¡åˆ†æ - æœ€é«˜é¢‘å·ç : ${sortedNumbers.slice(0,3).join(',')}`
      };
    }
    
    // è¶‹åŠ¿åˆ†æé¢„æµ‹ç®—æ³•
    function generateTrendPrediction(gameType, dateSeed = new Date().getDate() + new Date().getMonth() * 31) {
      const history = historicalData[gameType] || [];
      const recentDraws = history.slice(-3); // æœ€è¿‘3æœŸ
      const trendFreq = {};
      
      // åˆå§‹åŒ–
      for (let i = 1; i <= 49; i++) {
        trendFreq[i] = 0;
      }
      
      // åˆ†ææœ€è¿‘è¶‹åŠ¿ï¼Œç»™è¿‘æœŸå·ç æ›´é«˜æƒé‡
      recentDraws.forEach((draw, index) => {
        const weight = recentDraws.length - index; // è¶Šè¿‘æœŸæƒé‡è¶Šé«˜
        draw.forEach(num => {
          trendFreq[num] += weight;
        });
      });
      
      // é€‰æ‹©è¶‹åŠ¿æƒé‡æœ€é«˜çš„7ä¸ªå·ç 
      const selectedNumbers = Object.keys(trendFreq)
        .map(num => ({ num: parseInt(num), weight: trendFreq[num] }))
        .sort((a, b) => b.weight - a.weight)
        .slice(0, 7)
        .map(item => item.num)
        .sort((a, b) => a - b);
      
      console.log(`è¶‹åŠ¿åˆ†æç­–ç•¥(${gameType}):`, selectedNumbers);
      
      return {
        numbers: selectedNumbers,
        zodiac: getRandomZodiac(dateSeed),
        confidence: "72%",
        analysis: `åŸºäºæœ€è¿‘${recentDraws.length}æœŸè¶‹åŠ¿åˆ†æ - çƒ­é—¨è¶‹åŠ¿: ${selectedNumbers.slice(0,3).join(',')}`
      };
    }
    
    // æœºå™¨å­¦ä¹ é¢„æµ‹ç®—æ³•
    function generateMLPrediction(gameType, dateSeed = new Date().getDate() + new Date().getMonth() * 31) {
      const history = historicalData[gameType] || [];
      const weights = [0.4, 0.3, 0.2, 0.1]; // æƒé‡ï¼šæœ€è¿‘æœŸæƒé‡æ›´é«˜
      const prediction = [];
      
      // æ¨¡æ‹Ÿæœºå™¨å­¦ä¹ æƒé‡è®¡ç®—
      for (let i = 1; i <= 49; i++) {
        let score = 0;
        const recentHistory = history.slice(-4);
        recentHistory.forEach((draw, index) => {
          if (draw.includes(i)) {
            score += weights[3 - index]; // ä¿®æ­£æƒé‡é¡ºåºï¼Œæœ€è¿‘çš„æƒé‡æœ€é«˜
          }
        });
        
        // æ·»åŠ åŸºäºæ—¥æœŸå’Œå·ç çš„ç¡®å®šæ€§å› å­æ¨¡æ‹ŸMLçš„å¤æ‚æ€§
        score += ((dateSeed + i) % 100) * 0.001; // 0åˆ°0.099çš„ç¡®å®šæ€§è°ƒæ•´
        prediction.push({ num: i, score });
      }
      
      // é€‰æ‹©å¾—åˆ†æœ€é«˜çš„7ä¸ªå·ç 
      const selectedNumbers = prediction
        .sort((a, b) => b.score - a.score)
        .slice(0, 7)
        .map(item => item.num)
        .sort((a, b) => a - b);
      
      console.log(`æœºå™¨å­¦ä¹ ç­–ç•¥(${gameType}):`, selectedNumbers);
      
      return {
        numbers: selectedNumbers,
        zodiac: getRandomZodiac(dateSeed),
        confidence: "76%",
        analysis: `åŸºäºæœºå™¨å­¦ä¹ æƒé‡ç®—æ³• - é«˜åˆ†å·ç : ${selectedNumbers.slice(0,3).join(',')}`
      };
    }
    
    // æ··åˆç­–ç•¥é¢„æµ‹ç®—æ³•
    function generateHybridPrediction(gameType, dateSeed = new Date().getDate() + new Date().getMonth() * 31) {
      const strategies = [
        generateStatisticalPrediction(gameType, dateSeed),
        generateTrendPrediction(gameType, dateSeed),
        generateMLPrediction(gameType, dateSeed)
      ];
      
      console.log(`æ··åˆç­–ç•¥è°ƒç”¨ç»“æœ(${gameType}):`, {
        statistical: strategies[0].numbers,
        trend: strategies[1].numbers,
        ml: strategies[2].numbers
      });
      
      const hybridNumbers = [];
      const numberCounts = {};
      
      // ç»Ÿè®¡å„ç­–ç•¥æ¨èçš„å·ç 
      strategies.forEach((strategy, index) => {
        strategy.numbers.forEach(num => {
          numberCounts[num] = (numberCounts[num] || 0) + 1;
        });
      });
      
      // é€‰æ‹©å‡ºç°æ¬¡æ•°æœ€å¤šçš„å·ç 
      const sortedNumbers = Object.keys(numberCounts)
        .map(num => ({ num: parseInt(num), count: numberCounts[num] }))
        .sort((a, b) => b.count - a.count)
        .map(item => item.num);
      
      // ç¡®ä¿æœ‰7ä¸ªå·ç 
      for (let i = 0; i < 7; i++) {
        if (sortedNumbers[i]) {
          hybridNumbers.push(sortedNumbers[i]);
        } else {
          // å¦‚æœä¸å¤Ÿ7ä¸ªï¼ŒåŸºäºæ—¥æœŸç§å­ç¡®å®šæ€§è¡¥å……
          let randomNum;
          let attempt = 0;
          do {
            randomNum = ((dateSeed + attempt + hybridNumbers.length) % 49) + 1;
            attempt++;
          } while (hybridNumbers.includes(randomNum) && attempt < 50);
          hybridNumbers.push(randomNum);
        }
      }
      
      const finalNumbers = hybridNumbers.sort((a, b) => a - b);
      console.log(`æ··åˆç­–ç•¥æœ€ç»ˆç»“æœ(${gameType}):`, finalNumbers);
      
      return {
        numbers: finalNumbers,
        zodiac: getRandomZodiac(dateSeed),
        confidence: "80%",
        analysis: `ç»¼åˆå¤šç§ç®—æ³•çš„æ··åˆç­–ç•¥é¢„æµ‹ - çƒ­é—¨ç»„åˆ: ${finalNumbers.slice(0,3).join(',')}`
      };
    }
    
    // è¾…åŠ©å‡½æ•°
    function generateRandomNumbers(dateSeed = new Date().getDate() + new Date().getMonth() * 31) {
      const numbers = [];
      let attempt = 0;
      while (numbers.length < 7) {
        const num = ((dateSeed + attempt + numbers.length) % 49) + 1;
        if (!numbers.includes(num)) {
          numbers.push(num);
        }
        attempt++;
        if (attempt > 100) break; // é˜²æ­¢æ— é™å¾ªç¯
      }
      return numbers.sort((a, b) => a - b);
    }
    
    function getRandomZodiac(dateSeed = new Date().getDate() + new Date().getMonth() * 31) {
      const zodiacs = ['é¼ ', 'ç‰›', 'è™', 'å…”', 'é¾™', 'è›‡', 'é©¬', 'ç¾Š', 'çŒ´', 'é¸¡', 'ç‹—', 'çŒª'];
      // åŸºäºå½“å‰æ—¥æœŸç”Ÿæˆç¡®å®šæ€§çš„ç”Ÿè‚–ï¼Œç¡®ä¿å½“å¤©ç»“æœå›ºå®š
      return zodiacs[dateSeed % zodiacs.length];
    }
    
    // å†å²æ•°æ®æ¨¡æ‹Ÿï¼ˆå®é™…åº”ç”¨ä¸­åº”ä»APIè·å–ï¼‰
    const historicalData = {
      hk: [
        [3, 8, 15, 22, 29, 35, 41], [7, 12, 18, 25, 31, 38, 44], [2, 9, 16, 23, 30, 37, 43],
        [5, 11, 17, 24, 32, 39, 45], [1, 6, 14, 21, 28, 34, 42], [4, 10, 19, 26, 33, 40, 47],
        [13, 20, 27, 36, 41, 46, 49], [8, 15, 22, 29, 35, 42, 48], [3, 9, 16, 23, 30, 37, 44],
        [7, 14, 21, 28, 34, 41, 47], [2, 11, 18, 25, 32, 39, 45], [5, 12, 19, 26, 33, 40, 46],
        [1, 8, 17, 24, 31, 38, 43], [6, 13, 20, 27, 35, 42, 49], [4, 9, 15, 22, 29, 36, 44],
        [10, 16, 23, 30, 37, 41, 48], [3, 7, 14, 21, 28, 34, 45], [11, 18, 25, 32, 39, 43, 47],
        [2, 8, 15, 22, 29, 35, 46], [5, 12, 19, 26, 33, 40, 42]
      ],
      macau: [
        [4, 9, 16, 23, 30, 37, 44], [8, 13, 20, 27, 34, 41, 48], [3, 10, 17, 24, 31, 38, 45],
        [6, 12, 19, 26, 33, 40, 47], [2, 7, 15, 22, 29, 36, 43], [5, 11, 18, 25, 32, 39, 46],
        [1, 14, 21, 28, 35, 42, 49], [9, 16, 23, 30, 37, 44, 48], [4, 10, 17, 24, 31, 38, 45],
        [8, 13, 20, 27, 34, 41, 47], [3, 7, 15, 22, 29, 36, 43], [6, 12, 19, 26, 33, 40, 46],
        [2, 11, 18, 25, 32, 39, 49], [5, 14, 21, 28, 35, 42, 44], [1, 9, 16, 23, 30, 37, 48],
        [13, 17, 24, 31, 38, 41, 45], [4, 8, 15, 22, 29, 36, 47], [12, 19, 26, 33, 40, 43, 46],
        [3, 10, 20, 27, 34, 39, 49], [6, 11, 18, 25, 32, 37, 42]
      ]
    };

    // åˆ†æå·ç é¢‘ç‡
    function analyzeNumberFrequency(data) {
      const frequency = {};
      for (let i = 1; i <= 49; i++) {
        frequency[i] = 0;
      }
      
      data.forEach(draw => {
        draw.forEach(num => {
          frequency[num]++;
        });
      });
      
      return frequency;
    }

    // è®¡ç®—å·ç æƒé‡ï¼ˆåŸºäºå¤šç§å› ç´ ï¼‰
    function calculateNumberWeights(gameType, strategy = 'intelligent', dateSeed = new Date().getDate() + new Date().getMonth() * 31) {
      const data = gameType === '1' ? historicalData.hk : historicalData.macau;
      const frequency = analyzeNumberFrequency(data);
      const weights = {};
      
      // æ ¹æ®ç­–ç•¥ç±»å‹è°ƒæ•´åˆ†æå‚æ•°
      const recentPeriods = strategy === 'ai_fallback' ? 8 : strategy === 'validation_fix' ? 12 : 10;
      const recentData = data.slice(-recentPeriods);
      const recentFreq = analyzeNumberFrequency(recentData);
      
      for (let i = 1; i <= 49; i++) {
        let weight = 0;
        
        // æ ¹æ®ç­–ç•¥è°ƒæ•´æƒé‡åˆ†é…
        const avgFreq = data.length * 7 / 49; // ç†è®ºå¹³å‡é¢‘ç‡
        const freqScore = frequency[i] / avgFreq;
        const isHot = frequency[i] > avgFreq * 1.1;
        const isCold = frequency[i] < avgFreq * 0.9;
        const recentScore = recentFreq[i] / (recentData.length * 7 / 49);
        const isOdd = i % 2 === 1;
        const isSmall = i <= 24;
        const zodiacIndex = (i - 1) % 12;
        
        // ä¸ºä¸åŒå½©ç§æ·»åŠ åŸºç¡€å·®å¼‚
        const gameTypeBonus = gameType === '1' ? (i % 7 === 0 ? 0.1 : 0) : (i % 5 === 0 ? 0.1 : 0);
        // åŸºäºå·ç å’Œæ—¥æœŸçš„ç¡®å®šæ€§å› å­ï¼Œæ›¿ä»£éšæœºå› å­
        const deterministicFactor = ((dateSeed + i) % 21 - 10) * 0.005; // -0.05åˆ°+0.05çš„ç¡®å®šæ€§è°ƒæ•´
        
        if (strategy === 'ai_fallback') {
          // AIç­–ç•¥ï¼šæ›´æ³¨é‡å†å²é¢‘ç‡å’Œè¿‘æœŸè¶‹åŠ¿
          weight += freqScore * (gameType === '1' ? 0.4 : 0.35); // å†å²é¢‘ç‡æƒé‡
          if (isHot) weight += (gameType === '1' ? 0.2 : 0.25);
          if (isCold) weight += (gameType === '1' ? 0.1 : 0.15);
          weight += recentScore * (gameType === '1' ? 0.25 : 0.3); // è¿‘æœŸè¶‹åŠ¿
          weight += (isOdd ? 0.075 : 0.075) + (isSmall ? 0.075 : 0.075); // åˆ†å¸ƒ15%
          weight += gameTypeBonus + deterministicFactor;
        } else if (strategy === 'validation_fix') {
          // éªŒè¯ç­–ç•¥ï¼šå¹³è¡¡å„ç§å› ç´ 
          weight += freqScore * (gameType === '1' ? 0.25 : 0.3); // å†å²é¢‘ç‡
          if (isHot) weight += (gameType === '1' ? 0.1 : 0.05);
          if (isCold) weight += (gameType === '1' ? 0.3 : 0.35); // æ›´åå‘å†·å·
          weight += (1 / (recentScore + 0.1)) * (gameType === '1' ? 0.25 : 0.2); // åå‘è¶‹åŠ¿
          weight += (isOdd ? 0.1 : 0.1) + (isSmall ? 0.1 : 0.1); // åˆ†å¸ƒ20%
          weight += gameTypeBonus * 1.5 + deterministicFactor * 2;
        } else {
          // é»˜è®¤æ™ºèƒ½ç­–ç•¥
          weight += freqScore * (gameType === '1' ? 0.3 : 0.28); // å†å²é¢‘ç‡
          if (isHot) weight += (gameType === '1' ? 0.15 : 0.18);
          if (isCold) weight += (gameType === '1' ? 0.25 : 0.22);
          weight += (1 / (recentScore + 0.1)) * (gameType === '1' ? 0.2 : 0.25); // è¿‘æœŸè¶‹åŠ¿
          weight += (isOdd ? 0.075 : 0.075) + (isSmall ? 0.075 : 0.075); // åˆ†å¸ƒ15%
          weight += gameTypeBonus * 0.8 + deterministicFactor * 1.2;
        }
        
        // ç”Ÿè‚–æƒé‡ï¼ˆæ‰€æœ‰ç­–ç•¥å…±ç”¨ï¼‰
        const zodiacWeight = Math.sin((zodiacIndex / 12) * Math.PI * 2) * 0.05 + 0.05;
        weight += zodiacWeight;
        
        weights[i] = Math.max(weight, 0.1); // ç¡®ä¿æœ€å°æƒé‡
      }
      
      return weights;
    }

    // é¢„æµ‹ç»“æœç¼“å­˜
    const predictionCache = {};
    const predictionTimestamp = {};

    // æ™ºèƒ½é¢„æµ‹ç®—æ³•
    function generateIntelligentPrediction(type = 'hk', strategy = 'intelligent', dateSeed = new Date().getDate() + new Date().getMonth() * 31) {
      // ä¸ºä¸åŒç­–ç•¥å’Œå½©ç§ä½¿ç”¨åŸºäºæ—¥æœŸçš„å›ºå®šç¼“å­˜é”®
      const today = new Date().toDateString(); // è·å–å½“å‰æ—¥æœŸå­—ç¬¦ä¸²ï¼Œç¡®ä¿å½“å¤©ç»“æœå›ºå®š
      const cacheKey = `${type}_${strategy}_${today}`;
      const now = Date.now();
      const cacheExpiry = 24 * 60 * 60 * 1000; // 24å°æ—¶ç¼“å­˜ï¼Œç¡®ä¿å½“å¤©é¢„æµ‹ç»“æœå›ºå®š
      
      // æ£€æŸ¥ç¼“å­˜æ˜¯å¦æœ‰æ•ˆ
      if (predictionCache[cacheKey] && predictionTimestamp[cacheKey] && 
          (now - predictionTimestamp[cacheKey]) < cacheExpiry) {
        console.log(`ä½¿ç”¨ç¼“å­˜çš„${type === 'hk' ? 'é¦™æ¸¯' : 'æ¾³é—¨'}æ•°å­—é¢„æµ‹ç»“æœ (ç­–ç•¥: ${strategy}, æ—¥æœŸ: ${today})`);
        return predictionCache[cacheKey];
      }
      
      console.log(`ç”Ÿæˆæ–°çš„${type === 'hk' ? 'é¦™æ¸¯' : 'æ¾³é—¨'}æ•°å­—é¢„æµ‹ (ç­–ç•¥: ${strategy}, æ—¥æœŸ: ${today})`);
      
      const gameType = type === 'hk' ? '1' : '2';
      const weights = calculateNumberWeights(gameType, strategy, dateSeed);
      const numbers = [];
      const usedNumbers = new Set();
      
      // ä¸ºä¸åŒå½©ç§æ·»åŠ é€‰æ‹©åå¥½
      const gameTypePreference = type === 'hk' ? 
        { smallNumbers: 0.6, oddNumbers: 0.55, highWeights: 0.7 } : 
        { smallNumbers: 0.4, oddNumbers: 0.45, highWeights: 0.5 };
      // åŸºäºæ—¥æœŸç”Ÿæˆå›ºå®šçš„ç­–ç•¥ç§å­ï¼Œç¡®ä¿å½“å¤©ç»“æœä¸€è‡´
      const strategySeed = strategy === 'ai_fallback' ? dateSeed % 7 : strategy === 'validation_fix' ? dateSeed % 5 : dateSeed % 3;
      
      // åˆ›å»ºåŠ æƒå·ç æ± 
      const weightedPool = [];
      for (let num = 1; num <= 49; num++) {
        const weight = Math.round(weights[num] * 100);
        for (let i = 0; i < weight; i++) {
          weightedPool.push(num);
        }
      }
      
      // æ ¹æ®ç­–ç•¥é€‰æ‹©ä¸åŒçš„å·ç é€‰æ‹©æ–¹æ³•
      if (strategy === 'ai_fallback') {
        // AIç­–ç•¥ï¼šæ›´åå‘æƒé‡é«˜çš„å·ç ï¼Œä½†æ ¹æ®å½©ç§è°ƒæ•´
        while (numbers.length < 7) {
          const topWeights = Object.entries(weights)
            .filter(([num]) => !usedNumbers.has(parseInt(num)))
            .sort(([,a], [,b]) => b - a)
            .slice(0, type === 'hk' ? 15 + strategySeed : 25 + strategySeed)
            .map(([num]) => parseInt(num));
          
          // æ ¹æ®å½©ç§åå¥½è°ƒæ•´é€‰æ‹©ï¼ˆåŸºäºç¡®å®šæ€§ç§å­ï¼‰
          let candidateNums = topWeights;
          const selectionSeed = (dateSeed + numbers.length) % 100;
          if (selectionSeed < gameTypePreference.smallNumbers * 100) {
            candidateNums = candidateNums.filter(num => num <= 24);
            if (candidateNums.length === 0) candidateNums = topWeights;
          }
          if ((selectionSeed + 17) % 100 < gameTypePreference.oddNumbers * 100) {
            const oddNums = candidateNums.filter(num => num % 2 === 1);
            if (oddNums.length > 0) candidateNums = oddNums;
          }
          
          const selectionIndex = (dateSeed + strategySeed + numbers.length) % candidateNums.length;
          const selectedNum = candidateNums[selectionIndex];
          if (!usedNumbers.has(selectedNum)) {
            numbers.push(selectedNum);
            usedNumbers.add(selectedNum);
          }
        }
      } else if (strategy === 'validation_fix') {
        // éªŒè¯ç­–ç•¥ï¼šæ›´å¹³è¡¡çš„é€‰æ‹©ï¼Œä½†æ ¹æ®å½©ç§æœ‰ä¸åŒåå¥½
        while (numbers.length < 7) {
          let selectedNum;
          const weightSeed = (dateSeed + numbers.length) % 100;
          const useMiddleWeights = weightSeed < (type === 'hk' ? 70 : 50);
          
          if (useMiddleWeights) {
            // é€‰æ‹©ä¸­ç­‰æƒé‡å·ç ï¼ŒèŒƒå›´æ ¹æ®å½©ç§è°ƒæ•´
            const startSlice = type === 'hk' ? 8 + strategySeed : 12 + strategySeed;
            const endSlice = type === 'hk' ? 30 + strategySeed : 40 + strategySeed;
            const midWeights = Object.entries(weights)
              .filter(([num]) => !usedNumbers.has(parseInt(num)))
              .sort(([,a], [,b]) => b - a)
              .slice(startSlice, endSlice)
              .map(([num]) => parseInt(num));
            
            // æ ¹æ®å½©ç§åå¥½è¿‡æ»¤
            let candidateNums = midWeights;
            if (type === 'macau' && (weightSeed + 23) % 100 < 60) {
              candidateNums = candidateNums.filter(num => num > 24); // æ¾³é—¨åå‘å¤§å·
              if (candidateNums.length === 0) candidateNums = midWeights;
            }
            
            const selectionIndex = (dateSeed + strategySeed + numbers.length) % candidateNums.length;
            selectedNum = candidateNums[selectionIndex];
          } else {
            // ç¡®å®šæ€§é€‰æ‹©ï¼Œä½†æ ¹æ®å½©ç§è°ƒæ•´èŒƒå›´
            const minRange = type === 'hk' ? 1 : 10;
            const maxRange = type === 'hk' ? 40 : 49;
            let attempt = 0;
            do {
              selectedNum = ((dateSeed + strategySeed + numbers.length + attempt) % (maxRange - minRange + 1)) + minRange;
              attempt++;
            } while (usedNumbers.has(selectedNum) && attempt < 50);
          }
          
          if (!usedNumbers.has(selectedNum)) {
            numbers.push(selectedNum);
            usedNumbers.add(selectedNum);
          }
        }
      } else {
        // é»˜è®¤ç­–ç•¥ï¼šæ··åˆé€‰æ‹©ï¼Œæ ¹æ®å½©ç§æœ‰ä¸åŒç­–ç•¥
        while (numbers.length < 7) {
          let selectedNum;
          const isEarlySelection = numbers.length < (type === 'hk' ? 3 : 4);
          
          if (isEarlySelection) {
            // å‰å‡ ä¸ªå·ç ï¼šä¼˜å…ˆé€‰æ‹©æƒé‡é«˜çš„ï¼Œä½†èŒƒå›´æ ¹æ®å½©ç§è°ƒæ•´
            const topCount = type === 'hk' ? 12 + strategySeed : 18 + strategySeed;
            const topWeights = Object.entries(weights)
              .filter(([num]) => !usedNumbers.has(parseInt(num)))
              .sort(([,a], [,b]) => b - a)
              .slice(0, topCount)
              .map(([num]) => parseInt(num));
            
            // æ ¹æ®å½©ç§åå¥½è¿‡æ»¤ï¼ˆåŸºäºç¡®å®šæ€§ç§å­ï¼‰
            let candidateNums = topWeights;
            const filterSeed = (dateSeed + numbers.length) % 100;
            if (type === 'hk' && filterSeed < gameTypePreference.smallNumbers * 100) {
              candidateNums = candidateNums.filter(num => num <= 25);
              if (candidateNums.length === 0) candidateNums = topWeights;
            } else if (type === 'macau' && filterSeed < 60) {
              candidateNums = candidateNums.filter(num => num > 20);
              if (candidateNums.length === 0) candidateNums = topWeights;
            }
            
            const selectionIndex = (dateSeed + strategySeed + numbers.length) % candidateNums.length;
            selectedNum = candidateNums[selectionIndex];
          } else {
            // åå‡ ä¸ªå·ç ï¼šåŠ æƒéšæœºé€‰æ‹©ï¼Œä½†æ ¹æ®å½©ç§è°ƒæ•´æƒé‡æ± 
            const adjustedPool = [];
            const poolMultiplier = type === 'hk' ? 1.2 : 0.8;
            
            for (let num = 1; num <= 49; num++) {
              if (!usedNumbers.has(num)) {
                const weight = Math.round(weights[num] * 100 * poolMultiplier);
                for (let i = 0; i < Math.max(1, weight); i++) {
                  adjustedPool.push(num);
                }
              }
            }
            
            let attempt = 0;
            do {
              const deterministicIndex = (dateSeed + strategySeed + numbers.length + attempt) % adjustedPool.length;
              selectedNum = adjustedPool[deterministicIndex];
              attempt++;
            } while (usedNumbers.has(selectedNum) && attempt < 100);
          }
          
          if (!usedNumbers.has(selectedNum)) {
            numbers.push(selectedNum);
            usedNumbers.add(selectedNum);
          }
        }
      }
      
      // ç¡®ä¿å·ç åˆ†å¸ƒåˆç†
      numbers.sort((a, b) => a - b);
      
      // è®¡ç®—é¢„æµ‹ç½®ä¿¡åº¦ï¼ˆæ ¹æ®å½©ç§å’Œç­–ç•¥è°ƒæ•´ï¼‰
      const avgWeight = numbers.reduce((sum, num) => sum + weights[num], 0) / 7;
      let confidence;
      
      // ä¸ºä¸åŒå½©ç§å’Œç­–ç•¥è®¾ç½®ä¸åŒçš„ç½®ä¿¡åº¦è®¡ç®—
      const baseConfidence = type === 'hk' ? 75 : 72;
      const strategyBonus = strategy === 'ai_fallback' ? 8 : strategy === 'validation_fix' ? 5 : 6;
      // åŸºäºæ—¥æœŸçš„ç¡®å®šæ€§è°ƒæ•´å› å­ï¼Œæ›¿ä»£éšæœºå› å­
      const deterministicAdjustment = (dateSeed % 8) - 4; // -4åˆ°+3çš„ç¡®å®šæ€§è°ƒæ•´
      
      confidence = Math.max(60, Math.min(88, baseConfidence + strategyBonus + deterministicAdjustment + Math.round(avgWeight * 10)));
      
      // é€‰æ‹©æœ€å¯èƒ½çš„ç”Ÿè‚–ï¼ˆåŸºäºå·ç åˆ†å¸ƒã€å½©ç§å’Œç­–ç•¥ç‰¹æ€§ï¼‰
      const zodiacCounts = {};
      zodiacAnimals.forEach(z => zodiacCounts[z] = 0);
      
      // æ ¹æ®å·ç åˆ†å¸ƒè®¡ç®—ç”Ÿè‚–æƒé‡
      numbers.forEach(num => {
        const zodiacIndex = (num - 1) % 12;
        const zodiac = zodiacAnimals[zodiacIndex];
        zodiacCounts[zodiac]++;
      });
      
      // æ ¹æ®ç­–ç•¥å’Œå½©ç§è°ƒæ•´ç”Ÿè‚–é€‰æ‹©
      let mostLikelyZodiac;
      if (strategy === 'ai_fallback') {
        // AIç­–ç•¥ï¼šåå‘ç‰¹å®šç”Ÿè‚–
        const preferredZodiacs = type === 'hk' ? ['é¾™', 'è™', 'é©¬'] : ['è›‡', 'çŒ´', 'é¸¡'];
        const hasPreferred = preferredZodiacs.some(z => zodiacCounts[z] > 0);
        const zodiacSeed = (dateSeed + strategySeed) % 100;
        if (hasPreferred && zodiacSeed < 70) {
          mostLikelyZodiac = preferredZodiacs.find(z => zodiacCounts[z] > 0) || 
                           Object.entries(zodiacCounts).sort(([,a], [,b]) => b - a)[0][0];
        } else {
          mostLikelyZodiac = Object.entries(zodiacCounts).sort(([,a], [,b]) => b - a)[0][0];
        }
      } else if (strategy === 'validation_fix') {
        // éªŒè¯ç­–ç•¥ï¼šåŸºäºæ—¥æœŸç§å­çš„ç¡®å®šæ€§é€‰æ‹©
        const zodiacSeed = (dateSeed + strategySeed) % 10;
        if (zodiacSeed < 4) {
          mostLikelyZodiac = zodiacAnimals[(dateSeed + strategySeed) % 12];
        } else {
          mostLikelyZodiac = Object.entries(zodiacCounts).sort(([,a], [,b]) => b - a)[0][0];
        }
      } else {
        // é»˜è®¤ç­–ç•¥ï¼šåŸºäºåˆ†å¸ƒ
        mostLikelyZodiac = Object.entries(zodiacCounts).sort(([,a], [,b]) => b - a)[0][0];
      }
      
      const prediction = {
        numbers: numbers,
        zodiac: mostLikelyZodiac,
        confidence: `${confidence}%`,
        analysis: `åŸºäº${type === 'hk' ? 'é¦™æ¸¯' : 'æ¾³é—¨'}æ•°å­—å†å²æ•°æ®çš„${historicalData[type].length}æœŸç»Ÿè®¡åˆ†æï¼Œç»¼åˆè€ƒè™‘å·ç é¢‘ç‡ã€å†·çƒ­åˆ†å¸ƒã€è¿‘æœŸè¶‹åŠ¿ç­‰å¤šç»´åº¦å› ç´ `
      };
      
      // ç¼“å­˜é¢„æµ‹ç»“æœ
      predictionCache[cacheKey] = prediction;
      predictionTimestamp[cacheKey] = now;
      
      return prediction;
    }
    
    // éªŒè¯å’Œä¿®æ­£é¢„æµ‹ç»“æœ
    function validateAndFixPrediction(prediction, gameType, dateSeed = new Date().getDate() + new Date().getMonth() * 31) {
      // ç¡®ä¿numbersæ˜¯æ•°ç»„ä¸”é•¿åº¦ä¸º7
      if (!Array.isArray(prediction.numbers) || prediction.numbers.length !== 7) {
        return generateIntelligentPrediction(gameType, 'validation_fix');
      }
      
      // ç¡®ä¿æ‰€æœ‰å·ç åœ¨1-49èŒƒå›´å†…ä¸”ä¸é‡å¤
      const validNumbers = prediction.numbers.filter(num => 
        Number.isInteger(num) && num >= 1 && num <= 49
      );
      
      if (validNumbers.length !== 7 || new Set(validNumbers).size !== 7) {
        return generateIntelligentPrediction(gameType, 'validation_fix');
      }
      
      // ç¡®ä¿ç”Ÿè‚–æœ‰æ•ˆ
      if (!zodiacAnimals.includes(prediction.zodiac)) {
        prediction.zodiac = zodiacAnimals[dateSeed % 12];
      }
      
      // æ’åºå·ç 
      prediction.numbers.sort((a, b) => a - b);
      
      return prediction;
    }
    
    // æ˜¾ç¤ºé¢„æµ‹ç»“æœ
    function displayPredictionResult(prediction, type = 'hk') {
      const resultDiv = document.getElementById(`${type}PredictionResult`);
      const nextPeriod = getNextPeriod(type); // ä½¿ç”¨ä¸‹ä¸€æœŸæœŸå·è¿›è¡Œé¢„æµ‹
      const strategy = currentStrategy[type];
      const strategyInfo = PREDICTION_STRATEGIES[strategy];
      
      // ä¿å­˜é¢„æµ‹è®°å½•
      savePredictionRecord(type, nextPeriod, prediction, strategy);
      
      const numbersHtml = prediction.numbers.map((num, index) => 
        `<div class="prediction-number ${getNumberColor(num)}" style="animation-delay: ${index * 0.1}s">${num}</div>`
      ).join('');
      
      const currentZodiacEmoji = zodiacEmoji[prediction.zodiac] || 'ğŸ²';
      const typeName = type === 'hk' ? 'é¦™æ¸¯æ•°å­—' : 'æ¾³é—¨æ•°å­—';
      
      // åˆ†æå·ç åˆ†å¸ƒ
      const oddCount = prediction.numbers.filter(n => n % 2 === 1).length;
      const evenCount = 7 - oddCount;
      const smallCount = prediction.numbers.filter(n => n <= 24).length;
      const bigCount = 7 - smallCount;
      
      // è®¡ç®—å·ç è·¨åº¦
      const span = Math.max(...prediction.numbers) - Math.min(...prediction.numbers);
      
      // è®¡ç®—è¿å·æƒ…å†µ
      let consecutiveCount = 0;
      for (let i = 1; i < prediction.numbers.length; i++) {
        if (prediction.numbers[i] - prediction.numbers[i-1] === 1) {
          consecutiveCount++;
        }
      }
      
      // AIéªŒè¯æ ‡è¯†
      const aiVerification = strategyInfo.useAI ? 
        '<span style="color: #059669; font-weight: 600;">âœ“ AIé¢„æµ‹éªŒè¯</span>' : 
        '<span style="color: #0ea5e9; font-weight: 600;">ğŸ“Š ç»Ÿè®¡åˆ†æ</span>';
      
      resultDiv.innerHTML = `
        <h5>ğŸ¯ ${typeName}æ™ºèƒ½é¢„æµ‹ç»“æœ (æœŸå·: ${nextPeriod})</h5>
        <div class="prediction-numbers">${numbersHtml}</div>
        <div class="prediction-zodiac">
           <strong>ç‰¹ç ç”Ÿè‚–ï¼š</strong>${currentZodiacEmoji} ${prediction.zodiac}
         </div>
        
        <div style="margin-top: 16px; padding: 12px; background: #f8fafc; border-radius: 8px; border-left: 4px solid #3b82f6;">
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 13px;">
            <div><strong>é¢„æµ‹ç­–ç•¥ï¼š</strong>${strategyInfo.name}</div>
            <div><strong>éªŒè¯æ–¹å¼ï¼š</strong>${aiVerification}</div>
            <div><strong>ç½®ä¿¡åº¦ï¼š</strong><span style="color: #059669;">${prediction.confidence}</span></div>
            <div><strong>å¥‡å¶æ¯”ï¼š</strong>${oddCount}:${evenCount}</div>
            <div><strong>å¤§å°æ¯”ï¼š</strong>${bigCount}:${smallCount}</div>
            <div><strong>å·ç è·¨åº¦ï¼š</strong>${span}</div>
            <div><strong>è¿å·æ•°ï¼š</strong>${consecutiveCount}</div>
            <div><strong>å’Œå€¼ï¼š</strong>${prediction.numbers.reduce((a,b) => a+b, 0)}</div>
          </div>
        </div>
        
        <div style="margin-top: 12px; padding: 12px; background: #f0f9ff; border-radius: 8px; border-left: 4px solid #0ea5e9;">
          <div style="font-size: 13px; color: #0c4a6e; font-weight: 500; margin-bottom: 6px;">ğŸ“Š é¢„æµ‹ä¾æ®</div>
          <div style="font-size: 12px; color: #075985; line-height: 1.4;">${prediction.analysis || strategyInfo.description}</div>
        </div>

        ${Array.isArray(prediction.reasoning) && prediction.reasoning.length ? `
        <div style="margin-top: 12px; padding: 12px; background: #eef2ff; border-radius: 8px; border-left: 4px solid #6366f1;">
          <div style="font-size: 13px; color: #1e293b; font-weight: 600; margin-bottom: 6px;">ğŸ§  æ¨ç†è¿‡ç¨‹</div>
          <ol style="margin: 0; padding-left: 16px; color: #334155; font-size: 12px; line-height: 1.5;">
            ${prediction.reasoning.map(step => `<li>${step}</li>`).join('')}
          </ol>
        </div>
        ` : ''}

        <div style="margin-top: 12px; padding: 10px; background: #ecfdf5; border-radius: 8px; border-left: 4px solid #10b981;">
          <div style="font-size: 12px; color: #065f46; line-height: 1.5;">
            âœ… æ•°æ®å‡†ç¡®æ€§ï¼šå·²å®Œæˆå·ç èŒƒå›´æ ¡éªŒã€å»é‡ã€è¿å·æ§åˆ¶ã€å¥‡å¶ä¸å¤§å°æ¯”æ£€æµ‹ï¼›å†å²å‡†ç¡®ç‡åœ¨å¼€å¥–éªŒè¯åè‡ªåŠ¨æ›´æ–°å±•ç¤ºã€‚
          </div>
        </div>
        
        <div style="margin-top: 16px; padding: 12px; background: #fef3c7; border-radius: 6px; font-size: 12px; color: #92400e;">
          âš ï¸ è¯´æ˜ï¼šç»“æœç”±ç»Ÿè®¡å­¦ä¸AIåˆ†æç”Ÿæˆï¼Œå¹¶é€šè¿‡å‰ç«¯æ ¡éªŒä¿è¯æ•°æ®å‡†ç¡®æ€§å±•ç¤ºï¼›ä½†æ•°å­—å…·æœ‰éšæœºæ€§ï¼Œè¯·ç†æ€§å¯¹å¾…ã€‚
        </div>
      `;
      
      resultDiv.style.display = 'block';
      
      // æ›´æ–°ç•Œé¢æ˜¾ç¤º
      updatePeriodDisplay();
      updateAccuracyDisplay(type);
      
      showToast(`${typeName}é¢„æµ‹å®Œæˆï¼æœŸå·${nextPeriod}å»ºè®®å·ç å·²ç”Ÿæˆ`, 'success');
    }
    
    // æ ‡ç­¾é¡µåˆ‡æ¢åŠŸèƒ½
    function initPredictionTabs() {
      const hkTab = document.getElementById('hkPredictTab');
      const macauTab = document.getElementById('macauPredictTab');
      const hkPanel = document.getElementById('hkPrediction');
      const macauPanel = document.getElementById('macauPrediction');
      
      function switchTab(activeTab, activePanel, inactiveTab, inactivePanel) {
        activeTab.classList.add('active');
        inactiveTab.classList.remove('active');
        activePanel.classList.add('active');
        activePanel.style.display = 'block';
        inactivePanel.classList.remove('active');
        inactivePanel.style.display = 'none';
      }
      
      hkTab.addEventListener('click', () => {
        switchTab(hkTab, hkPanel, macauTab, macauPanel);
      });
      
      macauTab.addEventListener('click', () => {
        switchTab(macauTab, macauPanel, hkTab, hkPanel);
      });
    }
    
    // é¦™æ¸¯æ•°å­—é¢„æµ‹å‡½æ•°ï¼ˆå¸¦AIæ¨ç†è¿‡ç¨‹æ˜¾ç¤ºï¼‰
    async function predictHKLottery() {
      console.log('ğŸ¯ å¼€å§‹é¦™æ¸¯æ•°å­—é¢„æµ‹ - predictHKLottery');
      
      const resultDiv = document.getElementById('hkPredictionResult');
      const loadingDiv = document.getElementById('hkPredictionLoading');
      
      resultDiv.style.display = 'none';
      loadingDiv.style.display = 'block';
      
      try {
        const cfg = getAIConfig();
        console.log('âš™ï¸ è·å–AIé…ç½®:', cfg);
        
        // æ˜¾ç¤ºAIæ¨ç†è¿‡ç¨‹
        const thinkingSteps = [
          'ğŸ“Š æ­£åœ¨åˆ†æå†å²å¼€å¥–æ•°æ®...',
          'ğŸ” ç»Ÿè®¡å·ç å‡ºç°é¢‘ç‡...',
          'ğŸ“ˆ åˆ†æå¥‡å¶æ•°åˆ†å¸ƒè§„å¾‹...',
          'âš–ï¸ å¹³è¡¡å¤§å°å·ç æ¯”ä¾‹...',
          'ğŸ¯ è®¡ç®—è¿å·å‡ºç°æ¦‚ç‡...',
          'ğŸ‰ åˆ†æç”Ÿè‚–å‘¨æœŸæ€§è§„å¾‹...',
          'ğŸ§  ç»¼åˆæ‰€æœ‰å› ç´ è¿›è¡Œé¢„æµ‹...'
        ];
        
        let currentStep = 0;
        const loadingText = loadingDiv.querySelector('.loading-text') || loadingDiv;
        
        // é€æ­¥æ˜¾ç¤ºAIæ€è€ƒè¿‡ç¨‹
        const thinkingInterval = setInterval(() => {
          if (currentStep < thinkingSteps.length) {
            loadingText.innerHTML = thinkingSteps[currentStep];
            currentStep++;
          } else {
            clearInterval(thinkingInterval);
          }
        }, 800);
        
        const prompt = `ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„é¦™æ¸¯æ•°å­—æ•°æ®åˆ†æå¸ˆã€‚è¯·åŸºäºç»Ÿè®¡å­¦åŸç†å’Œå†å²æ•°æ®æ¨¡å¼ï¼Œä¸ºé¦™æ¸¯æ•°å­—é¢„æµ‹æœ€å¯èƒ½çš„7ä¸ªå·ç ï¼ˆ1-49ï¼‰å’Œå¯¹åº”çš„ç”Ÿè‚–ã€‚
        
        è¯·è€ƒè™‘ä»¥ä¸‹å› ç´ ï¼Œå¹¶æŒ‰ä¸å°‘äº ${cfg.reasoningDepth} æ­¥è¿›è¡Œæ¸…æ™°çš„æ¨ç†ï¼š
        1. å·ç å‡ºç°é¢‘ç‡ç»Ÿè®¡
        2. å¥‡å¶æ•°åˆ†å¸ƒè§„å¾‹
        3. å¤§å°å·ç å¹³è¡¡
        4. è¿å·å‡ºç°æ¦‚ç‡
        5. ç”Ÿè‚–å‘¨æœŸæ€§è§„å¾‹
        
        è¯·ç›´æ¥è¿”å›JSONæ ¼å¼çš„é¢„æµ‹ç»“æœï¼Œæ ¼å¼å¦‚ä¸‹ï¼š
        {
          \"numbers\": [1, 8, 15, 22, 29, 36, 43],
          \"zodiac\": \"é¾™\",
          \"confidence\": \"85%\",
          \"analysis\": \"åŸºäºè¿‘æœŸæ•°æ®åˆ†æ...\",
          \"reasoning\": [
            \"æ ¹æ®è¿‘æœŸé¢‘ç‡é€‰å–é«˜æ¦‚ç‡å·ç \",
            \"æ§åˆ¶å¥‡å¶ä¸å¤§å°æ¯”ä¾‹åœ¨åˆç†èŒƒå›´\",
            \"é¿å…è¿‡å¤šè¿å·å¹¶ä¼˜åŒ–åˆ†å¸ƒ\",
            \"ç»“åˆè¶‹åŠ¿ä¸å†å²äº¤å‰éªŒè¯\"
          ]
        }`;
        
        console.log('ğŸ“‹ æ„å»ºé¦™æ¸¯AIæç¤ºè¯ï¼Œé•¿åº¦:', prompt.length, 'å­—ç¬¦');
        
        let content;
        try {
          content = await callOpenRouter(prompt);
          console.log('âœ… é¦™æ¸¯AIè°ƒç”¨æˆåŠŸï¼Œè¿”å›å†…å®¹é•¿åº¦:', content.length, 'å­—ç¬¦');
        } catch (error) {
          console.error('âŒ é¦™æ¸¯AIè°ƒç”¨å¤±è´¥:', error);
          throw error;
        }
        
        clearInterval(thinkingInterval);
        
        let prediction;
        try {
          console.log('ğŸ” å¼€å§‹è§£æé¦™æ¸¯AIè¿”å›çš„JSON...');
          const jsonMatch = content.match(/\{[\s\S]*\}/);
          if (jsonMatch) {
            prediction = JSON.parse(jsonMatch[0]);
            console.log('âœ… é¦™æ¸¯AI JSONè§£ææˆåŠŸ:', prediction);
          } else {
            throw new Error('æœªæ‰¾åˆ°JSONæ ¼å¼');
          }
        } catch (parseError) {
          console.error('âŒ é¦™æ¸¯AI JSONè§£æå¤±è´¥ï¼Œä½¿ç”¨æ™ºèƒ½é¢„æµ‹ç®—æ³•:', parseError);
          console.log('ğŸ“ é¦™æ¸¯AIåŸå§‹å“åº”:', content);
          prediction = generateIntelligentPrediction('hk');
        }
        
        const dateSeed = new Date().getDate() + new Date().getMonth() * 31;
        prediction = validateAndFixPrediction(prediction, 'hk', dateSeed);
        displayPredictionResult(prediction, 'hk');
        
      } catch (error) {
        console.error('âŒ é¦™æ¸¯æ•°å­—é¢„æµ‹å¤±è´¥:', error);
        if (typeof thinkingInterval !== 'undefined') {
          clearInterval(thinkingInterval);
        }
        showToast('é¦™æ¸¯æ•°å­—é¢„æµ‹å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•', 'error');
        const intelligentPrediction = generateIntelligentPrediction('hk');
        displayPredictionResult(intelligentPrediction, 'hk');
      } finally {
        loadingDiv.style.display = 'none';
        console.log('ğŸ¯ é¦™æ¸¯æ•°å­—é¢„æµ‹ç»“æŸ');
      }
    }
    
    // æ¾³é—¨æ•°å­—é¢„æµ‹å‡½æ•°ï¼ˆå¸¦AIæ¨ç†è¿‡ç¨‹æ˜¾ç¤ºï¼‰
    async function predictMacauLottery() {
      console.log('ğŸ¯ å¼€å§‹æ¾³é—¨æ•°å­—é¢„æµ‹ - predictMacauLottery');
      
      const resultDiv = document.getElementById('macauPredictionResult');
      const loadingDiv = document.getElementById('macauPredictionLoading');
      
      resultDiv.style.display = 'none';
      loadingDiv.style.display = 'block';
      
      try {
        const cfg = getAIConfig();
        console.log('âš™ï¸ è·å–AIé…ç½®:', cfg);
        
        // æ˜¾ç¤ºAIæ¨ç†è¿‡ç¨‹
        const thinkingSteps = [
          'ğŸ“Š æ­£åœ¨åˆ†ææ¾³é—¨å†å²å¼€å¥–æ•°æ®...',
          'ğŸ” ç»Ÿè®¡æ¾³é—¨å·ç å‡ºç°é¢‘ç‡...',
          'ğŸ“ˆ åˆ†ææ¾³é—¨å¥‡å¶æ•°åˆ†å¸ƒè§„å¾‹...',
          'âš–ï¸ å¹³è¡¡æ¾³é—¨å¤§å°å·ç æ¯”ä¾‹...',
          'ğŸ¯ è®¡ç®—æ¾³é—¨è¿å·å‡ºç°æ¦‚ç‡...',
          'ğŸ¯ åˆ†ææ¾³é—¨ç”Ÿè‚–ç‰¹æœ‰è§„å¾‹...',
          'ğŸ§  ç»¼åˆæ¾³é—¨ç‰¹æœ‰å› ç´ è¿›è¡Œé¢„æµ‹...'
        ];
        
        let currentStep = 0;
        const loadingText = loadingDiv.querySelector('.loading-text') || loadingDiv;
        
        // é€æ­¥æ˜¾ç¤ºAIæ€è€ƒè¿‡ç¨‹
        const thinkingInterval = setInterval(() => {
          if (currentStep < thinkingSteps.length) {
            loadingText.innerHTML = thinkingSteps[currentStep];
            currentStep++;
          } else {
            clearInterval(thinkingInterval);
          }
        }, 800);
        
        const prompt = `ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„æ¾³é—¨æ•°å­—æ•°æ®åˆ†æå¸ˆã€‚è¯·åŸºäºç»Ÿè®¡å­¦åŸç†å’Œå†å²æ•°æ®æ¨¡å¼ï¼Œä¸ºæ¾³é—¨æ•°å­—é¢„æµ‹æœ€å¯èƒ½çš„7ä¸ªå·ç ï¼ˆ1-49ï¼‰å’Œå¯¹åº”çš„ç”Ÿè‚–ã€‚
        æ¾³é—¨æ•°å­—ç‰¹ç‚¹ï¼š
        1. å¼€å¥–é¢‘ç‡æ›´é«˜ï¼Œæ•°æ®æ ·æœ¬æ›´ä¸°å¯Œ
        2. å·ç åˆ†å¸ƒç›¸å¯¹æ›´å‡åŒ€
        3. ç”Ÿè‚–è§„å¾‹ä¸é¦™æ¸¯ç•¥æœ‰ä¸åŒ
        4. è¿å·å‡ºç°é¢‘ç‡è¾ƒä½
        5. å¤§å°å·ç åˆ†å¸ƒæ›´å¹³è¡¡

        è¯·è€ƒè™‘ä»¥ä¸‹å› ç´ ï¼Œå¹¶æŒ‰ä¸å°‘äº ${cfg.reasoningDepth} æ­¥è¿›è¡Œæ¸…æ™°çš„æ¨ç†ï¼š
        1. æ¾³é—¨å·ç å‡ºç°é¢‘ç‡ç»Ÿè®¡
        2. æ¾³é—¨å¥‡å¶æ•°åˆ†å¸ƒè§„å¾‹
        3. æ¾³é—¨å¤§å°å·ç å¹³è¡¡
        4. æ¾³é—¨è¿å·å‡ºç°æ¦‚ç‡
        5. æ¾³é—¨ç”Ÿè‚–ç‰¹æœ‰å‘¨æœŸæ€§è§„å¾‹

        è¯·ç›´æ¥è¿”å›JSONæ ¼å¼çš„é¢„æµ‹ç»“æœï¼Œæ ¼å¼å¦‚ä¸‹ï¼š
        {
          "numbers": [3, 12, 18, 25, 31, 38, 45],
          "zodiac": "è™",
          "confidence": "82%",
          "analysis": "åŸºäºæ¾³é—¨æ•°å­—ç‰¹æœ‰è§„å¾‹åˆ†æ...",
          "reasoning": [
            "ç»“åˆæ¾³é—¨å¼€å¥–é¢‘ç‡è¿›è¡Œé¢‘ç‡ç­›é€‰",
            "å¹³è¡¡å¤§å°ä¸å¥‡å¶æ¯”ä¾‹",
            "é™åˆ¶è¿å·æ•°é‡å¹¶ä¼˜åŒ–åˆ†å¸ƒ",
            "æŒ‰è¿‘æœŸèµ°åŠ¿è°ƒæ•´å€™é€‰é›†"
          ]
        }`;

        console.log('ğŸ“‹ æ„å»ºæ¾³é—¨AIæç¤ºè¯ï¼Œé•¿åº¦:', prompt.length, 'å­—ç¬¦');
        
        let content;
        try {
          content = await callOpenRouter(prompt);
          console.log('âœ… æ¾³é—¨AIè°ƒç”¨æˆåŠŸï¼Œè¿”å›å†…å®¹é•¿åº¦:', content.length, 'å­—ç¬¦');
        } catch (error) {
          console.error('âŒ æ¾³é—¨AIè°ƒç”¨å¤±è´¥:', error);
          throw error;
        }
        
        clearInterval(thinkingInterval);

        let prediction;
        try {
          console.log('ğŸ” å¼€å§‹è§£ææ¾³é—¨AIè¿”å›çš„JSON...');
          const jsonMatch = content.match(/\{[\s\S]*\}/);
          if (jsonMatch) {
            prediction = JSON.parse(jsonMatch[0]);
            console.log('âœ… æ¾³é—¨AI JSONè§£ææˆåŠŸ:', prediction);
          } else {
            throw new Error('æœªæ‰¾åˆ°JSONæ ¼å¼');
          }
        } catch (parseError) {
          console.error('âŒ æ¾³é—¨AI JSONè§£æå¤±è´¥ï¼Œä½¿ç”¨æ™ºèƒ½é¢„æµ‹ç®—æ³•:', parseError);
          console.log('ğŸ“ æ¾³é—¨AIåŸå§‹å“åº”:', content);
          prediction = generateIntelligentPrediction('macau');
        }

        const dateSeed = new Date().getDate() + new Date().getMonth() * 31;
        prediction = validateAndFixPrediction(prediction, 'macau', dateSeed);
        displayPredictionResult(prediction, 'macau');

      } catch (error) {
        console.error('âŒ æ¾³é—¨æ•°å­—é¢„æµ‹å¤±è´¥:', error);
        if (typeof thinkingInterval !== 'undefined') {
          clearInterval(thinkingInterval);
        }
        showToast('æ¾³é—¨æ•°å­—é¢„æµ‹å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•', 'error');
        const intelligentPrediction = generateIntelligentPrediction('macau');
        displayPredictionResult(intelligentPrediction, 'macau');
      } finally {
        loadingDiv.style.display = 'none';
        console.log('ğŸ¯ æ¾³é—¨æ•°å­—é¢„æµ‹ç»“æŸ');
      }
    }
    
    // ç»‘å®šé¢„æµ‹æŒ‰é’®äº‹ä»¶
    const hkPredictBtn = document.getElementById('hkPredictBtn');
    const macauPredictBtn = document.getElementById('macauPredictBtn');
    
    if (hkPredictBtn) {
      console.log('ğŸ¯ é¦™æ¸¯é¢„æµ‹æŒ‰é’®å·²ç»‘å®šäº‹ä»¶');
      hkPredictBtn.addEventListener('click', async () => {
        console.log('ğŸ¯ é¦™æ¸¯é¢„æµ‹æŒ‰é’®è¢«ç‚¹å‡»ï¼');
        try {
          await predictHKLottery();
          console.log('âœ… é¦™æ¸¯é¢„æµ‹å®Œæˆ');
        } catch (error) {
          console.error('âŒ é¦™æ¸¯é¢„æµ‹å¤±è´¥:', error);
        }
      });
    } else {
      console.warn('âš ï¸ æœªæ‰¾åˆ°é¦™æ¸¯é¢„æµ‹æŒ‰é’®');
    }
    
    if (macauPredictBtn) {
      console.log('ğŸ¯ æ¾³é—¨é¢„æµ‹æŒ‰é’®å·²ç»‘å®šäº‹ä»¶');
      macauPredictBtn.addEventListener('click', async () => {
        console.log('ğŸ¯ æ¾³é—¨é¢„æµ‹æŒ‰é’®è¢«ç‚¹å‡»ï¼');
        try {
          await predictMacauLottery();
          console.log('âœ… æ¾³é—¨é¢„æµ‹å®Œæˆ');
        } catch (error) {
          console.error('âŒ æ¾³é—¨é¢„æµ‹å¤±è´¥:', error);
        }
      });
    } else {
      console.warn('âš ï¸ æœªæ‰¾åˆ°æ¾³é—¨é¢„æµ‹æŒ‰é’®');
    }
    
    // åˆå§‹åŒ–æ ‡ç­¾é¡µ
    initPredictionTabs();
    
    // é¡µé¢åŠ è½½å®Œæˆåå¯åŠ¨å€’è®¡æ—¶
    window.addEventListener('DOMContentLoaded', function() {
      startLotteryCountdown();
      
      // åˆå§‹åŒ–é¢„æµ‹ç³»ç»Ÿ
      updatePeriodDisplay();
      updatePredictionHistory('hk');
      updatePredictionHistory('macau');
      updateAccuracyDisplay('hk');
      updateAccuracyDisplay('macau');
      
      // ä»…ä¿ç•™ AI ç­–ç•¥ï¼Œåˆå§‹åŒ–æ˜¾ç¤º
      currentStrategy.hk = 'ai';
      currentStrategy.macau = 'ai';
      document.getElementById('hkCurrentStrategy').textContent = PREDICTION_STRATEGIES.ai.name;
      document.getElementById('macauCurrentStrategy').textContent = PREDICTION_STRATEGIES.ai.name;
      
      // å¯åŠ¨è‡ªåŠ¨éªŒè¯
      startAutoVerification();
    });
  </script>
</body>
</html>
