<!doctype html>
<html lang="zh-CN">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ç›å¡å·´å¡ç•™è¨€æ¿</title>
  <style>
    :root {
      --bg: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      --bg-secondary: #f8fafc;
      --card: #ffffff;
      --card-hover: #ffffff;
      --line: #e2e8f0;
      --text: #1e293b;
      --text-light: #64748b;
      --muted: #64748b;
      --accent: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      --accent-hover: linear-gradient(135deg, #5a67d8 0%, #6b46c1 100%);
      --success: #10b981;
      --error: #ef4444;
      --warning: #f59e0b;
      --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      --shadow-lg: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
    }

    * {
      box-sizing: border-box;
    }

    body {
      font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'PingFang SC', 'Noto Sans SC', sans-serif;
      margin: 0;
      background: var(--bg);
      background-attachment: fixed;
      color: var(--text);
      line-height: 1.6;
      overflow-x: hidden;
    }

    .wrap {
      max-width: 900px;
      margin: 32px auto;
      padding: 20px;
    }

    .card {
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 24px;
      box-shadow: var(--shadow);
      margin-bottom: 24px;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      backdrop-filter: blur(10px);
      position: relative;
      overflow: hidden;
    }

    .card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 2px;
      background: var(--accent);
      transform: scaleX(0);
      transition: transform 0.3s ease;
    }

    .card:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }

    .card:hover::before {
      transform: scaleX(1);
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 20px;
    }

    h2,
    h3 {
      margin: 0;
      background: var(--accent);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      font-weight: 700;
    }

    .userbox {
      display: flex;
      align-items: center;
      gap: 16px;
    }

    .avatar {
      width: 48px;
      height: 48px;
      border-radius: 12px;
      display: grid;
      place-items: center;
      font-size: 24px;
      background: linear-gradient(135deg, #fef3c7 0%, #fcd34d 100%);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      transition: transform 0.2s ease;
    }

    .avatar:hover {
      transform: scale(1.05);
    }

    .name {
      font-weight: 600;
      font-size: 16px;
      color: var(--text);
    }

    .muted {
      color: var(--muted);
      font-size: 13px;
      font-weight: 400;
    }

    .row {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }

    .presence {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: 12px;
    }

    .presence .pill {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      border: 1px solid var(--line);
      border-radius: 20px;
      background: var(--card);
      transition: all 0.2s ease;
      cursor: default;
    }

    .presence .pill:hover {
      background: var(--bg-secondary);
      transform: translateY(-1px);
    }

    .presence .pill .dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--success);
      box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.2);
      animation: pulse 2s infinite;
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: 0.7;
      }
    }

    .composer {
      display: flex;
      gap: 12px;
      align-items: flex-end;
    }

    textarea {
      flex: 1;
      min-height: 80px;
      max-height: 200px;
      padding: 16px;
      border: 2px solid var(--line);
      border-radius: 12px;
      outline: none;
      font-size: 15px;
      background: var(--card);
      transition: all 0.3s ease;
      resize: none;
      font-family: inherit;
      line-height: 1.5;
    }

    textarea:focus {
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      background: #fafbfc;
    }

    button {
      padding: 12px 20px;
      border: 0;
      border-radius: 12px;
      background: var(--accent);
      color: #fff;
      cursor: pointer;
      white-space: nowrap;
      font-weight: 600;
      font-size: 14px;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: left 0.5s;
    }

    button:hover::before {
      left: 100%;
    }

    button:hover {
      background: var(--accent-hover);
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
    }

    button:active {
      transform: translateY(0);
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    ul#list {
      list-style: none;
      padding: 0;
      margin: 20px 0 0 0;
    }

    li.msg {
      display: flex;
      gap: 12px;
      padding: 16px;
      border: 1px solid var(--line);
      border-radius: 16px;
      background: var(--card);
      margin-bottom: 12px;
      transition: all 0.3s ease;
      animation: slideIn 0.5s ease-out;
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateX(-20px);
      }

      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    li.msg:hover {
      background: var(--bg-secondary);
      transform: translateX(4px);
    }

    .bubble {
      flex: 1;
    }

    .meta {
      font-size: 12px;
      color: var(--muted);
      margin: 8px 0 0;
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }

    /* ç™»å½•æ¡†ä¼˜åŒ– */
    .login {
      max-width: 400px;
      margin: 100px auto;
      animation: fadeInUp 0.8s ease-out;
    }

    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(30px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .login .card {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .login h3 {
      margin: 0 0 20px;
      text-align: center;
      font-size: 24px;
      font-weight: 700;
    }

    .login .field {
      display: flex;
      gap: 12px;
      align-items: stretch;
    }

    input[type=password] {
      flex: 1;
      padding: 14px 16px;
      border: 2px solid var(--line);
      border-radius: 12px;
      outline: none;
      font-size: 15px;
      transition: all 0.3s ease;
      background: var(--card);
    }

    input[type=password]:focus {
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }

    .error {
      color: var(--error);
      font-size: 13px;
      margin-top: 12px;
      min-height: 20px;
      font-weight: 500;
    }

    .topbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
    }

    .actions {
      display: flex;
      gap: 12px;
    }

    .logout {
      background: var(--card);
      color: var(--text);
      border: 2px solid var(--line);
    }

    .logout:hover {
      background: var(--bg-secondary);
      border-color: var(--error);
      color: var(--error);
    }

    .config {
      background: var(--card);
      color: var(--text);
      border: 2px solid var(--line);
    }

    .config:hover {
      background: var(--bg-secondary);
      border-color: #667eea;
      color: #667eea;
    }

    /* å¼€å¥–æ¨¡å—ä¼˜åŒ– */
    select {
      padding: 10px 12px;
      font-size: 14px;
      margin-bottom: 16px;
      border: 2px solid var(--line);
      border-radius: 8px;
      background: var(--card);
      transition: all 0.3s ease;
      cursor: pointer;
    }

    select:focus {
      border-color: #667eea;
      outline: none;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }

    /* å¼€å¥–ä¿¡æ¯å¸ƒå±€ */
    .lottery-container {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .lottery-main {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 16px;
      color: white;
      box-shadow: 0 8px 32px rgba(102, 126, 234, 0.3);
    }

    .lottery-issue {
      font-size: 16px;
      font-weight: 500;
      opacity: 0.9;
      margin-bottom: 8px;
    }

    .lottery-numbers {
      font-size: 32px;
      font-weight: 800;
      letter-spacing: 2px;
      text-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      margin: 8px 0;
      line-height: 1.2;
    }

    .lottery-numbers .number {
      display: inline-block;
      background: rgba(255, 255, 255, 0.2);
      padding: 8px 12px;
      margin: 0 4px;
      border-radius: 12px;
      min-width: 50px;
      text-align: center;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.3);
    }

    .lottery-zodiac {
      font-size: 18px;
      margin-top: 12px;
      padding: 12px 16px;
      background: rgba(255, 255, 255, 0.15);
      border-radius: 12px;
      backdrop-filter: blur(10px);
    }

    .lottery-next {
      font-size: 14px;
      opacity: 0.8;
      margin-top: 8px;
    }

    .lottery-history {
      background: var(--card);
      border-radius: 12px;
      padding: 16px;
      border: 2px solid var(--line);
    }

    .lottery-history h4 {
      margin: 0 0 12px 0;
      color: var(--text);
      font-size: 16px;
      font-weight: 600;
    }

    .lottery-history ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .lottery-history li {
      padding: 12px 0;
      border-bottom: 1px solid var(--line);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .lottery-history li:last-child {
      border-bottom: none;
    }

    .history-issue {
      font-weight: 600;
      color: var(--accent);
    }

    .history-numbers {
      font-size: 18px;
      font-weight: 700;
      color: var(--text);
      letter-spacing: 1px;
    }

    .zodiac {
      font-size: 16px;
      margin-top: 6px;
    }

    .countdown {
      font-weight: 600;
      color: var(--error);
      margin-top: 12px;
      padding: 12px;
      background: rgba(239, 68, 68, 0.1);
      border-radius: 8px;
      border-left: 4px solid var(--error);
    }

    /* AIé¢„æµ‹åŠŸèƒ½æ ·å¼ */
    .ai-prediction-section {
      margin-top: 24px;
      padding: 20px;
      background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
      border-radius: 12px;
      border: 1px solid #0ea5e9;
    }

    .ai-prediction-section h4 {
      margin: 0 0 12px 0;
      color: #0369a1;
      font-size: 18px;
    }

    .prediction-disclaimer {
      font-size: 12px;
      color: #64748b;
      margin: 0 0 16px 0;
      font-style: italic;
    }

    /* é¢„æµ‹å½©ç§é€‰æ‹©æ ·å¼ */
    .prediction-type-selector {
      margin-bottom: 20px;
    }

    .prediction-type-selector label {
      display: block;
      font-size: 14px;
      font-weight: 600;
      color: #0c4a6e;
      margin-bottom: 8px;
    }

    .prediction-tabs {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
    }

    .prediction-tab {
      flex: 1;
      padding: 12px 16px;
      border: 2px solid #0ea5e9;
      background: white;
      color: #0369a1;
      border-radius: 12px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .prediction-tab:hover {
      background: #f0f9ff;
      transform: translateY(-1px);
    }

    .prediction-tab.active {
      background: linear-gradient(135deg, #0ea5e9 0%, #0284c7 100%);
      color: white;
      box-shadow: 0 4px 12px rgba(14, 165, 233, 0.3);
    }

    .prediction-panel {
      display: none;
      animation: fadeIn 0.3s ease-in-out;
    }

    .prediction-panel.active {
      display: block;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .predict-btn {
      background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
    }

    .predict-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(59, 130, 246, 0.4);
    }

    .predict-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    .auto-prediction-status {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 12px 24px;
      border-radius: 25px;
      font-size: 14px;
      font-weight: 600;
      text-align: center;
      margin: 15px 0;
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
      transition: all 0.3s ease;
    }

    .auto-prediction-status.active {
      background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
      box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
    }

    .auto-prediction-status.waiting {
      background: linear-gradient(135deg, #FF9800 0%, #F57C00 100%);
      box-shadow: 0 4px 15px rgba(255, 152, 0, 0.3);
    }

    .manual-predict-btn {
      background: linear-gradient(45deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
    }

    .manual-predict-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
    }

    .manual-predict-btn:active {
      transform: translateY(0);
    }

    .manual-predict-btn:disabled {
      background: #9ca3af;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .prediction-loading {
      text-align: center;
      padding: 20px;
    }

    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 4px solid #e5e7eb;
      border-top: 4px solid #3b82f6;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    .prediction-info {
      background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
      border: 1px solid #cbd5e1;
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 15px;
      font-size: 14px;
    }

    .prediction-info>div {
      margin-bottom: 6px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .prediction-info>div:last-child {
      margin-bottom: 0;
    }

    .prediction-info span {
      font-weight: 600;
      color: #1e40af;
    }

    .accuracy-rate span {
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 12px;
    }

    .accuracy-high {
      background: #dcfce7;
      color: #166534;
    }

    .accuracy-medium {
      background: #fef3c7;
      color: #92400e;
    }

    .accuracy-low {
      background: #fee2e2;
      color: #991b1b;
    }

    .prediction-history {
      margin-top: 20px;
      border-top: 1px solid #e5e7eb;
      padding-top: 15px;
    }

    .prediction-history h5 {
      margin: 0 0 10px 0;
      color: #374151;
      font-size: 14px;
    }

    .history-list {
      max-height: 200px;
      overflow-y: auto;
    }

    .history-item {
      background: #f9fafb;
      border: 1px solid #e5e7eb;
      border-radius: 6px;
      padding: 8px 10px;
      margin-bottom: 8px;
      font-size: 12px;
    }

    .history-item:last-child {
      margin-bottom: 0;
    }

    .history-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;
    }

    .history-period {
      font-weight: 600;
      color: #1f2937;
    }

    .history-status {
      padding: 1px 6px;
      border-radius: 8px;
      font-size: 10px;
      font-weight: 600;
    }

    .status-pending {
      background: #dbeafe;
      color: #1e40af;
    }

    .status-correct {
      background: #dcfce7;
      color: #166534;
    }

    .status-incorrect {
      background: #fee2e2;
      color: #991b1b;
    }

    .history-numbers {
      color: #6b7280;
      margin-bottom: 2px;
    }

    .history-result {
      color: #374151;
      font-size: 11px;
    }

    .strategy-indicator {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 5px;
    }

    .strategy-ai {
      background: #3b82f6;
    }

    .strategy-statistical {
      background: #10b981;
    }

    .strategy-trend {
      background: #f59e0b;
    }

    .strategy-ml {
      background: #8b5cf6;
    }

    .strategy-hybrid {
      background: linear-gradient(45deg, #f59e0b, #10b981, #3b82f6, #8b5cf6);
      background-size: 400% 400%;
      animation: gradient-shift 3s ease-in-out infinite;
    }

    @keyframes gradient-shift {

      0%,
      100% {
        background-position: 0% 50%;
      }

      50% {
        background-position: 100% 50%;
      }
    }

    @keyframes blink {

      0%,
      50%,
      100% {
        opacity: 1;
      }

      25%,
      75% {
        opacity: 0.3;
      }
    }

    @keyframes pulse-glow {

      0%,
      100% {
        box-shadow: 0 0 5px rgba(255, 152, 0, 0.3);
      }

      50% {
        box-shadow: 0 0 20px rgba(255, 152, 0, 0.8);
      }
    }

    .strategy-switching {
      animation: pulse-glow 2s ease-in-out 3;
    }

    .ai-analysis-steps {
      margin-top: 15px;
      background: #f8f9fa;
      border-radius: 8px;
      padding: 15px;
      border-left: 4px solid #2196F3;
    }

    .ai-analysis-steps h6 {
      margin: 0 0 12px 0;
      color: #1976d2;
      font-size: 14px;
      font-weight: 600;
    }

    .analysis-step {
      padding: 8px 0;
      margin: 4px 0;
      border-radius: 4px;
      transition: all 0.3s ease;
      font-size: 13px;
      position: relative;
      padding-left: 25px;
    }

    .analysis-step::before {
      content: '';
      position: absolute;
      left: 0;
      top: 50%;
      transform: translateY(-50%);
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #ccc;
      transition: all 0.3s ease;
    }

    .analysis-step.active {
      background: rgba(33, 150, 243, 0.1);
      border-left: 3px solid #2196F3;
      color: #1976d2;
      font-weight: 500;
    }

    .analysis-step.active::before {
      background: #2196F3;
      box-shadow: 0 0 8px rgba(33, 150, 243, 0.6);
    }

    .analysis-step.completed {
      color: #4CAF50;
      background: rgba(76, 175, 80, 0.1);
    }

    .analysis-step.completed::before {
      background: #4CAF50;
    }

    .accuracy-high {
      color: #059669;
      font-weight: 600;
    }

    .accuracy-medium {
      color: #d97706;
      font-weight: 600;
    }

    .accuracy-low {
      color: #dc2626;
      font-weight: 600;
    }

    .loading-spinner {
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 12px;
    }

    .result-verification {
      margin-top: 20px;
      padding: 15px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .result-verification h6 {
      margin: 0 0 12px 0;
      color: #fbbf24;
      font-size: 14px;
      font-weight: 600;
    }

    .verification-form {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .period-input,
    .result-input {
      padding: 8px 12px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 6px;
      background: rgba(255, 255, 255, 0.1);
      color: white;
      font-size: 13px;
    }

    .period-input::placeholder,
    .result-input::placeholder {
      color: rgba(255, 255, 255, 0.6);
    }

    .verify-btn {
      padding: 8px 16px;
      background: linear-gradient(135deg, #10b981, #059669);
      color: white;
      border: none;
      border-radius: 6px;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .verify-btn:hover {
      background: linear-gradient(135deg, #059669, #047857);
      transform: translateY(-1px);
    }

    .result-comparison {
      margin-top: 8px;
      padding: 8px;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 4px;
      font-size: 12px;
    }

    .match-info {
      margin-top: 4px;
      color: #9ca3af;
    }

    .accuracy-info {
      color: #fbbf24;
      font-weight: 600;
    }

    .strategy-selector {
      margin: 10px 0;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .strategy-selector label {
      font-weight: bold;
      color: #333;
      min-width: 80px;
    }

    .strategy-selector select {
      padding: 8px 12px;
      border: 2px solid #ddd;
      border-radius: 8px;
      background: white;
      font-size: 14px;
      color: #333;
      cursor: pointer;
      transition: all 0.3s ease;
      min-width: 150px;
    }

    .strategy-selector select:hover {
      border-color: #007bff;
      box-shadow: 0 2px 8px rgba(0, 123, 255, 0.2);
    }

    .strategy-selector select:focus {
      outline: none;
      border-color: #007bff;
      box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.1);
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    .prediction-result {
      margin-top: 16px;
      padding: 20px;
      background: white;
      border-radius: 8px;
      border: 1px solid #e5e7eb;
    }

    .prediction-numbers {
      display: flex;
      gap: 8px;
      justify-content: center;
      margin: 16px 0;
      flex-wrap: wrap;
    }

    .prediction-number {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      color: white;
      font-size: 16px;
      animation: fadeInUp 0.5s ease;
    }

    .prediction-number.red {
      background: #ef4444;
    }

    .prediction-number.blue {
      background: #3b82f6;
    }

    .prediction-number.green {
      background: #10b981;
    }

    .prediction-zodiac {
      text-align: center;
      font-size: 24px;
      margin: 12px 0;
    }

    .prediction-confidence {
      text-align: center;
      font-size: 14px;
      color: #64748b;
      margin-top: 12px;
    }

    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* å“åº”å¼ä¼˜åŒ– */
    @media (max-width: 768px) {
      .lottery-numbers {
        font-size: 24px;
      }

      .lottery-numbers .number {
        padding: 6px 8px;
        margin: 0 2px;
        min-width: 40px;
      }

      .lottery-main {
        padding: 16px;
      }
    }

    /* Toast é€šçŸ¥æ ·å¼ */
    .toast {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 16px 20px;
      border-radius: 12px;
      color: white;
      font-weight: 500;
      z-index: 1000;
      transform: translateX(400px);
      transition: transform 0.3s ease;
      box-shadow: var(--shadow-lg);
    }

    .toast.show {
      transform: translateX(0);
    }

    .toast.success {
      background: var(--success);
    }

    .toast.error {
      background: var(--error);
    }

    .toast.warning {
      background: var(--warning);
    }

    /* å“åº”å¼ä¼˜åŒ– */
    @media (max-width: 768px) {
      .wrap {
        margin: 16px;
        padding: 16px;
      }

      .card {
        padding: 16px;
        margin-bottom: 16px;
      }

      .composer {
        flex-direction: column;
        align-items: stretch;
      }

      .login {
        margin: 60px auto;
      }

      .userbox {
        gap: 12px;
      }

      .avatar {
        width: 40px;
        height: 40px;
        font-size: 20px;
      }
    }
  </style>
</head>

<body>

  <!-- ç™»å½•è§†å›¾ -->
  <div id="loginView" class="wrap">
    <div class="card login">
      <h3>ç›å¡å·´å¡ç•™è¨€æ¿ Â· å¯†ç ç™»å½•</h3>
      <div class="muted" style="margin-bottom:10px;">â­=â­=â­=â­=â­=â­=â­=â­=â­=â­=â­=â­=â­</div>
      <div class="field">
        <input id="pwd" type="password" placeholder="è¾“å…¥å¯†ç ï¼Œä¾‹å¦‚ï¼šå¤©ä¸Šæœ‰å‡ é¢—æ˜Ÿæ˜Ÿï¼Ÿ" />
        <button id="loginBtn">è¿›å…¥</button>
      </div>
      <div id="loginErr" class="error"></div>
    </div>
  </div>

  <!-- ä¸»è§†å›¾ -->
  <div id="mainView" class="wrap" style="display:none;">
    <!-- ç”¨æˆ·ä¿¡æ¯ -->
    <div class="card">
      <div class="topbar">
        <div class="userbox">
          <div id="meAvatar" class="avatar">ğŸ™‚</div>
          <div>
            <div id="meName" class="name">æœªçŸ¥</div>
            <div class="muted">ç•™è¨€ä¼šåœ¨ 48 å°æ—¶åè‡ªåŠ¨æ¸…é™¤</div>
          </div>
        </div>
        <div class="actions">
          <!-- APIçŠ¶æ€æŒ‡ç¤ºå™¨ -->
          <div id="apiStatusIndicator"
            style="display:flex; align-items:center; gap:6px; padding:6px 10px; background:#f8fafc; border:1px solid #e2e8f0; border-radius:8px; margin-right:8px;">
            <div id="apiStatusDot" style="width:6px; height:6px; border-radius:50%; background:#ef4444;"></div>
            <span id="apiStatusText" style="font-size:11px; color:#64748b;">APIæœªé…ç½®</span>
          </div>
          <button id="quickApiBtn" class="config" onclick="openQuickApiSetup()"
            style="margin-right:4px; background:#10b981; border-color:#10b981;">ğŸ”‘ è®¾ç½®API</button>
          <button id="configBtn" class="config" onclick="openConfigPanel()">âš™ï¸ é…ç½®</button>
          <button id="logoutBtn" class="logout">é€€å‡º</button>
        </div>
      </div>
    </div>
    <div id="configModal"
      style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.45); z-index:1000; align-items:center; justify-content:center;">
      <div
        style="background:#fff; width:680px; max-width:90%; border-radius:12px; box-shadow:0 10px 30px rgba(0,0,0,0.2); overflow:hidden;">
        <div
          style="padding:14px 18px; border-bottom:1px solid #eee; font-weight:600; display:flex; align-items:center; justify-content:space-between;">
          <span>AI é…ç½®</span>
          <div style="display:flex; gap:8px;">
            <button onclick="switchConfigTab('ai')" id="aiConfigTab" class="config-tab active"
              style="padding:4px 12px; border:1px solid #ddd; background:#f8fafc; border-radius:6px; font-size:12px; cursor:pointer;">AIå‚æ•°</button>
            <button onclick="switchConfigTab('api')" id="apiConfigTab" class="config-tab"
              style="padding:4px 12px; border:1px solid #ddd; background:#fff; border-radius:6px; font-size:12px; cursor:pointer;">APIå¯†é’¥</button>
          </div>
        </div>

        <!-- AIå‚æ•°é…ç½®é¢æ¿ -->
        <div id="aiConfigPanel" class="config-panel"
          style="padding:16px; display:grid; grid-template-columns:1fr 1fr; gap:12px;">
          <label style="display:flex; flex-direction:column; gap:6px; font-size:12px;">
            <span>æ¸©åº¦ (0-1)</span>
            <input id="cfg_temperature" type="number" min="0" max="1" step="0.05"
              style="padding:8px; border:1px solid #ddd; border-radius:8px;" />
          </label>
          <label style="display:flex; flex-direction:column; gap:6px; font-size:12px;">
            <span>æœ€å¤§Tokens</span>
            <input id="cfg_max_tokens" type="number" min="100" max="4000" step="50"
              style="padding:8px; border:1px solid #ddd; border-radius:8px;" />
          </label>
          <label style="display:flex; flex-direction:column; gap:6px; font-size:12px;">
            <span>éªŒè¯çª—å£å¤§å°</span>
            <input id="cfg_windowSize" type="number" min="3" max="50" step="1"
              style="padding:8px; border:1px solid #ddd; border-radius:8px;" />
          </label>
          <label style="display:flex; flex-direction:column; gap:6px; font-size:12px;">
            <span>æœ€ä½èƒœç‡é˜ˆå€¼ (%)</span>
            <input id="cfg_minWinRate" type="number" min="10" max="100" step="1"
              style="padding:8px; border:1px solid #ddd; border-radius:8px;" />
          </label>
          <label style="display:flex; flex-direction:column; gap:6px; font-size:12px;">
            <span>è°ƒæ•´æ¨¡å¼</span>
            <select id="cfg_adjustMode" style="padding:8px; border:1px solid #ddd; border-radius:8px;">
              <option value="conservative">ä¿å®ˆ</option>
              <option value="aggressive">æ¿€è¿›</option>
            </select>
          </label>
          <label style="display:flex; flex-direction:column; gap:6px; font-size:12px;">
            <span>æ¨ç†æ·±åº¦</span>
            <input id="cfg_reasoningDepth" type="number" min="1" max="10" step="1"
              style="padding:8px; border:1px solid #ddd; border-radius:8px;" />
          </label>
        </div>

        <!-- APIå¯†é’¥é…ç½®é¢æ¿ -->
        <div id="apiConfigPanel" class="config-panel" style="padding:16px; display:none;">
          <!-- APIæä¾›å•†é€‰æ‹© -->
          <div style="margin-bottom:16px;">
            <label style="display:flex; flex-direction:column; gap:6px; font-size:12px;">
              <span>APIæä¾›å•†</span>
              <select id="apiProvider" onchange="onProviderChange()"
                style="padding:8px; border:1px solid #ddd; border-radius:8px; width:100%;">
                <option value="openrouter">OpenRouter</option>
                <option value="anthropic">Anthropic Claude</option>
                <option value="openai">OpenAI</option>
                <option value="custom">è‡ªå®šä¹‰API</option>
              </select>
            </label>
          </div>

          <!-- APIå¯†é’¥è¾“å…¥åŒºåŸŸ -->
          <div id="apiKeySection" style="margin-bottom:16px;">
            <label style="display:flex; flex-direction:column; gap:6px; font-size:12px;">
              <span>APIå¯†é’¥</span>
              <div style="display:flex; gap:8px;">
                <input id="apiKey" type="password" placeholder="è¯·è¾“å…¥APIå¯†é’¥"
                  style="flex:1; padding:8px; border:1px solid #ddd; border-radius:8px;" />
                <button id="toggleApiKey" onclick="toggleApiKeyVisibility()"
                  style="padding:8px; border:1px solid #ddd; background:#f8fafc; border-radius:8px; cursor:pointer;">ğŸ‘ï¸</button>
              </div>
              <div id="apiKeyHint" style="font-size:11px; color:#64748b; margin-top:4px;"></div>
            </label>
          </div>

          <!-- è‡ªå®šä¹‰APIé…ç½® -->
          <div id="customApiSection" style="display:none; margin-bottom:16px;">
            <label style="display:flex; flex-direction:column; gap:6px; font-size:12px;">
              <span>APIç«¯ç‚¹URL</span>
              <input id="customApiUrl" type="url" placeholder="https://api.example.com/v1"
                style="padding:8px; border:1px solid #ddd; border-radius:8px;" />
            </label>
          </div>

          <!-- APIçŠ¶æ€æ˜¾ç¤º -->
          <div id="apiStatusSection"
            style="margin-bottom:16px; padding:12px; background:#f8fafc; border-radius:8px; border:1px solid #e2e8f0;">
            <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:8px;">
              <span style="font-size:12px; font-weight:600;">APIçŠ¶æ€</span>
              <button onclick="testApiConnection()"
                style="padding:4px 8px; border:1px solid #3b82f6; background:#3b82f6; color:#fff; border-radius:6px; font-size:11px; cursor:pointer;">æµ‹è¯•è¿æ¥</button>
            </div>
            <div id="apiStatusDisplay" style="font-size:11px; color:#64748b;">
              æœªé…ç½®APIå¯†é’¥
            </div>
          </div>

          <!-- æ¨¡å‹çŠ¶æ€æ˜¾ç¤º -->
          <div id="modelStatusSection"
            style="margin-bottom:16px; padding:12px; background:#f8fafc; border-radius:8px; border:1px solid #e2e8f0;">
            <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:8px;">
              <span style="font-size:12px; font-weight:600;">å¯ç”¨æ¨¡å‹</span>
              <button onclick="testAvailableModels()"
                style="padding:4px 8px; border:1px solid #10b981; background:#10b981; color:#fff; border-radius:6px; font-size:11px; cursor:pointer;">æ£€æµ‹æ¨¡å‹</button>
            </div>
            <div id="modelStatusDisplay" style="font-size:11px; color:#64748b;">
              ç‚¹å‡»"æ£€æµ‹æ¨¡å‹"æŸ¥çœ‹å¯ç”¨æ¨¡å‹
            </div>
          </div>

          <!-- å¿«é€Ÿé…ç½®æ¨¡æ¿ -->
          <div style="margin-bottom:16px;">
            <div style="font-size:12px; font-weight:600; margin-bottom:8px;">å¿«é€Ÿé…ç½®</div>
            <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px;">
              <button onclick="applyApiTemplate('openrouter')"
                style="padding:8px; border:1px solid #ddd; background:#f8fafc; border-radius:6px; font-size:11px; cursor:pointer; text-align:left;">
                <div style="font-weight:600;">OpenRouter</div>
                <div style="color:#64748b; font-size:10px;">å¤šæ¨¡å‹èšåˆå¹³å°</div>
              </button>
              <button onclick="applyApiTemplate('anthropic')"
                style="padding:8px; border:1px solid #ddd; background:#f8fafc; border-radius:6px; font-size:11px; cursor:pointer; text-align:left;">
                <div style="font-weight:600;">Anthropic</div>
                <div style="color:#64748b; font-size:10px;">Claudeå®˜æ–¹API</div>
              </button>
            </div>
          </div>
        </div>

        <div style="padding:12px 16px; border-top:1px solid #eee; display:flex; gap:8px; justify-content:flex-end;">
          <button onclick="closeConfigPanel()"
            style="padding:8px 12px; border:1px solid #ddd; background:#fff; border-radius:8px;">å–æ¶ˆ</button>
          <button onclick="saveConfigChanges()"
            style="padding:8px 12px; border:0; background:#3b82f6; color:#fff; border-radius:8px;">ä¿å­˜</button>
        </div>
      </div>
    </div>

    <!-- å¿«é€ŸAPIè®¾ç½®å¼¹çª— -->
    <div id="quickApiModal"
      style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.45); z-index:1001; align-items:center; justify-content:center;">
      <div
        style="background:#fff; width:480px; max-width:90%; border-radius:12px; box-shadow:0 10px 30px rgba(0,0,0,0.2); overflow:hidden;">
        <div style="padding:16px; border-bottom:1px solid #eee; font-weight:600; text-align:center;">
          ğŸ”‘ å¿«é€Ÿè®¾ç½®APIå¯†é’¥
        </div>
        <div style="padding:20px;">
          <div style="margin-bottom:16px; text-align:center;">
            <div style="font-size:14px; margin-bottom:8px; color:#1e293b;">é€‰æ‹©æ‚¨çš„APIæä¾›å•†</div>
            <div style="font-size:12px; color:#64748b; line-height:1.4;">
              é…ç½®APIå¯†é’¥å³å¯å¼€å§‹ä½¿ç”¨AIé¢„æµ‹åŠŸèƒ½
            </div>
          </div>

          <div style="display:grid; grid-template-columns:1fr 1fr; gap:12px; margin-bottom:20px;">
            <button onclick="selectApiProvider('openrouter')"
              style="padding:12px; border:2px solid #e2e8f0; background:#f8fafc; border-radius:8px; cursor:pointer; transition:all 0.2s;">
              <div style="font-weight:600; margin-bottom:4px;">ğŸŒ OpenRouter</div>
              <div style="font-size:11px; color:#64748b; line-height:1.3;">å¤šæ¨¡å‹èšåˆå¹³å°<br />æ”¯æŒå¤šç§å…è´¹æ¨¡å‹</div>
            </button>
            <button onclick="selectApiProvider('anthropic')"
              style="padding:12px; border:2px solid #e2e8f0; background:#f8fafc; border-radius:8px; cursor:pointer; transition:all 0.2s;">
              <div style="font-weight:600; margin-bottom:4px;">ğŸ§  Anthropic</div>
              <div style="font-size:11px; color:#64748b; line-height:1.3;">Claudeå®˜æ–¹API<br />é«˜è´¨é‡AIå¯¹è¯</div>
            </button>
          </div>

          <div id="quickApiKeySection" style="display:none; margin-bottom:16px;">
            <label style="display:flex; flex-direction:column; gap:6px; font-size:12px;">
              <span>APIå¯†é’¥</span>
              <input id="quickApiKey" type="password" placeholder="è¯·è¾“å…¥æ‚¨çš„APIå¯†é’¥"
                style="padding:10px; border:1px solid #ddd; border-radius:8px; font-size:12px;" />
              <div id="quickApiHint" style="font-size:11px; color:#64748b;"></div>
            </label>
          </div>

          <div id="quickApiActions" style="display:flex; gap:8px; justify-content:flex-end;">
            <button onclick="closeQuickApiSetup()"
              style="padding:8px 16px; border:1px solid #ddd; background:#fff; border-radius:8px;">å–æ¶ˆ</button>
            <button id="quickApiTestBtn" onclick="testQuickApiKey()"
              style="display:none; padding:8px 16px; border:1px solid #f59e0b; background:#f59e0b; color:#fff; border-radius:8px;">æµ‹è¯•è¿æ¥</button>
            <button id="quickApiSaveBtn" onclick="saveQuickApiKey()"
              style="display:none; padding:8px 16px; border:0; background:#10b981; color:#fff; border-radius:8px;">ä¿å­˜å¹¶å¯ç”¨</button>
          </div>
        </div>
      </div>
    </div>

    <!-- åœ¨çº¿åˆ—è¡¨ -->
    <div class="card">
      <div class="row" style="justify-content:space-between;">
        <div class="name">å½“å‰åœ¨çº¿</div>
        <div class="muted">1 åˆ†é’Ÿå†…æ´»è·ƒè§†ä¸ºåœ¨çº¿</div>
      </div>
      <div id="presence" class="presence" style="margin-top:8px;"></div>
    </div>

    <!-- å¼€å¥–èµ„è®¯æ¨¡å— -->
    <div class="card">
      <h3>ğŸ§§ å¼€å¥–èµ„è®¯</h3>
      <label for="gameSelect">é€‰æ‹©æ¸¸æˆï¼š</label>
      <select id="gameSelect">
        <option value="1">é¦™æ¸¯</option>
        <option value="4">æ–°æ¾³é—¨</option>
      </select>
      <div id="lotteryInfo">è½½å…¥ä¸­...</div>
      <div id="countdown" class="countdown"></div>

      <!-- AIé¢„æµ‹åŠŸèƒ½ -->
      <div class="ai-prediction-section">
        <h4>ğŸ¤– AIæ™ºèƒ½é¢„æµ‹</h4>
        <p class="prediction-disclaimer">âš ï¸ ä»…ä¾›å¨±ä¹å‚è€ƒï¼Œä¸æ„æˆæŠ•æ³¨å»ºè®®</p>

        <!-- é¢„æµ‹å½©ç§é€‰æ‹© -->
        <div class="prediction-type-selector">
          <label>é€‰æ‹©é¢„æµ‹å½©ç§ï¼š</label>
          <div class="prediction-tabs">
            <button id="hkPredictTab" class="prediction-tab active" data-type="hk">ğŸ‡­ğŸ‡° é¦™æ¸¯æ•°å­—é¢„æµ‹</button>
            <button id="macauPredictTab" class="prediction-tab" data-type="macau">ğŸ‡²ğŸ‡´ æ¾³é—¨æ•°å­—é¢„æµ‹</button>
          </div>
        </div>

        <!-- é¦™æ¸¯æ•°å­—é¢„æµ‹ -->
        <div id="hkPrediction" class="prediction-panel active">
          <div class="prediction-info">
            <div class="current-period">å½“å‰é¢„æµ‹æœŸå·: <span id="hkCurrentPeriod">-</span></div>
            <div class="prediction-strategy">
              <div>å½“å‰ç­–ç•¥: <span id="hkCurrentStrategy" style="font-weight: bold; color: #2196F3;">AIæ™ºèƒ½åˆ†æ</span></div>
              <div class="strategy-details" id="hkStrategyDetails"
                style="font-size: 12px; color: #666; margin-top: 4px;">
                <span id="hkStrategyComposition">ç»Ÿè®¡åˆ†æ + æœºå™¨å­¦ä¹  + é›†æˆé¢„æµ‹</span>
              </div>
            </div>
            <div class="accuracy-rate">
              å†å²å‡†ç¡®ç‡: <span id="hkAccuracyRate" style="font-weight: bold;">-</span>
              <span class="accuracy-trend" id="hkAccuracyTrend" style="margin-left: 8px; font-size: 12px;"></span>
            </div>
            <div class="strategy-performance" id="hkStrategyPerformance"
              style="margin-top: 8px; padding: 8px; background: #f5f5f5; border-radius: 4px; font-size: 12px;">
              <div style="display: flex; justify-content: space-between; align-items: center;">
                <span>æ€»é¢„æµ‹: <span id="hkTotalPredictions">0</span> æ¬¡</span>
                <span>æˆåŠŸ: <span id="hkCorrectPredictions">0</span> æ¬¡</span>
                <span id="hkPerformanceStatus"
                  style="padding: 2px 8px; border-radius: 12px; background: #4CAF50; color: white;">æ­£å¸¸</span>
              </div>
            </div>
          </div>
          <div class="auto-prediction-status" id="hkAutoPredictionStatus">â° ç­‰å¾…è‡ªåŠ¨é¢„æµ‹...</div>
          <button id="hkManualPredictBtn" class="manual-predict-btn" style="margin-top: 10px;">ğŸ”® æ‰‹åŠ¨é¢„æµ‹é¦™æ¸¯</button>
          <div id="hkPredictionResult" class="prediction-result" style="display: none;"></div>
          <div id="hkPredictionLoading" class="prediction-loading" style="display: none;">
            <div class="loading-spinner"></div>
            <div class="ai-analysis-steps" id="hkAnalysisSteps">
              <h6>ğŸ¤– AIé¢„æµ‹åˆ†æè¿‡ç¨‹:</h6>
              <div class="analysis-step" id="hkStep1">â³ å‡†å¤‡å¼€å§‹æ™ºèƒ½åˆ†æ...</div>
              <div class="analysis-step" id="hkStep2" style="opacity: 0.3;">ğŸ“Š æ•°æ®é¢„å¤„ç†ä¸­...</div>
              <div class="analysis-step" id="hkStep3" style="opacity: 0.3;">ğŸ” ç»Ÿè®¡åˆ†æä¸­...</div>
              <div class="analysis-step" id="hkStep4" style="opacity: 0.3;">ğŸ§  æœºå™¨å­¦ä¹ é¢„æµ‹ä¸­...</div>
              <div class="analysis-step" id="hkStep5" style="opacity: 0.3;">ğŸ¯ ä¼˜åŒ–å·ç ç»„åˆ...</div>
              <div class="analysis-step" id="hkStep6" style="opacity: 0.3;">âœ… ç”Ÿæˆæœ€ç»ˆé¢„æµ‹...</div>
            </div>
          </div>
          <div class="prediction-history">
            <h5>ğŸ“Š é¢„æµ‹å†å²è®°å½•</h5>
            <div class="performance-trend" id="hkPerformanceTrend"
              style="margin-bottom: 12px; padding: 8px; background: #f8f9fa; border-radius: 4px; font-size: 12px;">
              <div style="display: flex; justify-content: space-between; align-items: center;">
                <span>æœ€è¿‘10æœŸå‡†ç¡®ç‡è¶‹åŠ¿:</span>
                <span id="hkTrendIndicator" style="font-weight: bold;">-</span>
              </div>
              <div class="mini-chart" id="hkMiniChart"
                style="height: 20px; margin-top: 4px; display: flex; align-items: flex-end; gap: 2px;"></div>
            </div>
            <div id="hkPredictionHistory" class="history-list"></div>
            <div class="auto-verification-info">
              <h6>ğŸ¤– è‡ªåŠ¨å¼€å¥–éªŒè¯</h6>
              <p style="color: #666; font-size: 12px; margin: 8px 0;">
                ç³»ç»Ÿä¼šè‡ªåŠ¨è·å–å®˜æ–¹å¼€å¥–ç»“æœè¿›è¡ŒéªŒè¯ï¼Œæ— éœ€æ‰‹åŠ¨è¾“å…¥
              </p>
              <div id="hkAutoVerificationStatus" class="verification-status">
                ç­‰å¾…è‡ªåŠ¨éªŒè¯...
              </div>
            </div>
          </div>
        </div>

        <!-- æ¾³é—¨æ•°å­—é¢„æµ‹ -->
        <div id="macauPrediction" class="prediction-panel" style="display: none;">
          <div class="prediction-info">
            <div class="current-period">å½“å‰é¢„æµ‹æœŸå·: <span id="macauCurrentPeriod">-</span></div>
            <div class="prediction-strategy">
              <div>å½“å‰ç­–ç•¥: <span id="macauCurrentStrategy" style="font-weight: bold; color: #2196F3;">AIæ™ºèƒ½åˆ†æ</span></div>
              <div class="strategy-details" id="macauStrategyDetails"
                style="font-size: 12px; color: #666; margin-top: 4px;">
                <span id="macauStrategyComposition">ç»Ÿè®¡åˆ†æ + æœºå™¨å­¦ä¹  + é›†æˆé¢„æµ‹</span>
              </div>
            </div>
            <div class="accuracy-rate">
              å†å²å‡†ç¡®ç‡: <span id="macauAccuracyRate" style="font-weight: bold;">-</span>
              <span class="accuracy-trend" id="macauAccuracyTrend" style="margin-left: 8px; font-size: 12px;"></span>
            </div>
            <div class="strategy-performance" id="macauStrategyPerformance"
              style="margin-top: 8px; padding: 8px; background: #f5f5f5; border-radius: 4px; font-size: 12px;">
              <div style="display: flex; justify-content: space-between; align-items: center;">
                <span>æ€»é¢„æµ‹: <span id="macauTotalPredictions">0</span> æ¬¡</span>
                <span>æˆåŠŸ: <span id="macauCorrectPredictions">0</span> æ¬¡</span>
                <span id="macauPerformanceStatus"
                  style="padding: 2px 8px; border-radius: 12px; background: #4CAF50; color: white;">æ­£å¸¸</span>
              </div>
            </div>
          </div>
          <div class="auto-prediction-status" id="macauAutoPredictionStatus">â° ç­‰å¾…è‡ªåŠ¨é¢„æµ‹...</div>
          <button id="macauManualPredictBtn" class="manual-predict-btn" style="margin-top: 10px;">ğŸ”® æ‰‹åŠ¨é¢„æµ‹æ¾³é—¨</button>
          <div id="macauPredictionResult" class="prediction-result" style="display: none;"></div>
          <div id="macauPredictionLoading" class="prediction-loading" style="display: none;">
            <div class="loading-spinner"></div>
            <div class="ai-analysis-steps" id="macauAnalysisSteps">
              <h6>ğŸ¤– AIé¢„æµ‹åˆ†æè¿‡ç¨‹:</h6>
              <div class="analysis-step" id="macauStep1">â³ å‡†å¤‡å¼€å§‹æ™ºèƒ½åˆ†æ...</div>
              <div class="analysis-step" id="macauStep2" style="opacity: 0.3;">ğŸ“Š æ•°æ®é¢„å¤„ç†ä¸­...</div>
              <div class="analysis-step" id="macauStep3" style="opacity: 0.3;">ğŸ” ç»Ÿè®¡åˆ†æä¸­...</div>
              <div class="analysis-step" id="macauStep4" style="opacity: 0.3;">ğŸ§  æœºå™¨å­¦ä¹ é¢„æµ‹ä¸­...</div>
              <div class="analysis-step" id="macauStep5" style="opacity: 0.3;">ğŸ¯ ä¼˜åŒ–å·ç ç»„åˆ...</div>
              <div class="analysis-step" id="macauStep6" style="opacity: 0.3;">âœ… ç”Ÿæˆæœ€ç»ˆé¢„æµ‹...</div>
            </div>
          </div>
          <div class="prediction-history">
            <h5>ğŸ“Š é¢„æµ‹å†å²è®°å½•</h5>
            <div class="performance-trend" id="macauPerformanceTrend"
              style="margin-bottom: 12px; padding: 8px; background: #f8f9fa; border-radius: 4px; font-size: 12px;">
              <div style="display: flex; justify-content: space-between; align-items: center;">
                <span>æœ€è¿‘10æœŸå‡†ç¡®ç‡è¶‹åŠ¿:</span>
                <span id="macauTrendIndicator" style="font-weight: bold;">-</span>
              </div>
              <div class="mini-chart" id="macauMiniChart"
                style="height: 20px; margin-top: 4px; display: flex; align-items: flex-end; gap: 2px;"></div>
            </div>
            <div id="macauPredictionHistory" class="history-list"></div>
            <div class="auto-verification-info">
              <h6>ğŸ¤– è‡ªåŠ¨å¼€å¥–éªŒè¯</h6>
              <p style="color: #666; font-size: 12px; margin: 8px 0;">
                ç³»ç»Ÿä¼šè‡ªåŠ¨è·å–å®˜æ–¹å¼€å¥–ç»“æœè¿›è¡ŒéªŒè¯ï¼Œæ— éœ€æ‰‹åŠ¨è¾“å…¥
              </p>
              <div id="macauAutoVerificationStatus" class="verification-status">
                ç­‰å¾…è‡ªåŠ¨éªŒè¯...
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- ç•™è¨€è¾“å…¥ -->
    <div class="card">
      <form id="form" class="composer" autocomplete="off">
        <textarea id="text" placeholder="å†™ä¸‹ä½ æƒ³è¯´çš„è¯ï¼ˆä¸é™åˆ¶å­—æ•°ï¼‰"></textarea>
        <button id="send" type="submit">å‘é€</button>
      </form>
    </div>

    <!-- ç•™è¨€åˆ—è¡¨ -->
    <ul id="list"></ul>
  </div>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>
  <script>
    // â€”â€” ç”¨æˆ· & å¯†ç æ˜ å°„ â€”â€”
    const USERS = {
      horse: { id: 'horse', name: 'é©¬', avatar: 'ğŸ' },
      sheep: { id: 'sheep', name: 'ç¾Š', avatar: 'ğŸ‘' },
      mouse: { id: 'mouse', name: 'è€é¼ ', avatar: 'ğŸ­' },
      rabbit: { id: 'rabbit', name: 'å…”å­', avatar: 'ğŸ‡' },
      monkey: { id: 'monkey', name: 'çŒ´å­', avatar: 'ğŸ’' },
      snake: { id: 'snake', name: 'è›‡', avatar: 'ğŸ' }
    };
    const PASSWORDS = {
      'ma123': 'horse',
      'yang123': 'sheep',
      'shu123': 'mouse',
      'tu123': 'rabbit',
      'hou123': 'monkey',
      'she123': 'snake'
    };

    // Toast ç»„ä»¶
    function showToast(msg, type = 'success', duration = 2000) {
      const t = document.createElement('div');
      t.className = `toast ${type}`;
      t.textContent = msg;
      document.body.appendChild(t);
      requestAnimationFrame(() => t.classList.add('show'));
      setTimeout(() => {
        t.classList.remove('show');
        setTimeout(() => t.remove(), 300);
      }, duration);
    }

    // è‡ªé€‚åº”æ–‡æœ¬åŸŸé«˜åº¦
    function autoResizeTextarea(el) {
      if (!el) return;
      const resize = () => { el.style.height = 'auto'; el.style.height = Math.min(el.scrollHeight, 200) + 'px'; };
      el.addEventListener('input', resize);
      resize();
    }

    // â€”â€” Firebase é…ç½® â€”â€”
    const firebaseConfig = {
      apiKey: "AIzaSyDTsjNPdZntfabyVn0q-9y39l9a1ur_cEw",
      authDomain: "jiatingliuyanban-635f9.firebaseapp.com",
      databaseURL: "https://jiatingliuyanban-635f9-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "jiatingliuyanban-635f9",
      storageBucket: "jiatingliuyanban-635f9.appspot.com",
      messagingSenderId: "196518556157",
      appId: "1:196518556157:web:f710ec71f8acb4eb79a994"
    };

    // â€”â€” å¸¸é‡ â€”â€”
    const EXP_MS = 48 * 3600 * 1000;       // ç•™è¨€è¿‡æœŸ 48h
    const ONLINE_WINDOW = 60 * 1000;      // åœ¨çº¿åˆ¤å®š 1min
    const COUNTDOWN_INTERVAL = 60000;     // ç•™è¨€å€’è®¡æ—¶åˆ·æ–° 1min

    // â€”â€” å¼€å¥–APIé…ç½® â€”â€”
    const LOTTERY_APIS = [
      {
        name: 'é¦™æ¸¯API',
        url: (gameid) => `https://api.166001.com/lottery/get/${gameid}`,
        parser: (json) => json.data
      },
      {
        name: 'æ–°æ¾³é—¨API',
        url: (gameid) => `https://history.macaumarksix.com/history/macaujc2/y/${new Date().getFullYear()}`,
        parser: (json) => {
          if (!json || json.result !== true || json.code !== 200 || !json.data || !Array.isArray(json.data) || json.data.length === 0) return null;

          // è·å–æœ€æ–°ä¸€æ¡æ•°æ®ï¼ˆæ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼‰
          const data = json.data[0];

          // è§£æå¼€å¥–å·ç ï¼ˆ7ä¸ªå·ç ï¼š6ä¸ªæ­£é€‰+1ä¸ªç‰¹ç ï¼‰
          const numbers = data.openCode.split(',').map(n => parseInt(n.trim()));
          const mainNumbers = numbers.slice(0, 6); // å‰6ä¸ªæ˜¯æ­£é€‰å·ç 

          return {
            currentIssue: data.expect,
            currentResult: mainNumbers.join(','),
            currentZodiac: data.zodiac,
            nextIssue: '',
            nextTime: data.openTime,
            resultsOfLastThreeIssues: [],
            specialNumber: numbers[numbers.length - 1], // ç‰¹ç 
            waveColors: data.wave, // æ³¢è‰²ä¿¡æ¯
            zodiacAnimals: data.zodiac // ç”Ÿè‚–ä¿¡æ¯
          };
        }
      },
      {
        name: 'é¦™æ¸¯å†å²æ•°æ®',
        url: (gameid) => `https://r.jina.ai/http://marksixlottery.net/history`,
        parser: (html) => {
          try {
            const text = typeof html === 'string' ? html : '';

            // æ–°çš„è§£æé€»è¾‘ï¼šåŒ¹é…æœŸå·å’Œå¼€å¥–å·ç 
            // æ ¼å¼ï¼šæœŸ è™Ÿ ç¬¬2025081æœŸ é–‹çæ™‚é–“ 20250726 21:30:00 25 è›‡ 19 çŒª 45 é¸¡ 22 çŒ´ 32 ç‹— 33 é¸¡ 36 é©¬
            const drawPattern = /æœŸ\s*è™Ÿ\s*ç¬¬(\d{7})æœŸ\s*é–‹çæ™‚é–“\s*(\d{8})\s*(\d{1,2})\s*\S*\s*(\d{1,2})\s*\S*\s*(\d{1,2})\s*\S*\s*(\d{1,2})\s*\S*\s*(\d{1,2})\s*\S*\s*(\d{1,2})\s*\S*\s*(\d{1,2})\s*\S*/g;

            const matches = [...text.matchAll(drawPattern)];
            if (matches.length > 0) {
              // è·å–æœ€æ–°ä¸€æœŸï¼ˆç¬¬ä¸€ä¸ªåŒ¹é…ï¼‰
              const latestMatch = matches[0];
              const issue = latestMatch[1];
              const drawTime = latestMatch[2];
              const numbers = latestMatch.slice(3, 9).map(n => parseInt(n));

              if (numbers.length === 6 && numbers.every(n => n >= 1 && n <= 49)) {
                return {
                  currentIssue: issue,
                  currentResult: numbers.join(','),
                  currentZodiac: '', // å¯ä»¥ä»åç»­æ–‡æœ¬ä¸­è§£æç”Ÿè‚–
                  nextIssue: '',
                  nextTime: drawTime,
                  resultsOfLastThreeIssues: []
                };
              }
            }

            // å¤‡ç”¨è§£æï¼šå°è¯•åŒ¹é…å…¶ä»–å¯èƒ½çš„æ ¼å¼
            const altPattern = /ç¬¬(\d{7})æœŸ[\s\S]*?(\d{1,2})\s*\S*\s*(\d{1,2})\s*\S*\s*(\d{1,2})\s*\S*\s*(\d{1,2})\s*\S*\s*(\d{1,2})\s*\S*\s*(\d{1,2})/g;
            const altMatches = [...text.matchAll(altPattern)];

            if (altMatches.length > 0) {
              const latestMatch = altMatches[0];
              const issue = latestMatch[1];
              const numbers = latestMatch.slice(2, 8).map(n => parseInt(n));

              if (numbers.length === 6 && numbers.every(n => n >= 1 && n <= 49)) {
                return {
                  currentIssue: issue,
                  currentResult: numbers.join(','),
                  currentZodiac: '',
                  nextIssue: '',
                  nextTime: '',
                  resultsOfLastThreeIssues: []
                };
              }
            }

            // æ›´ç®€å•çš„å¤‡ç”¨è§£æï¼šæŸ¥æ‰¾æœŸå·å’Œ6ä¸ªæ•°å­—
            const simplePattern = /ç¬¬(\d{7})æœŸ[\s\S]*?(\d{1,2})[\s\S]*?(\d{1,2})[\s\S]*?(\d{1,2})[\s\S]*?(\d{1,2})[\s\S]*?(\d{1,2})[\s\S]*?(\d{1,2})/;
            const simpleMatch = text.match(simplePattern);

            if (simpleMatch) {
              const issue = simpleMatch[1];
              const numbers = simpleMatch.slice(2, 8).map(n => parseInt(n));

              if (numbers.length === 6 && numbers.every(n => n >= 1 && n <= 49)) {
                return {
                  currentIssue: issue,
                  currentResult: numbers.join(','),
                  currentZodiac: '',
                  nextIssue: '',
                  nextTime: '',
                  resultsOfLastThreeIssues: []
                };
              }
            }
          } catch (e) {
            console.warn('é¦™æ¸¯å†å²æ•°æ®è§£æå¤±è´¥:', e);
          }
          return null;
        }
      },
      {
        name: 'æ¾³é—¨å†å²æ•°æ®',
        url: (gameid) => `https://r.jina.ai/http://macaujc.me/post`,
        parser: (html) => {
          try {
            const text = typeof html === 'string' ? html : '';

            // ä¸»è¦è§£æï¼šåŒ¹é…æ¾³é—¨å¼€å¥–æ•°æ®ï¼Œå¤„ç†æ¢è¡Œç¬¦
            // æ ¼å¼ï¼šæ¾³é–€å…­åˆå½©ç¬¬ 2025316 æœŸé–‹çè™Ÿç¢¼\n20\n29\n40\n42\n17\n25\n24
            const drawPattern = /æ¾³é–€å…­åˆå½©ç¬¬\s*(\d{7})\s*æœŸé–‹çè™Ÿç¢¼\s*(\d{1,2})\s*(\d{1,2})\s*(\d{1,2})\s*(\d{1,2})\s*(\d{1,2})\s*(\d{1,2})/gs;

            const matches = [...text.matchAll(drawPattern)];
            if (matches.length > 0) {
              // è·å–æœ€æ–°ä¸€æœŸï¼ˆç¬¬ä¸€ä¸ªåŒ¹é…ï¼‰
              const latestMatch = matches[0];
              const issue = latestMatch[1];
              const numbers = latestMatch.slice(2, 8).map(n => parseInt(n));

              if (numbers.length === 6 && numbers.every(n => n >= 1 && n <= 49)) {
                return {
                  currentIssue: issue,
                  currentResult: numbers.join(','),
                  currentZodiac: '', // å¯ä»¥ä»åç»­æ–‡æœ¬ä¸­è§£æç”Ÿè‚–
                  nextIssue: '',
                  nextTime: '',
                  resultsOfLastThreeIssues: []
                };
              }
            }

            // å¤‡ç”¨è§£æ1ï¼šåŒ¹é…è¡¨æ ¼ä¸­çš„æ•°æ®ï¼Œå¤„ç†æ¢è¡Œå’Œç”Ÿè‚–äº¤æ›¿
            // æ ¼å¼ï¼šç¬¬ 2025316 æœŸ\n2025-11-12 21:32:00\n20\nç‹—\n29\nç‰›\n40\nè™\n42\né¼ \n17\nç‰›\n25\nè›‡\n24\né¦¬
            const tablePattern = /ç¬¬\s*(\d{7})\s*æœŸ[\s\S]*?(\d{1,2})\s*\S*\s*(\d{1,2})\s*\S*\s*(\d{1,2})\s*\S*\s*(\d{1,2})\s*\S*\s*(\d{1,2})\s*\S*\s*(\d{1,2})/gs;
            const tableMatches = [...text.matchAll(tablePattern)];

            if (tableMatches.length > 0) {
              const latestMatch = tableMatches[0];
              const issue = latestMatch[1];
              const numbers = latestMatch.slice(2, 8).map(n => parseInt(n));

              if (numbers.length === 6 && numbers.every(n => n >= 1 && n <= 49)) {
                return {
                  currentIssue: issue,
                  currentResult: numbers.join(','),
                  currentZodiac: '',
                  nextIssue: '',
                  nextTime: '',
                  resultsOfLastThreeIssues: []
                };
              }
            }

            // å¤‡ç”¨è§£æ2ï¼šæ›´çµæ´»çš„åŒ¹é…ï¼Œå¤„ç†å„ç§æ¢è¡Œæƒ…å†µ
            // æŸ¥æ‰¾"æ¾³é–€å…­åˆå½©ç¬¬"åé¢çš„æœŸå·ï¼Œç„¶åè·Ÿéšçš„6ä¸ªæ•°å­—
            const flexiblePattern = /æ¾³é–€å…­åˆå½©ç¬¬\s*(\d{7})\s*æœŸé–‹çè™Ÿç¢¼[\s\S]*?(\d{1,2})[\s\S]*?(\d{1,2})[\s\S]*?(\d{1,2})[\s\S]*?(\d{1,2})[\s\S]*?(\d{1,2})[\s\S]*?(\d{1,2})/;
            const flexibleMatch = text.match(flexiblePattern);

            if (flexibleMatch) {
              const issue = flexibleMatch[1];
              const numbers = flexibleMatch.slice(2, 8).map(n => parseInt(n));

              if (numbers.length === 6 && numbers.every(n => n >= 1 && n <= 49)) {
                return {
                  currentIssue: issue,
                  currentResult: numbers.join(','),
                  currentZodiac: '',
                  nextIssue: '',
                  nextTime: '',
                  resultsOfLastThreeIssues: []
                };
              }
            }

            // å¤‡ç”¨è§£æ3ï¼šæŸ¥æ‰¾æœŸå·åçš„è¿ç»­6ä¸ªæ•°å­—ï¼ˆå¯èƒ½åŒ…å«ç”Ÿè‚–ï¼‰
            const issuePattern = /(\d{7})[\s\S]*?(\d{1,2})[\s\S]*?(\d{1,2})[\s\S]*?(\d{1,2})[\s\S]*?(\d{1,2})[\s\S]*?(\d{1,2})[\s\S]*?(\d{1,2})/;
            const issueMatch = text.match(issuePattern);

            if (issueMatch) {
              const issue = issueMatch[1];
              const numbers = issueMatch.slice(2, 8).map(n => parseInt(n));

              if (numbers.length === 6 && numbers.every(n => n >= 1 && n <= 49)) {
                return {
                  currentIssue: issue,
                  currentResult: numbers.join(','),
                  currentZodiac: '',
                  nextIssue: '',
                  nextTime: '',
                  resultsOfLastThreeIssues: []
                };
              }
            }
          } catch (e) {
            console.warn('æ¾³é—¨å†å²æ•°æ®è§£æå¤±è´¥:', e);
          }
          return null;
        }
      },
      {
        name: 'å¤‡ç”¨API1',
        url: (gameid) => `https://api.jisuapi.com/caipiao/query?appkey=demo&caipiaoid=${gameid}`,
        parser: (json) => {
          if (json.status !== 0) return null;
          const r = json.result;
          return {
            currentIssue: r.issueno,
            currentResult: r.number,
            currentZodiac: '',
            nextIssue: '',
            nextTime: '',
            resultsOfLastThreeIssues: []
          };
        }
      },
      {
        name: 'å¤‡ç”¨API2',
        url: (gameid) => `https://open.liupai.net/lottery/query?appkey=demo&cpid=${gameid}`,
        parser: (json) => {
          if (json.status !== '200') return null;
          const r = json.result;
          return {
            currentIssue: r.issueno,
            currentResult: r.number,
            currentZodiac: '',
            nextIssue: '',
            nextTime: '',
            resultsOfLastThreeIssues: []
          };
        }
      },
      // æ–°å¢ï¼šé¦™æ¸¯å¤šæœŸå†å²æ•°æ®API
      {
        name: 'é¦™æ¸¯å¤šæœŸå†å²',
        url: () => {
          const year = new Date().getFullYear();
          return `https://r.jina.ai/https://ttc5188.com/api/history/hongkong?year=${year}&page=1&pageSize=50`;
        },
        parser: (text) => {
          try {
            // å¤„ç†r.jina.aiè¿”å›çš„Markdownæ ¼å¼
            let jsonText = text;
            if (text.includes('Markdown Content:')) {
              // ä»Markdownä¸­æå–JSONéƒ¨åˆ†
              const jsonMatch = text.match(/Markdown Content:\s*(\{[\s\S]*\})/s);
              if (jsonMatch) {
                jsonText = jsonMatch[1];
              }
            }

            const data = typeof jsonText === 'string' ? JSON.parse(jsonText) : jsonText;
            const list = data && Array.isArray(data.data) ? data.data : [];
            const draws = [];
            for (const item of list) {
              const codes = typeof item.open_code === 'string'
                ? item.open_code.split(',').map(s => parseInt(s, 10)).filter(n => !isNaN(n))
                : [];
              const numbers = codes.slice(0, 7);
              if (numbers.length >= 6 && numbers.every(n => n >= 1 && n <= 49)) {
                const zodiacArr = typeof item.zodiac === 'string' ? item.zodiac.split(',') : [];
                draws.push({
                  period: String(item.expect || ''),
                  numbers: numbers,
                  zodiac: zodiacArr.slice(0, 7).join(','),
                  drawDate: item.open_time || '',
                  dataSource: 'é¦™æ¸¯å¤šæœŸå†å²(ttc5188)'
                });
              }
            }
            return draws.length > 0 ? draws : null;
          } catch (e) {
            console.error('ttc5188è§£æé”™è¯¯:', e);
            return null;
          }
        }
      },
      // æ–°å¢ï¼šé¦™æ¸¯å¤‡ç”¨å†å²æ•°æ®API
      {
        name: 'é¦™æ¸¯å¤‡ç”¨å†å²',
        url: (period) => `https://r.jina.ai/http://www.lottery.gov.cn/lottery/hk_history.asp?issue=${period}`,
        parser: (html) => {
          try {
            const text = typeof html === 'string' ? html : '';

            // å°è¯•åŒ¹é…é¦™æ¸¯å…­åˆå½©æ•°æ®æ ¼å¼
            const drawMatch = text.match(/(\d{4})\s+(\d{1,2})\s+(\d{1,2})\s+(\d{1,2})\s+(\d{1,2})\s+(\d{1,2})\s+(\d{1,2})/);

            if (drawMatch) {
              const period = drawMatch[1];
              const numbers = drawMatch.slice(2, 8).map(n => parseInt(n));

              if (numbers.length === 6 && numbers.every(n => n >= 1 && n <= 49)) {
                return {
                  period: period,
                  numbers: numbers,
                  zodiac: '',
                  drawDate: '',
                  dataSource: 'é¦™æ¸¯å¤‡ç”¨å†å²'
                };
              }
            }

            return null;
          } catch (e) {
            console.warn('é¦™æ¸¯å¤‡ç”¨å†å²æ•°æ®è§£æå¤±è´¥:', e);
            return null;
          }
        }
      },
      // æ–°å¢ï¼šæ¾³é—¨å¤šæœŸå†å²æ•°æ®API
      {
        name: 'æ¾³é—¨å¤šæœŸå†å²',
        url: () => `https://momarksix.org/api/lottery/history/omsix`,
        parser: (jsonText) => {
          try {
            // ç›´æ¥è§£æJSONæ•°æ®
            const data = typeof jsonText === 'string' ? JSON.parse(jsonText) : jsonText;

            if (data.code !== 200 || !data.data || !Array.isArray(data.data)) {
              console.warn('æ¾³é—¨å¤šæœŸå†å²APIè¿”å›æ— æ•ˆæ•°æ®æ ¼å¼');
              return null;
            }

            const draws = [];

            // è½¬æ¢æ•°æ®æ ¼å¼
            for (const item of data.data) {
              if (item.issue && item.num && Array.isArray(item.num) && item.num.length >= 6) {
                // æå–å‰6ä¸ªå·ç ä½œä¸ºå¼€å¥–å·ç 
                const numbers = item.num.slice(0, 6);

                // éªŒè¯å·ç èŒƒå›´
                if (numbers.every(n => n >= 1 && n <= 49)) {
                  const drawDate = item.kjTime ? new Date(item.kjTime * 1000).toLocaleDateString() : '';

                  draws.push({
                    period: item.issue.toString(),
                    numbers: numbers,
                    zodiac: item.zodiac ? item.zodiac.slice(0, 6).join(',') : '',
                    drawDate: drawDate,
                    dataSource: 'æ¾³é—¨å¤šæœŸå†å²'
                  });
                }
              }
            }

            console.log(`æ¾³é—¨å¤šæœŸå†å²APIæˆåŠŸè§£æ ${draws.length} æœŸæ•°æ®`);
            return draws.length > 0 ? draws : null;
          } catch (e) {
            console.warn('æ¾³é—¨å¤šæœŸå†å²æ•°æ®è§£æå¤±è´¥:', e);
            return null;
          }
        }
      }
    ];

    // â€”â€” ç”Ÿè‚– emoji æ˜ å°„ â€”â€”
    const zodiacEmoji = {
      // åäºŒç”Ÿè‚–å®Œæ•´æ˜ å°„ï¼ˆæ”¯æŒç¹ç®€ä½“åŠå¸¸è§å˜ä½“ï¼‰
      "é¼ ": "ğŸ­", "è€é¼ ": "ğŸ­", "å­é¼ ": "ğŸ­",
      "ç‰›": "ğŸ®", "ä¸‘ç‰›": "ğŸ®", "æ°´ç‰›": "ğŸ®", "é»„ç‰›": "ğŸ®",
      "è™": "ğŸ¯", "å¯…è™": "ğŸ¯", "è€è™": "ğŸ¯", "ç™½è™": "ğŸ¯",
      "å…”": "ğŸ°", "å¯å…”": "ğŸ°", "å…”å­": "ğŸ°", "ç‰å…”": "ğŸ°",
      "é¾™": "ğŸ²", "é¾": "ğŸ²", "è¾°é¾™": "ğŸ²", "è¾°é¾": "ğŸ²", "é’é¾™": "ğŸ²", "é’é¾": "ğŸ²",
      "è›‡": "ğŸ", "å·³è›‡": "ğŸ", "é•¿è›‡": "ğŸ", "é’è›‡": "ğŸ",
      "é©¬": "ğŸ´", "é¦¬": "ğŸ´", "åˆé©¬": "ğŸ´", "åˆé¦¬": "ğŸ´", "ç™½é©¬": "ğŸ´", "ç™½é¦¬": "ğŸ´",
      "ç¾Š": "ğŸ‘", "æœªç¾Š": "ğŸ‘", "å±±ç¾Š": "ğŸ‘", "ç»µç¾Š": "ğŸ‘",
      "çŒ´": "ğŸµ", "ç”³çŒ´": "ğŸµ", "çŒ´å­": "ğŸµ", "é‡‘çŒ´": "ğŸµ",
      "é¸¡": "ğŸ”", "é›": "ğŸ”", "é…‰é¸¡": "ğŸ”", "é…‰é›": "ğŸ”", "å…¬é¸¡": "ğŸ”", "å…¬é›": "ğŸ”",
      "ç‹—": "ğŸ¶", "æˆŒç‹—": "ğŸ¶", "å°ç‹—": "ğŸ¶", "é»„ç‹—": "ğŸ¶",
      "çŒª": "ğŸ·", "è±¬": "ğŸ·", "äº¥çŒª": "ğŸ·", "äº¥è±¬": "ğŸ·", "é‡çŒª": "ğŸ·", "é‡è±¬": "ğŸ·"
    };

    // â€”â€” 2025å¹´ç”Ÿè‚–å²æ•°å¯¹åº”å…³ç³» â€”â€”
    // 2025å¹´æ˜¯è›‡å¹´ï¼Œ1å²æ˜¯è›‡
    function getZodiacByAge(age) {
      const zodiacOrder = ['é¼ ', 'ç‰›', 'è™', 'å…”', 'é¾™', 'è›‡', 'é©¬', 'ç¾Š', 'çŒ´', 'é¸¡', 'ç‹—', 'çŒª'];
      // 2025å¹´1å²æ˜¯è›‡ï¼Œç´¢å¼•ä¸º5ï¼ˆè›‡åœ¨æ•°ç»„ä¸­çš„æ­£ç¡®ä½ç½®ï¼‰

      // æ­£ç¡®è®¡ç®—ï¼šå…ˆè®¡ç®—å¯¹åº”1-12å²ï¼Œç„¶åæ ¹æ®1å²=è›‡çš„åŸºå‡†è®¡ç®—
      let ageIn1To12 = (age - 1) % 12 + 1;
      let zodiacIndex = (5 - (ageIn1To12 - 1) + 12) % 12;

      return zodiacOrder[zodiacIndex];
    }

    function getAgeByZodiac(zodiac) {
      const zodiacOrder = ['é¼ ', 'ç‰›', 'è™', 'å…”', 'é¾™', 'è›‡', 'é©¬', 'ç¾Š', 'çŒ´', 'é¸¡', 'ç‹—', 'çŒª'];
      const baseIndex = 5; // 2025å¹´è›‡çš„ç´¢å¼•ï¼ˆè›‡åœ¨æ•°ç»„ä¸­çš„æ­£ç¡®ä½ç½®ï¼‰
      const targetIndex = zodiacOrder.indexOf(zodiac);
      if (targetIndex === -1) return -1;

      let age = (baseIndex - targetIndex + 12) % 12 + 1;
      // ä¹Ÿå¯ä»¥æ˜¯13å²ã€25å²ã€37å²ç­‰ï¼ˆç›¸å·®12å²çš„å€æ•°ï¼‰
      return age;
    }

    // è·å–å½“å‰å¹´ä»½çš„ç”Ÿè‚–å²æ•°æ˜ å°„
    function getCurrentYearZodiacAgeMapping() {
      const currentYear = new Date().getFullYear();
      // 2025å¹´ç”Ÿè‚–æ˜ å°„åŸºå‡†
      const year2025Zodiac = 'è›‡'; // 2025å¹´æ˜¯è›‡å¹´
      const zodiacOrder = ['é¼ ', 'ç‰›', 'è™', 'å…”', 'é¾™', 'è›‡', 'é©¬', 'ç¾Š', 'çŒ´', 'é¸¡', 'ç‹—', 'çŒª'];
      const baseIndex = zodiacOrder.indexOf(year2025Zodiac);

      const mapping = {};
      for (let age = 1; age <= 12; age++) {
        const ageIndex = (baseIndex - (age - 1) + 12) % 12;
        mapping[age] = zodiacOrder[ageIndex];
      }

      return mapping;
    }

    // éªŒè¯ç”Ÿè‚–å²æ•°è®¡ç®—æ˜¯å¦æ­£ç¡®
    function validateZodiacCalculation() {
      console.log('ğŸ§ª éªŒè¯2025å¹´ç”Ÿè‚–å²æ•°è®¡ç®—:');

      // éªŒè¯å‡ ä¸ªå…³é”®å¹´é¾„
      const testCases = [
        { age: 1, expected: 'è›‡' },
        { age: 2, expected: 'é¾™' },
        { age: 3, expected: 'å…”' },
        { age: 12, expected: 'é©¬' }
      ];

      let allCorrect = true;
      testCases.forEach(testCase => {
        const result = getZodiacByAge(testCase.age);
        const isCorrect = result === testCase.expected;
        console.log(`   ${testCase.age}å²: ${result} ${isCorrect ? 'âœ…' : 'âŒ (æœŸæœ›: ' + testCase.expected + ')'}`);
        if (!isCorrect) allCorrect = false;
      });

      // éªŒè¯åå‘è®¡ç®—
      const zodiacTestCases = ['è›‡', 'é¾™', 'å…”', 'é©¬'];
      console.log('\nğŸ”„ åå‘éªŒè¯ï¼ˆç”Ÿè‚–â†’å²æ•°ï¼‰:');
      zodiacTestCases.forEach(zodiac => {
        const age = getAgeByZodiac(zodiac);
        console.log(`   ${zodiac}: ${age}å²`);
      });

      console.log(`\n${allCorrect ? 'âœ…' : 'âŒ'} ç”Ÿè‚–è®¡ç®—éªŒè¯${allCorrect ? 'é€šè¿‡' : 'å¤±è´¥'}`);

      return allCorrect;
    }

    // AIåˆ†ææ­¥éª¤æ§åˆ¶å‡½æ•°
    function showAIAnalysisSteps(type) {
      const prefix = type === 'hk' ? 'hk' : 'macau';
      const steps = [
        { id: `${prefix}Step1`, text: 'â³ å‡†å¤‡å¼€å§‹æ™ºèƒ½åˆ†æ...', duration: 1000 },
        { id: `${prefix}Step2`, text: 'ğŸ“Š åŠ è½½å†å²æ•°æ®...', duration: 1500 },
        { id: `${prefix}Step3`, text: 'ğŸ” ç»Ÿè®¡é¢‘ç‡åˆ†æ...', duration: 1500 },
        { id: `${prefix}Step4`, text: 'ğŸ“ˆ è®¡ç®—æ¦‚ç‡æ¨¡å‹...', duration: 1500 },
        { id: `${prefix}Step5`, text: 'ğŸ§  æœºå™¨å­¦ä¹ é¢„æµ‹...', duration: 2000 },
        { id: `${prefix}Step6`, text: 'ğŸ¯ ä¼˜åŒ–å·ç ç»„åˆ...', duration: 1500 },
        { id: `${prefix}Step7`, text: 'âœ… ç”Ÿæˆæœ€ç»ˆé¢„æµ‹...', duration: 1000 }
      ];

      let currentStep = 0;
      let totalDelay = 0;

      // é‡ç½®æ‰€æœ‰æ­¥éª¤
      steps.forEach((step, index) => {
        const element = document.getElementById(step.id);
        if (element) {
          element.style.opacity = '0.3';
          element.className = 'analysis-step';
        }
      });

      // é€æ­¥æ˜¾ç¤ºåˆ†æè¿‡ç¨‹
      const interval = setInterval(() => {
        if (currentStep > 0 && currentStep <= steps.length) {
          const prevStep = steps[currentStep - 1];
          const prevElement = document.getElementById(prevStep.id);
          if (prevElement) {
            prevElement.style.opacity = '1';
            prevElement.className = 'analysis-step completed';
          }
        }

        if (currentStep < steps.length) {
          const currentStepData = steps[currentStep];
          const element = document.getElementById(currentStepData.id);
          if (element) {
            element.style.opacity = '1';
            element.className = 'analysis-step active';
            element.textContent = currentStepData.text;

            // åœ¨æ§åˆ¶å°è¾“å‡ºå½“å‰æ­¥éª¤
            console.log(`ğŸ¤– AIåˆ†ææ­¥éª¤ ${currentStep + 1}/${steps.length}: ${currentStepData.text}`);
          }
          currentStep++;
        } else {
          // å®Œæˆæ‰€æœ‰æ­¥éª¤
          clearInterval(interval);
          const lastStep = steps[steps.length - 1];
          const lastElement = document.getElementById(lastStep.id);
          if (lastElement) {
            lastElement.style.opacity = '1';
            lastElement.className = 'analysis-step completed';
          }
          console.log('âœ… AIåˆ†ææ­¥éª¤å®Œæˆ');
        }
      }, 1500); // æ¯1.5ç§’åˆ‡æ¢ä¸€ä¸ªæ­¥éª¤
    }

    // é‡ç½®åˆ†ææ­¥éª¤æ˜¾ç¤º
    function resetAIAnalysisSteps(type) {
      const prefix = type === 'hk' ? 'hk' : 'macau';
      for (let i = 1; i <= 7; i++) {
        const element = document.getElementById(`${prefix}Step${i}`);
        if (element) {
          element.style.opacity = '0.3';
          element.className = 'analysis-step';
          // æ¢å¤é»˜è®¤æ–‡æœ¬
          const defaultTexts = [
            'â³ å‡†å¤‡å¼€å§‹æ™ºèƒ½åˆ†æ...',
            'ğŸ“Š æ•°æ®é¢„å¤„ç†ä¸­...',
            'ğŸ” ç»Ÿè®¡åˆ†æä¸­...',
            'ğŸ§  æœºå™¨å­¦ä¹ é¢„æµ‹ä¸­...',
            'ğŸ¯ ä¼˜åŒ–å·ç ç»„åˆ...',
            'âœ… ç”Ÿæˆæœ€ç»ˆé¢„æµ‹...'
          ];
          if (i <= defaultTexts.length) {
            element.textContent = defaultTexts[i - 1];
          }
        }
      }
    }

    // â€”â€” DOM å¼•ç”¨ â€”â€”
    const loginView = document.getElementById('loginView');
    const mainView = document.getElementById('mainView');
    const pwdInput = document.getElementById('pwd');
    const loginBtn = document.getElementById('loginBtn');
    const loginErr = document.getElementById('loginErr');
    const meAvatar = document.getElementById('meAvatar');
    const meName = document.getElementById('meName');
    const logoutBtn = document.getElementById('logoutBtn');
    const form = document.getElementById('form');
    const textInput = document.getElementById('text');
    const sendBtn = document.getElementById('send');
    const listEl = document.getElementById('list');
    const presenceEl = document.getElementById('presence');
    const gameSelect = document.getElementById('gameSelect');
    const lotteryInfo = document.getElementById('lotteryInfo');
    const countdownEl = document.getElementById('countdown');
    const predictBtn = document.getElementById('predictBtn');
    const predictionResult = document.getElementById('predictionResult');
    const predictionLoading = document.getElementById('predictionLoading');

    // â€”â€” çŠ¶æ€å˜é‡ â€”â€”
    let currentUser = null;
    let db, messagesRef, statusRef, statusAllRef, connectedRef;
    let messageTimer = null;

    // â€”â€” è‡ªåŠ¨ç™»å½•æ£€æµ‹ â€”â€”
    const savedRole = sessionStorage.getItem('roleId');
    if (savedRole && USERS[savedRole]) {
      currentUser = USERS[savedRole];
      showMain();
    }

    // â€”â€” ç™»å½•äº‹ä»¶ â€”â€”
    loginBtn.addEventListener('click', () => {
      const pwd = (pwdInput.value || '').trim();
      const roleId = PASSWORDS[pwd];
      if (!roleId || !USERS[roleId]) {
        loginErr.textContent = 'å¯†ç é”™è¯¯ï¼Œè¯·é‡è¯•';
        showToast('å¯†ç é”™è¯¯', 'error');
        return;
      }
      currentUser = USERS[roleId];
      sessionStorage.setItem('roleId', currentUser.id);
      showMain();
      showToast('ç™»å½•æˆåŠŸ', 'success');
    });

    // æ”¯æŒå›è½¦é”®ç™»å½•
    pwdInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        loginBtn.click();
      }
    });

    // â€”â€” é€€å‡ºäº‹ä»¶ â€”â€”
    logoutBtn.addEventListener('click', () => {
      try { statusRef && statusRef.remove(); } catch (e) { }
      sessionStorage.removeItem('roleId');
      mainView.style.display = 'none';
      loginView.style.display = 'block';
      if (messageTimer) clearInterval(messageTimer);
      showToast('å·²é€€å‡ºç™»å½•', 'warning');
    });

    // â€”â€” æ˜¾ç¤ºä¸»ç•Œé¢ & åˆå§‹åŒ– Firebase & ç›‘å¬æ¶ˆæ¯ & åœ¨çº¿ & å¼€å¥– â€”â€” 
    function showMain() {
      loginView.style.display = 'none';
      mainView.style.display = 'block';
      meAvatar.textContent = currentUser.avatar;
      meName.textContent = currentUser.name;

      // UI åˆå§‹åŒ–
      autoResizeTextarea(textInput);

      if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
      db = firebase.database();
      messagesRef = db.ref('messages');
      statusRef = db.ref('status/' + currentUser.id);
      statusAllRef = db.ref('status');
      connectedRef = db.ref('.info/connected');

      // â€”â€” åœ¨çº¿çŠ¶æ€å¿ƒè·³ â€”â€”
      connectedRef.on('value', snap => {
        if (snap.val() === true) {
          statusRef.onDisconnect().remove();
          statusRef.set({
            uid: currentUser.id, name: currentUser.name,
            avatar: currentUser.avatar,
            lastSeen: firebase.database.ServerValue.TIMESTAMP
          });
        }
      });
      setInterval(() => {
        statusRef.update({ lastSeen: firebase.database.ServerValue.TIMESTAMP });
      }, 30000);

      // â€”â€” æ¸²æŸ“åœ¨çº¿ç”¨æˆ· â€”â€”
      statusAllRef.on('value', snap => {
        const now = Date.now();
        const online = [];
        snap.forEach(ch => {
          const v = ch.val();
          if (v.lastSeen && (now - v.lastSeen) < ONLINE_WINDOW) {
            online.push(v);
          }
        });
        presenceEl.innerHTML = online.length
          ? online.map(v => `<span class="pill"><span class="dot"></span><span>${v.avatar}</span><b>${v.name}</b></span>`).join('')
          : '<span class="muted">å½“å‰æ— äººåœ¨çº¿</span>';
      });

      // â€”â€” å‘é€æ¶ˆæ¯ â€”â€”
      form.addEventListener('submit', async e => {
        e.preventDefault();
        const txt = (textInput.value || '').trim();
        if (!txt) return;
        sendBtn.disabled = true;
        sendBtn.textContent = 'å‘é€ä¸­...';
        try {
          await messagesRef.push({
            userId: currentUser.id,
            text: txt,
            ts: firebase.database.ServerValue.TIMESTAMP
          });
          textInput.value = '';
          textInput.dispatchEvent(new Event('input'));
          showToast('å‘é€æˆåŠŸ', 'success');
        } catch (err) {
          console.error(err);
          showToast('å‘é€å¤±è´¥ï¼Œè¯·é‡è¯•', 'error');
        } finally {
          sendBtn.disabled = false;
          sendBtn.textContent = 'å‘é€';
        }
      });

      // Ctrl/Cmd + Enter å‘é€
      textInput.addEventListener('keydown', (e) => {
        if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
          e.preventDefault();
          form.requestSubmit();
        }
      });

      // â€”â€” æ¸…ç† & ç›‘å¬ & æ¸²æŸ“ç•™è¨€ â€”â€”
      cleanupExpired();
      messageTimer = setInterval(cleanupExpired, 10 * 60 * 1000);

      const since = Date.now() - EXP_MS;
      messagesRef.orderByChild('ts').startAt(since).limitToLast(500)
        .on('child_added', snap => renderMessage(snap.key, snap.val()));
      messagesRef.on('child_removed', snap => {
        const el = document.getElementById('msg-' + snap.key);
        if (el) el.remove();
      });

      // â€”â€” ç•™è¨€å€’è®¡æ—¶æ›´æ–° â€”â€”
      setInterval(updateAllMessageCountdowns, COUNTDOWN_INTERVAL);

      // â€”â€” åˆå§‹åŒ– & ç›‘å¬å¼€å¥–æ¨¡å— â€”â€”
      gameSelect.addEventListener('change', () => loadLottery(gameSelect.value));
      loadLottery(gameSelect.value);
    }

    // â€”â€” æ¸²æŸ“å•æ¡ç•™è¨€ â€”â€”
    function renderMessage(id, m) {
      if (!m || !m.ts) return;
      const age = Date.now() - m.ts;
      if (age >= EXP_MS) return;
      let li = document.getElementById('msg-' + id);
      if (!li) {
        li = document.createElement('li');
        li.id = 'msg-' + id; li.className = 'msg';
        li.innerHTML = `
          <div class="avatar">${USERS[m.userId]?.avatar || 'ğŸ™‚'}</div>
          <div class="bubble">
            <div><strong>${USERS[m.userId]?.name || 'æœªçŸ¥'}ï¼š</strong><span class="content"></span></div>
            <div class="meta"><span class="time"></span> <span class="remain"></span></div>
          </div>`;
        listEl.prepend(li);
      }
      li.querySelector('.content').textContent = m.text;
      li.dataset.ts = m.ts;
      li.querySelector('.time').textContent = new Date(m.ts).toLocaleString();
      updateMessageCountdown(li);
    }

    // â€”â€” æ›´æ–°æ‰€æœ‰ç•™è¨€å‰©ä½™æ—¶é•¿ â€”â€”
    function updateAllMessageCountdowns() {
      document.querySelectorAll('li.msg').forEach(updateMessageCountdown);
    }
    function updateMessageCountdown(li) {
      const ts = Number(li.dataset.ts);
      const remain = ts + EXP_MS - Date.now();
      if (remain <= 0) { li.remove(); return; }
      const s = Math.floor(remain / 1000);
      const h = String(Math.floor(s / 3600)).padStart(2, '0');
      const m = String(Math.floor((s % 3600) / 60)).padStart(2, '0');
      li.querySelector('.remain').textContent = `å‰©ä½™ ${h}å°æ—¶${m}åˆ†é’Ÿ`;
    }

    // â€”â€” å®¢æˆ·ç«¯æ¸…ç†è¿‡æœŸç•™è¨€ â€”â€”
    function cleanupExpired() {
      const cutoff = Date.now() - EXP_MS;
      messagesRef.orderByChild('ts').endAt(cutoff)
        .once('value', snap => snap.forEach(ch => ch.ref.remove()));
    }

    // â€”â€” å¸¦è¶…æ—¶çš„fetchè¯·æ±‚ â€”â€”
    async function fetchWithTimeout(url, options = {}, timeout = 8000) {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), timeout);
      try {
        const response = await fetch(url, {
          ...options,
          signal: controller.signal
        });
        clearTimeout(timeoutId);
        return response;
      } catch (error) {
        clearTimeout(timeoutId);
        throw error;
      }
    }

    // â€”â€” åŠ è½½å¼€å¥–æ•°æ® & æ¸²æŸ“ï¼ˆå¢å¼ºç‰ˆï¼‰â€”â€”
    async function loadLottery(gameid) {
      lotteryInfo.textContent = 'è½½å…¥ä¸­...';

      // å°è¯•æ‰€æœ‰APIæº
      for (let i = 0; i < LOTTERY_APIS.length; i++) {
        const api = LOTTERY_APIS[i];
        try {
          showToast(`æ­£åœ¨å°è¯•${api.name}...`, 'warning', 1500);

          const res = await fetchWithTimeout(api.url(gameid));
          if (!res.ok) throw new Error(`HTTP ${res.status}`);

          const json = await res.json();
          const d = api.parser(json);

          if (!d) {
            throw new Error('æ•°æ®è§£æå¤±è´¥');
          }

          // æ¸²æŸ“æˆåŠŸçš„æ•°æ®
          const zodiacHtml = d.currentZodiac
            ? d.currentZodiac.split(',').map(z => `${zodiacEmoji[z] || ''}${z}`).join(', ')
            : '';

          // æ ¼å¼åŒ–å¼€å¥–å·ç ï¼Œä¸ºæ¯ä¸ªæ•°å­—æ·»åŠ æ ·å¼
          const formatNumbers = (numbers) => {
            if (!numbers || numbers === 'â€”') return 'â€”';
            return numbers.split(/[,ï¼Œ+]/).map(num =>
              `<span class="number">${num.trim()}</span>`
            ).join('');
          };

          const last3 = (d.resultsOfLastThreeIssues || []).map(r => {
            const zs = r.zodiac
              ? r.zodiac.split(',').map(z => `${zodiacEmoji[z] || ''}${z}`).join(', ')
              : '';
            return `<li>
              <div>
                <div class="history-issue">${r.issue}</div>
                <div class="history-numbers">${formatNumbers(r.result)}</div>
                ${zs ? `<div class="zodiac">${zs}</div>` : ''}
              </div>
              <div class="muted">${r.creatTime}</div>
            </li>`;
          }).join('');

          lotteryInfo.innerHTML = `
            <div class="lottery-container">
              <div class="lottery-main">
                <div style="flex: 1;">
                  <div class="lottery-issue">ç¬¬ ${d.currentIssue || 'â€”'} æœŸ</div>
                  <div class="lottery-numbers">${formatNumbers(d.currentResult)}</div>
                  ${zodiacHtml ? `<div class="lottery-zodiac">${zodiacHtml}</div>` : ''}
                  <div class="lottery-next">ä¸‹æœŸï¼š${d.nextIssue || 'â€”'}${d.nextTime ? ` â€¢ ${d.nextTime}` : ''}</div>
                </div>
              </div>
              ${last3 ? `
                <div class="lottery-history">
                  <h4>ğŸ“Š æœ€è¿‘ä¸‰æœŸå¼€å¥–</h4>
                  <ul>${last3}</ul>
                </div>
              `: ''}
              <div class="muted" style="text-align: center; margin-top: 8px;">æ•°æ®æ¥æºï¼š${api.name}</div>
            </div>
          `;

          // å¯åŠ¨å€’è®¡æ—¶ï¼ˆå›ºå®šæ¯æ™š21:30å¼€å¥–ï¼‰
          startLotteryCountdown();

          showToast(`${api.name}åŠ è½½æˆåŠŸ`, 'success');
          return; // æˆåŠŸåé€€å‡ºå¾ªç¯

        } catch (e) {
          console.warn(`${api.name}å¤±è´¥:`, e.message);

          // å¦‚æœæ˜¯æœ€åä¸€ä¸ªAPIä¹Ÿå¤±è´¥äº†
          if (i === LOTTERY_APIS.length - 1) {
            lotteryInfo.innerHTML = `
              <div class="error">âš ï¸ æ‰€æœ‰æ•°æ®æºå‡æ— æ³•è®¿é—®</div>
              <div class="muted">å¯èƒ½çš„åŸå› ï¼š</div>
              <ul style="padding-left:16px; margin:8px 0;">
                <li>ç½‘ç»œè¿æ¥é—®é¢˜</li>
                <li>APIæœåŠ¡æš‚æ—¶ä¸å¯ç”¨</li>
                <li>è·¨åŸŸè®¿é—®é™åˆ¶</li>
              </ul>
              <button onclick="loadLottery(${gameid})" style="margin-top:8px;">ğŸ”„ é‡æ–°åŠ è½½</button>
            `;
            showToast('æ‰€æœ‰æ•°æ®æºåŠ è½½å¤±è´¥', 'error', 3000);
          }
        }
      }
    }

    // â€”â€” å¼€å¥–å€’è®¡æ—¶ â€”â€”
    let lotteryTimer = null;
    function startLotteryCountdown() {
      if (lotteryTimer) clearTimeout(lotteryTimer);
      function tick() {
        const now = new Date();
        const today = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 21, 30, 0); // ä»Šå¤©21:30
        let target = today;

        // å¦‚æœä»Šå¤©21:30å·²è¿‡ï¼Œåˆ™è®¡ç®—æ˜å¤©21:30
        if (now > today) {
          target = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1, 21, 30, 0);
        }

        const diff = target.getTime() - now.getTime();
        if (diff <= 0) {
          countdownEl.textContent = 'ğŸ‰ æ­£åœ¨å¼€å¥–ä¸­ï¼';
          // å¼€å¥–å1åˆ†é’Ÿé‡æ–°è®¡ç®—ä¸‹æœŸæ—¶é—´
          lotteryTimer = setTimeout(tick, 60000);
        } else {
          const h = Math.floor(diff / 3600000);
          const m = Math.floor((diff % 3600000) / 60000);
          const s = Math.floor((diff % 60000) / 1000);

          if (h > 0) {
            countdownEl.textContent = `â³ è·ç¦»å¼€å¥–ï¼š${h}å°æ—¶${m}åˆ†${s}ç§’`;
          } else {
            countdownEl.textContent = `â³ è·ç¦»å¼€å¥–ï¼š${m}åˆ†${s}ç§’`;
          }
          lotteryTimer = setTimeout(tick, 1000);
        }
      }
      tick();
    }

    // â€”â€” AIé¢„æµ‹åŠŸèƒ½ â€”â€”
    // ä½¿ç”¨OpenRouterçš„moonshotai/kimi-k2:freeæ¨¡å‹

    // OpenRouteré…ç½® - å¤šä¸ªAPIå¯†é’¥è½®æ¢ä½¿ç”¨
    const OPENROUTER_API_KEYS = [
      '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',
      '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',
      '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'
    ];
    const OPENROUTER_API_URL = 'https://openrouter.ai/api/v1/chat/completions';
    const OPENROUTER_MODEL = 'mistralai/mistral-nemo:free';

    // å¯†é’¥è½®æ¢ç´¢å¼•
    let currentKeyIndex = 0;

    // å…è´¹æ¨¡å‹åˆ—è¡¨ - 2025å¹´æœ€æ–°ç¡®è®¤å¯ç”¨çš„å…è´¹æ¨¡å‹
    const FREE_MODELS = [
      'deepseek/deepseek-chat-v3.1:free',           // ğŸš€ DeepSeekæœ€æ–°å…è´¹ç‰ˆ (æœ€ç¨³å®š)
      'meta-llama/llama-3.3-8b-instruct:free',      // ğŸ¯ Llama 3.3 8B (ç¨³å®šæ€§å¥½)
      'qwen/qwen-2.5-72b-instruct:free',            // ğŸ”¥ 720äº¿å‚æ•°å…è´¹ç‰ˆ (é«˜æ€§èƒ½)
      'google/gemini-2.0-flash-exp:free',           // âš¡ Googleæœ€æ–°å…è´¹æ¨¡å‹ (å¿«é€Ÿ)
      'moonshotai/kimi-k2:free',                    // ğŸŒŸ ä½ æœ€åˆæƒ³è¦çš„æ¨¡å‹
      'google/gemma-3-12b-it:free',                  // ğŸ’ Google Gemma 3 (å¤‡ç”¨)
      'deepseek/deepseek-r1:free',                  // âš¡ DeepSeekæ¨ç†æ¨¡å‹ (å¤‡ç”¨)
      'mistralai/mistral-nemo:free'                  // ğŸ† é«˜æ€§èƒ½å…è´¹æ¨¡å‹ (æœ€åå¤‡ç”¨)
    ];

    // APIå¯†é’¥åˆ—è¡¨ - æ‚¨æä¾›çš„å¤šä¸ªå¯†é’¥
    const API_KEYS = [
      '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',
      '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',
      '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'
    ];

    // å½“å‰æ¨¡å‹ç´¢å¼•
    let currentModelIndex = 0;

    // APIæä¾›å•†ç±»å‹ - ä½¿ç”¨OpenRouter
    const API_PROVIDERS = {
      OPENROUTER: 'openrouter'
    };

    // å½“å‰ä½¿ç”¨çš„APIæä¾›å•† - é»˜è®¤ä½¿ç”¨OpenRouter
    let currentProvider = API_PROVIDERS.OPENROUTER;

    // â€”â€” AI é…ç½®ï¼ˆæ¸©åº¦ã€çª—å£ç­‰ï¼‰ â€”â€”
    function getAIConfig() {
      const stored = localStorage.getItem('AI_CONFIG');
      const defaults = {
        temperature: 0.5,        // é™ä½æ¸©åº¦ä»¥æé«˜ç¨³å®šæ€§
        max_tokens: 300,         // å‡å°‘tokenæ•°é‡é¿å…402é”™è¯¯
        windowSize: 8,           // å‡å°‘çª—å£å¤§å°
        minWinRate: 40,          // é™ä½èƒœç‡è¦æ±‚
        adjustMode: 'conservative', // ä¿å®ˆè°ƒæ•´æ¨¡å¼
        reasoningDepth: 3        // å‡å°‘æ¨ç†æ·±åº¦
      };
      try {
        return stored ? { ...defaults, ...JSON.parse(stored) } : defaults;
      } catch {
        return defaults;
      }
    }

    function saveAIConfig(cfg) {
      localStorage.setItem('AI_CONFIG', JSON.stringify(cfg));
    }

    function extractAIContent(data) {
      console.log('ğŸ” å¼€å§‹æå–AIå†…å®¹...');
      console.log('ğŸ“Š è¾“å…¥æ•°æ®ç±»å‹:', typeof data);
      console.log('ğŸ“Š è¾“å…¥æ•°æ®ç»“æ„:', data ? Object.keys(data) : 'null');

      if (!data) {
        console.log('âŒ æ•°æ®ä¸ºç©º');
        return '';
      }

      const ch = Array.isArray(data.choices) ? data.choices[0] : null;
      console.log('ğŸ“Š choicesæ•°ç»„:', Array.isArray(data.choices) ? `é•¿åº¦${data.choices.length}` : 'ä¸æ˜¯æ•°ç»„');
      console.log('ğŸ“Š ç¬¬ä¸€ä¸ªchoice:', ch ? 'å­˜åœ¨' : 'ä¸å­˜åœ¨');
      if (ch) {
        console.log('ğŸ“Š choiceç»“æ„:', Object.keys(ch));
      }

      if (!ch) {
        console.log('âŒ æ²¡æœ‰æ‰¾åˆ°æœ‰æ•ˆçš„choice');
        return '';
      }

      // å°è¯•å¤šç§å¯èƒ½çš„å“åº”æ ¼å¼
      if (ch && ch.message && typeof ch.message.content === 'string') {
        console.log('âœ… æ‰¾åˆ°message.contentæ ¼å¼');
        return ch.message.content;
      }

      // OpenRouterå¯èƒ½ä½¿ç”¨reasoning_contentå­—æ®µ
      if (ch && ch.message && typeof ch.message.reasoning_content === 'string') {
        console.log('âœ… æ‰¾åˆ°message.reasoning_contentæ ¼å¼');
        return ch.message.reasoning_content;
      }

      if (ch && ch.delta && typeof ch.delta.content === 'string') {
        console.log('âœ… æ‰¾åˆ°delta.contentæ ¼å¼');
        return ch.delta.content;
      }

      if (ch && ch.message && Array.isArray(ch.message.content)) {
        console.log('ğŸ” å°è¯•message.contentæ•°ç»„æ ¼å¼');
        const parts = ch.message.content.map(p => (typeof p === 'string' ? p : (p && p.text ? p.text : ''))).join('\n').trim();
        if (parts) {
          console.log('âœ… æˆåŠŸä»message.contentæ•°ç»„æå–å†…å®¹');
          return parts;
        }
      }

      if (typeof ch.text === 'string') {
        console.log('âœ… æ‰¾åˆ°textæ ¼å¼');
        return ch.text;
      }

      if (typeof ch.output_text === 'string') {
        console.log('âœ… æ‰¾åˆ°output_textæ ¼å¼');
        return ch.output_text;
      }

      if (typeof ch.content === 'string') {
        console.log('âœ… æ‰¾åˆ°contentæ ¼å¼');
        return ch.content;
      }

      if (Array.isArray(ch.content)) {
        console.log('ğŸ” å°è¯•contentæ•°ç»„æ ¼å¼');
        const parts = ch.content.map(p => (typeof p === 'string' ? p : (p && p.text ? p.text : ''))).join('\n').trim();
        if (parts) {
          console.log('âœ… æˆåŠŸä»contentæ•°ç»„æå–å†…å®¹');
          return parts;
        }
      }

      if (typeof data.output_text === 'string') {
        console.log('âœ… æ‰¾åˆ°data.output_textæ ¼å¼');
        return data.output_text;
      }

      console.log('âŒ å°è¯•äº†æ‰€æœ‰æ ¼å¼éƒ½æ— æ³•æå–å†…å®¹');
      console.log('ğŸ“Š å®Œæ•´æ•°æ®:', JSON.stringify(data, null, 2));
      return '';
    }

    // è·å–ä¸‹ä¸€ä¸ªå¯ç”¨çš„APIå¯†é’¥
    function getNextApiKey() {
      const key = OPENROUTER_API_KEYS[currentKeyIndex];
      currentKeyIndex = (currentKeyIndex + 1) % OPENROUTER_API_KEYS.length;
      return key;
    }

    // OpenRouter APIè°ƒç”¨å‡½æ•° - æ”¯æŒå¤šå¯†é’¥è½®æ¢
    async function callOpenRouterAI(prompt, model = OPENROUTER_MODEL) {
      console.log(`ğŸ¤– è°ƒç”¨OpenRouteræ¨¡å‹: ${model}...`);

      let lastError = null;

      // å°è¯•æ‰€æœ‰APIå¯†é’¥
      for (let keyAttempt = 0; keyAttempt < OPENROUTER_API_KEYS.length; keyAttempt++) {
        const currentApiKey = getNextApiKey();
        console.log(`ğŸ”‘ ä½¿ç”¨APIå¯†é’¥: ${currentApiKey.substring(0, 15)}... (å°è¯• ${keyAttempt + 1}/${OPENROUTER_API_KEYS.length})`);

        try {
          const requestBody = {
            model: model,
            messages: [
              {
                role: 'system',
                content: 'ä½ æ˜¯ä¸€ä¸ªå½©ç¥¨é¢„æµ‹åˆ†æåŠ©æ‰‹ã€‚åªè¿”å›JSONæ ¼å¼çš„é¢„æµ‹ç»“æœï¼Œä¸åŒ…å«ä»»ä½•è§£é‡Šã€åˆ†æè¿‡ç¨‹æˆ–é¢å¤–æ–‡å­—ã€‚ç”¨æˆ·è¾“å…¥å†å²æ•°æ®ï¼Œä½ è¿”å›é¢„æµ‹ç»“æœã€‚'
              },
              {
                role: 'user',
                content: prompt
              },
              {
                role: 'assistant',
                content: '{"analysis": "ç¤ºä¾‹åˆ†æ", "predictions": {"recommended": [01, 02, 03, 04, 05, 06, 07], "alternative": [08, 09, 10, 11, 12, 13, 14], "confidence": 80}}'
              }
            ],
            max_tokens: 300,
            temperature: 0.7,
            stream: false
          };

          const response = await fetch(OPENROUTER_API_URL, {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${currentApiKey}`,
              'Content-Type': 'application/json',
              'HTTP-Referer': window.location.origin,
              'X-Title': 'AI Lottery Predictor'
            },
            body: JSON.stringify(requestBody)
          });

          console.log(`ğŸ“¡ APIå¯†é’¥ ${currentApiKey.substring(0, 15)}... å“åº”çŠ¶æ€:`, response.status);

          if (!response.ok) {
            const errorText = await response.text();
            lastError = new Error(`OpenRouterè¯·æ±‚å¤±è´¥: ${response.status} ${errorText}`);
            console.warn(`âŒ APIå¯†é’¥ ${currentApiKey.substring(0, 15)}... å¤±è´¥:`, response.status, errorText);

            // å¦‚æœæ˜¯429é”™è¯¯ï¼ˆé™æµï¼‰ï¼Œå°è¯•ä¸‹ä¸€ä¸ªå¯†é’¥
            if (response.status === 429 || response.status === 402) {
              continue;
            } else {
              // å…¶ä»–é”™è¯¯ç›´æ¥æŠ›å‡º
              throw lastError;
            }
          }

          const data = await response.json();
          console.log(`âœ… APIå¯†é’¥ ${currentApiKey.substring(0, 15)}... å“åº”æˆåŠŸ`);

          // æå–å†…å®¹
          const content = extractAIContent(data);
          console.log('ğŸ“ OpenRouteræå–çš„å†…å®¹:', content);

          if (!content || content.trim() === '') {
            throw new Error('OpenRouterè¿”å›å†…å®¹ä¸ºç©º');
          }

          return content;

        } catch (error) {
          lastError = error;
          console.warn(`âŒ APIå¯†é’¥ ${currentApiKey.substring(0, 15)}... è°ƒç”¨å¼‚å¸¸:`, error.message);

          // å¦‚æœæ˜¯ç½‘ç»œé”™è¯¯æˆ–é™æµé”™è¯¯ï¼Œå°è¯•ä¸‹ä¸€ä¸ªå¯†é’¥
          if (error.message.includes('limit') || error.message.includes('429') || error.message.includes('402')) {
            continue;
          } else {
            throw error;
          }
        }
      }

      // æ‰€æœ‰å¯†é’¥éƒ½å¤±è´¥äº†
      console.error('âŒ æ‰€æœ‰APIå¯†é’¥éƒ½å·²ç”¨å®Œ');
      throw lastError || new Error('æ‰€æœ‰APIå¯†é’¥éƒ½æ— æ³•è®¿é—®ï¼Œè¯·ç¨åå†è¯•');
    }

    // æœ¬åœ°ç®—æ³•é¢„æµ‹ç³»ç»Ÿ
    class LocalPredictionEngine {
      constructor() {
        this.algorithms = {
          markovChain: new MarkovChainAnalyzer(),
          bayesian: new BayesianAnalyzer(),
          timeSeries: new TimeSeriesAnalyzer(),
          clustering: new ClusteringAnalyzer(),
          neuralNetwork: new NeuralNetworkAnalyzer(),
          monteCarlo: new MonteCarloAnalyzer(),
          geneticAlgorithm: new GeneticAlgorithmAnalyzer(),
          supportVectorMachine: new SVMAnalyzer()
        };
        this.weights = {
          markovChain: 0.15,
          bayesian: 0.15,
          timeSeries: 0.15,
          clustering: 0.10,
          neuralNetwork: 0.15,
          monteCarlo: 0.10,
          geneticAlgorithm: 0.10,
          supportVectorMachine: 0.10
        };
      }

      async predict(historyData) {
        console.log('ğŸ”® å¯åŠ¨æœ¬åœ°ç®—æ³•é¢„æµ‹...');

        if (historyData.length < 5) {
          throw new Error('å†å²æ•°æ®ä¸è¶³ï¼Œéœ€è¦è‡³å°‘5æœŸæ•°æ®è¿›è¡Œé¢„æµ‹');
        }

        const results = {};
        const predictions = [];

        // æ‰§è¡Œæ‰€æœ‰ç®—æ³•
        for (const [name, algorithm] of Object.entries(this.algorithms)) {
          try {
            console.log(`ğŸ”„ æ‰§è¡Œ${name}åˆ†æ...`);
            const result = await algorithm.predict(historyData);
            results[name] = result;

            result.numbers.forEach(num => {
              predictions.push({
                number: num,
                source: name,
                confidence: result.confidence * this.weights[name]
              });
            });
          } catch (error) {
            console.warn(`âš ï¸ ${name}ç®—æ³•æ‰§è¡Œå¤±è´¥:`, error.message);
            results[name] = { numbers: [], confidence: 0 };
          }
        }

        // ç»¼åˆç»“æœ
        return this.combinePredictions(predictions, results);
      }

      combinePredictions(predictions, results) {
        const numberScores = {};

        predictions.forEach(pred => {
          if (!numberScores[pred.number]) {
            numberScores[pred.number] = {
              number: pred.number,
              totalScore: 0,
              sources: [],
              count: 0
            };
          }
          numberScores[pred.number].totalScore += pred.confidence;
          numberScores[pred.number].sources.push(pred.source);
          numberScores[pred.number].count++;
        });

        const rankedNumbers = Object.values(numberScores)
          .map(item => ({
            ...item,
            averageScore: item.totalScore / item.count,
            sourceDiversity: item.sources.length / 8
          }))
          .sort((a, b) => {
            const scoreA = a.averageScore * 0.7 + a.sourceDiversity * 0.3;
            const scoreB = b.averageScore * 0.7 + b.sourceDiversity * 0.3;
            return scoreB - scoreA;
          });

        const recommended = rankedNumbers.slice(0, 7).map(item => item.number);
        const alternative = rankedNumbers.slice(7, 14).map(item => item.number);
        const overallConfidence = rankedNumbers.slice(0, 7).reduce((sum, item) => sum + item.averageScore, 0) / 7;

        return {
          analysis: "æœ¬åœ°ç®—æ³•ç»¼åˆåˆ†æ - é›†æˆ8ç§é«˜çº§ç®—æ³•",
          predictions: {
            recommended: recommended.sort((a, b) => a - b),
            alternative: alternative.sort((a, b) => a - b),
            confidence: Math.min(95, Math.round(overallConfidence * 100))
          }
        };
      }
    }

    // çœŸæ­£çš„é©¬å°”å¯å¤«é“¾åˆ†æå™¨
    class MarkovChainAnalyzer {
      constructor() {
        this.transitionMatrix = null;
        this.stateProbabilities = new Map();
      }

      // æ„å»ºçŠ¶æ€è½¬ç§»çŸ©é˜µ
      buildTransitionMatrix(historyData) {
        const matrix = Array(50).fill(0).map(() => Array(50).fill(0)); // 1-49å·ç 
        const stateCounts = Array(50).fill(0);

        // åˆ†æè¿ç»­ä¸¤æœŸçš„å·ç è½¬ç§»
        for (let i = 1; i < historyData.length; i++) {
          const prevDraw = historyData[i - 1].numbers;
          const currDraw = historyData[i].numbers;

          prevDraw.forEach(prevNum => {
            stateCounts[prevNum]++;
            currDraw.forEach(currNum => {
              matrix[prevNum][currNum]++;
            });
          });
        }

        // è®¡ç®—è½¬ç§»æ¦‚ç‡
        for (let i = 1; i <= 49; i++) {
          if (stateCounts[i] > 0) {
            for (let j = 1; j <= 49; j++) {
              matrix[i][j] = matrix[i][j] / stateCounts[i];
            }
          }
        }

        this.transitionMatrix = matrix;
        return matrix;
      }

      // åˆ†æé«˜é˜¶é©¬å°”å¯å¤«é“¾ï¼ˆè€ƒè™‘å¤šæœŸè¿ç»­æ€§ï¼‰
      analyzeHighOrderTransitions(historyData, order = 2) {
        const patterns = new Map();

        for (let i = order; i < historyData.length; i++) {
          const pattern = [];
          for (let j = 0; j < order; j++) {
            pattern.push(...historyData[i - j - 1].numbers.sort((a, b) => a - b));
          }
          const patternKey = pattern.join(',');
          const nextNumbers = historyData[i].numbers;

          if (!patterns.has(patternKey)) {
            patterns.set(patternKey, []);
          }
          patterns.get(patternKey).push(nextNumbers);
        }

        return patterns;
      }

      // è®¡ç®—çŠ¶æ€ç¨³å®šæ€§
      calculateStateStability(historyData) {
        const stability = {};

        for (let num = 1; num <= 49; num++) {
          const occurrences = [];
          historyData.forEach((draw, index) => {
            if (draw.numbers.includes(num)) {
              occurrences.push(index);
            }
          });

          if (occurrences.length > 1) {
            const intervals = [];
            for (let i = 1; i < occurrences.length; i++) {
              intervals.push(occurrences[i] - occurrences[i - 1]);
            }

            const meanInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
            const variance = intervals.reduce((sum, interval) =>
              sum + Math.pow(interval - meanInterval, 2), 0) / intervals.length;

            stability[num] = {
              meanInterval: meanInterval,
              variance: variance,
              regularity: 1 / (1 + variance) // è§„å¾‹æ€§æŒ‡æ ‡
            };
          }
        }

        return stability;
      }

      async predict(historyData) {
        if (historyData.length < 5) {
          throw new Error('é©¬å°”å¯å¤«é“¾åˆ†æéœ€è¦è‡³å°‘5æœŸå†å²æ•°æ®');
        }

        console.log('ğŸ”— å¼€å§‹æ„å»ºé©¬å°”å¯å¤«é“¾è½¬ç§»çŸ©é˜µ...');

        // æ„å»ºè½¬ç§»çŸ©é˜µ
        const transitionMatrix = this.buildTransitionMatrix(historyData);

        // åˆ†æé«˜é˜¶æ¨¡å¼
        const highOrderPatterns = this.analyzeHighOrderTransitions(historyData, 2);

        // è®¡ç®—çŠ¶æ€ç¨³å®šæ€§
        const stateStability = this.calculateStateStability(historyData);

        // è·å–æœ€è¿‘ä¸€æœŸå·ç 
        const lastNumbers = historyData[historyData.length - 1].numbers;

        // è®¡ç®—æ¯ä¸ªå·ç çš„è½¬ç§»æ¦‚ç‡å¾—åˆ†
        const probabilityScores = new Map();

        for (let num = 1; num <= 49; num++) {
          let totalProbability = 0;
          let weightSum = 0;

          // åŸºäºè½¬ç§»çŸ©é˜µçš„æ¦‚ç‡
          lastNumbers.forEach(lastNum => {
            if (transitionMatrix[lastNum][num] > 0) {
              totalProbability += transitionMatrix[lastNum][num];
              weightSum++;
            }
          });

          // è€ƒè™‘é«˜é˜¶æ¨¡å¼åŒ¹é…
          const lastTwoPatterns = [];
          if (historyData.length >= 2) {
            const pattern1 = historyData[historyData.length - 1].numbers.sort((a, b) => a - b);
            const pattern2 = historyData[historyData.length - 2].numbers.sort((a, b) => a - b);
            const patternKey = [...pattern2, ...pattern1].join(',');

            if (highOrderPatterns.has(patternKey)) {
              const nextNumbersList = highOrderPatterns.get(patternKey);
              const patternProbability = nextNumbersList.filter(nums =>
                nums.includes(num)).length / nextNumbersList.length;
              totalProbability += patternProbability * 0.3; // ç»™é«˜é˜¶æ¨¡å¼ä¸€å®šæƒé‡
              weightSum += 0.3;
            }
          }

          // è€ƒè™‘çŠ¶æ€ç¨³å®šæ€§
          if (stateStability[num]) {
            const stabilityBonus = stateStability[num].regularity * 0.1;
            totalProbability += stabilityBonus;
            weightSum += 1;
          }

          const finalScore = weightSum > 0 ? totalProbability / weightSum : 0;
          probabilityScores.set(num, finalScore);
        }

        // é€‰æ‹©å¾—åˆ†æœ€é«˜çš„7ä¸ªå·ç 
        const sortedNumbers = Array.from(probabilityScores.entries())
          .sort((a, b) => b[1] - a[1])
          .slice(0, 7)
          .map(([num]) => num);

        // è®¡ç®—ç½®ä¿¡åº¦ï¼ˆåŸºäºè½¬ç§»æ¦‚ç‡çš„ç¦»æ•£ç¨‹åº¦ï¼‰
        const scores = Array.from(probabilityScores.values());
        const meanScore = scores.reduce((a, b) => a + b, 0) / scores.length;
        const variance = scores.reduce((sum, score) =>
          sum + Math.pow(score - meanScore, 2), 0) / scores.length;
        const confidence = Math.min(0.95, Math.max(0.3, 1 / (1 + variance)));

        console.log(`ğŸ”— é©¬å°”å¯å¤«é“¾åˆ†æå®Œæˆï¼Œç½®ä¿¡åº¦: ${confidence.toFixed(3)}`);

        return {
          numbers: sortedNumbers.sort((a, b) => a - b),
          confidence: confidence,
          algorithm: 'markov_chain',
          details: {
            transitionMatrixBuilt: true,
            highOrderPatterns: highOrderPatterns.size,
            stateStabilityAnalyzed: Object.keys(stateStability).length,
            avgProbability: meanScore
          }
        };
      }
    }

    // çœŸæ­£çš„è´å¶æ–¯æ¦‚ç‡æ¨¡å‹
    class BayesianAnalyzer {
      constructor() {
        this.priorProbabilities = new Map();
        this.conditionalProbabilities = new Map();
        this.likelihoodMatrix = null;
      }

      // è®¡ç®—å…ˆéªŒæ¦‚ç‡ï¼ˆåŸºäºå†å²é¢‘ç‡ï¼‰
      calculatePriorProbabilities(historyData) {
        const totalNumbers = historyData.reduce((sum, draw) => sum + draw.numbers.length, 0);
        const frequency = new Map();

        historyData.forEach(draw => {
          draw.numbers.forEach(num => {
            frequency.set(num, (frequency.get(num) || 0) + 1);
          });
        });

        // ä½¿ç”¨æ‹‰æ™®æ‹‰æ–¯å¹³æ»‘é¿å…é›¶æ¦‚ç‡
        const alpha = 1; // å¹³æ»‘å‚æ•°
        for (let num = 1; num <= 49; num++) {
          const count = frequency.get(num) || 0;
          const probability = (count + alpha) / (totalNumbers + alpha * 49);
          this.priorProbabilities.set(num, probability);
        }

        return this.priorProbabilities;
      }

      // è®¡ç®—æ¡ä»¶æ¦‚ç‡ï¼ˆç»™å®šæŸäº›å·ç å‡ºç°ï¼Œå…¶ä»–å·ç å‡ºç°çš„æ¦‚ç‡ï¼‰
      calculateConditionalProbabilities(historyData) {
        const coOccurrence = Array(50).fill(0).map(() => Array(50).fill(0));
        const occurrence = Array(50).fill(0);

        historyData.forEach(draw => {
          draw.numbers.forEach(num => {
            occurrence[num]++;
            draw.numbers.forEach(otherNum => {
              if (num !== otherNum) {
                coOccurrence[num][otherNum]++;
              }
            });
          });
        });

        // è®¡ç®—æ¡ä»¶æ¦‚ç‡ P(B|A) = P(A,B) / P(A)
        for (let i = 1; i <= 49; i++) {
          for (let j = 1; j <= 49; j++) {
            if (i !== j && occurrence[i] > 0) {
              const prob = coOccurrence[i][j] / occurrence[i];
              this.conditionalProbabilities.set(`${i},${j}`, prob);
            }
          }
        }

        return this.conditionalProbabilities;
      }

      // è®¡ç®—ä¼¼ç„¶å‡½æ•°ï¼ˆç»™å®šå†å²æ¨¡å¼çš„æ¦‚ç‡ï¼‰
      calculateLikelihood(historyData, candidateNumbers) {
        let likelihood = 1.0;

        // åˆ†æå€™é€‰å·ç ä¸å†å²æ•°æ®çš„åŒ¹é…ç¨‹åº¦
        candidateNumbers.forEach(num => {
          const recentHistory = historyData.slice(-10);
          let matchCount = 0;

          recentHistory.forEach(draw => {
            if (draw.numbers.includes(num)) {
              matchCount++;
            }
          });

          // ä½¿ç”¨æ³Šæ¾åˆ†å¸ƒå»ºæ¨¡å‡ºç°é¢‘ç‡
          const lambda = matchCount / 10; // å¹³å‡æ¯æœŸå‡ºç°æ¦‚ç‡
          const poissonProb = this.poissonProbability(lambda, 1); // é¢„æµ‹ä¸‹æœŸå‡ºç°ä¸€æ¬¡
          likelihood *= poissonProb;
        });

        return likelihood;
      }

      // æ³Šæ¾åˆ†å¸ƒæ¦‚ç‡è®¡ç®—
      poissonProbability(lambda, k) {
        if (lambda === 0) return k === 0 ? 1 : 0;
        return (Math.pow(lambda, k) * Math.exp(-lambda)) / this.factorial(k);
      }

      factorial(n) {
        if (n <= 1) return 1;
        let result = 1;
        for (let i = 2; i <= n; i++) {
          result *= i;
        }
        return result;
      }

      // åº”ç”¨è´å¶æ–¯å®šç†
      applyBayesTheorem(evidence, hypothesis) {
        // P(H|E) = P(E|H) * P(H) / P(E)
        const priorHypothesis = this.priorProbabilities.get(hypothesis) || 0.02;
        const likelihoodGivenHypothesis = this.calculateLikelihoodForHypothesis(evidence, hypothesis);
        const evidenceProbability = this.calculateEvidenceProbability(evidence);

        if (evidenceProbability === 0) return priorHypothesis;

        const posteriorProbability = (likelihoodGivenHypothesis * priorHypothesis) / evidenceProbability;
        return Math.min(1, Math.max(0, posteriorProbability));
      }

      calculateLikelihoodForHypothesis(evidence, hypothesis) {
        // è®¡ç®—ç»™å®šå‡è®¾ä¸‹çš„ä¼¼ç„¶
        let likelihood = 1.0;

        evidence.forEach(num => {
          const conditionalProb = this.conditionalProbabilities.get(`${hypothesis},${num}`) || 0.01;
          likelihood *= conditionalProb;
        });

        return likelihood;
      }

      calculateEvidenceProbability(evidence) {
        // è®¡ç®—è¯æ®çš„å…¨æ¦‚ç‡
        let totalProbability = 0;

        for (let num = 1; num <= 49; num++) {
          const prior = this.priorProbabilities.get(num) || 0.02;
          const likelihood = this.calculateLikelihoodForHypothesis(evidence, num);
          totalProbability += prior * likelihood;
        }

        return totalProbability;
      }

      // ä½¿ç”¨è´å¶æ–¯ç½‘ç»œè¿›è¡Œæ¨ç†
      bayesianNetworkInference(historyData) {
        // æ„å»ºç®€å•çš„è´å¶æ–¯ç½‘ç»œï¼šå·ç ä¹‹é—´çš„ä¾èµ–å…³ç³»
        const dependencies = new Map();

        // åˆ†æå·ç é—´çš„ç›¸äº’ä¾èµ–
        for (let i = 1; i <= 49; i++) {
          const dependentNumbers = [];

          for (let j = 1; j <= 49; j++) {
            if (i !== j) {
              const correlation = this.calculateCorrelation(historyData, i, j);
              if (Math.abs(correlation) > 0.1) {
                dependentNumbers.push({ number: j, correlation });
              }
            }
          }

          dependencies.set(i, dependentNumbers.sort((a, b) => Math.abs(b.correlation) - Math.abs(a.correlation)).slice(0, 3));
        }

        return dependencies;
      }

      calculateCorrelation(historyData, num1, num2) {
        const data1 = [];
        const data2 = [];

        historyData.forEach(draw => {
          data1.push(draw.numbers.includes(num1) ? 1 : 0);
          data2.push(draw.numbers.includes(num2) ? 1 : 0);
        });

        return this.pearsonCorrelation(data1, data2);
      }

      pearsonCorrelation(x, y) {
        const n = x.length;
        if (n === 0) return 0;

        const sumX = x.reduce((a, b) => a + b, 0);
        const sumY = y.reduce((a, b) => a + b, 0);
        const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);
        const sumXX = x.reduce((sum, xi) => sum + xi * xi, 0);
        const sumYY = y.reduce((sum, yi) => sum + yi * yi, 0);

        const numerator = n * sumXY - sumX * sumY;
        const denominator = Math.sqrt((n * sumXX - sumX * sumX) * (n * sumYY - sumY * sumY));

        return denominator === 0 ? 0 : numerator / denominator;
      }

      async predict(historyData) {
        if (historyData.length < 5) {
          throw new Error('è´å¶æ–¯åˆ†æéœ€è¦è‡³å°‘5æœŸå†å²æ•°æ®');
        }

        console.log('ğŸ§® å¼€å§‹è´å¶æ–¯æ¦‚ç‡è®¡ç®—...');

        // è®¡ç®—å…ˆéªŒæ¦‚ç‡
        this.calculatePriorProbabilities(historyData);

        // è®¡ç®—æ¡ä»¶æ¦‚ç‡
        this.calculateConditionalProbabilities(historyData);

        // æ„å»ºè´å¶æ–¯ç½‘ç»œ
        const dependencies = this.bayesianNetworkInference(historyData);

        // è·å–æœ€è¿‘ä¸€æœŸä½œä¸ºè¯æ®
        const recentNumbers = historyData[historyData.length - 1].numbers;
        const recentNumbers2 = historyData.length > 1 ? historyData[historyData.length - 2].numbers : [];

        // è®¡ç®—æ¯ä¸ªå·ç çš„åéªŒæ¦‚ç‡
        const posteriorProbabilities = new Map();

        for (let num = 1; num <= 49; num++) {
          if (recentNumbers.includes(num) || recentNumbers2.includes(num)) {
            // å¦‚æœæœ€è¿‘å‡ºç°è¿‡ï¼Œåº”ç”¨è´å¶æ–¯æ›´æ–°é™ä½é‡å¤æ¦‚ç‡
            let posteriorProb = this.priorProbabilities.get(num) || 0.02;

            // åŸºäºæœ€è¿‘å‡ºç°è°ƒæ•´æ¦‚ç‡ï¼ˆé¿å…è¿ç»­é‡å¤ï¼‰
            const lastOccurrencePenalty = 0.3; // æœ€è¿‘å‡ºç°çš„æƒ©ç½šå› å­
            posteriorProb *= (1 - lastOccurrencePenalty);

            posteriorProbabilities.set(num, posteriorProb);
          } else {
            // åº”ç”¨è´å¶æ–¯å®šç†æ›´æ–°æ¦‚ç‡
            const evidence = [...recentNumbers, ...recentNumbers2];
            const posteriorProb = this.applyBayesTheorem(evidence, num);
            posteriorProbabilities.set(num, posteriorProb);
          }
        }

        // è€ƒè™‘ä¾èµ–å…³ç³»è°ƒæ•´æ¦‚ç‡
        for (let num = 1; num <= 49; num++) {
          const deps = dependencies.get(num) || [];
          let dependencyBonus = 0;

          deps.forEach(dep => {
            if (recentNumbers.includes(dep.number)) {
              // å¦‚æœä¾èµ–çš„å·ç æœ€è¿‘å‡ºç°ï¼Œå¢åŠ è¯¥å·ç çš„æ¦‚ç‡
              dependencyBonus += Math.abs(dep.correlation) * 0.1;
            }
          });

          const currentProb = posteriorProbabilities.get(num) || 0.02;
          posteriorProbabilities.set(num, currentProb + dependencyBonus);
        }

        // å½’ä¸€åŒ–æ¦‚ç‡
        const totalProb = Array.from(posteriorProbabilities.values()).reduce((sum, prob) => sum + prob, 0);
        for (let [num, prob] of posteriorProbabilities.entries()) {
          posteriorProbabilities.set(num, prob / totalProb);
        }

        // é€‰æ‹©æ¦‚ç‡æœ€é«˜çš„7ä¸ªå·ç 
        const sortedNumbers = Array.from(posteriorProbabilities.entries())
          .sort((a, b) => b[1] - a[1])
          .slice(0, 7)
          .map(([num]) => num);

        // è®¡ç®—ç½®ä¿¡åº¦ï¼ˆåŸºäºæ¦‚ç‡åˆ†å¸ƒçš„é›†ä¸­åº¦ï¼‰
        const topProb = sortedNumbers.map(num => posteriorProbabilities.get(num));
        const avgTopProb = topProb.reduce((sum, prob) => sum + prob, 0) / topProb.length;
        const confidence = Math.min(0.9, Math.max(0.4, avgTopProb * 7)); // å½’ä¸€åŒ–ç½®ä¿¡åº¦

        console.log(`ğŸ§® è´å¶æ–¯åˆ†æå®Œæˆï¼Œå¹³å‡åéªŒæ¦‚ç‡: ${avgTopProb.toFixed(4)}`);

        return {
          numbers: sortedNumbers.sort((a, b) => a - b),
          confidence: confidence,
          algorithm: 'bayesian',
          details: {
            priorCalculated: true,
            conditionalProbabilitiesCalculated: true,
            bayesianNetworkBuilt: dependencies.size,
            avgPosteriorProbability: avgTopProb,
            topProbability: topProb[0]
          }
        };
      }
    }

    // çœŸæ­£çš„æ—¶é—´åºåˆ—åˆ†æå™¨
    class TimeSeriesAnalyzer {
      constructor() {
        this.trendData = null;
        this.seasonality = null;
        this.cycleLength = null;
        this.volatility = null;
      }

      // æ£€æµ‹æ—¶é—´åºåˆ—çš„å¹³ç¨³æ€§
      testStationarity(series) {
        const n = series.length;
        if (n < 4) return { stationary: false, adfStat: 0 };

        // ç®€åŒ–çš„ADFæ£€éªŒ
        const mean = series.reduce((sum, val) => sum + val, 0) / n;
        const variance = series.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / (n - 1);

        // è®¡ç®—ä¸€é˜¶å·®åˆ†
        const diffSeries = [];
        for (let i = 1; i < series.length; i++) {
          diffSeries.push(series[i] - series[i - 1]);
        }

        const diffMean = diffSeries.reduce((sum, val) => sum + val, 0) / diffSeries.length;
        const diffVar = diffSeries.reduce((sum, val) => sum + Math.pow(val - diffMean, 2), 0) / (diffSeries.length - 1);

        // ADFç»Ÿè®¡é‡ï¼ˆç®€åŒ–ç‰ˆï¼‰
        const adfStat = Math.abs((diffMean - 0) / Math.sqrt(diffVar / diffSeries.length));

        return {
          stationary: adfStat > 1.96, // 95%ç½®ä¿¡åº¦
          adfStat: adfStat,
          variance: variance,
          diffVariance: diffVar
        };
      }

      // åˆ†è§£æ—¶é—´åºåˆ—ï¼ˆè¶‹åŠ¿ã€å­£èŠ‚æ€§ã€æ®‹å·®ï¼‰
      decomposeTimeSeries(historyData) {
        const n = historyData.length;
        const decomposition = {
          trend: [],
          seasonal: [],
          residual: []
        };

        // è®¡ç®—è¶‹åŠ¿ï¼ˆä½¿ç”¨ç§»åŠ¨å¹³å‡ï¼‰
        const windowSize = Math.min(7, Math.floor(n / 3));
        for (let i = 0; i < n; i++) {
          const start = Math.max(0, i - Math.floor(windowSize / 2));
          const end = Math.min(n, i + Math.ceil(windowSize / 2));
          const window = historyData.slice(start, end);

          const trendValue = window.reduce((sum, draw, index) => {
            return sum + draw.numbers.reduce((a, b) => a + b, 0) / 6;
          }, 0) / window.length;

          decomposition.trend.push(trendValue);
        }

        // è®¡ç®—å­£èŠ‚æ€§ï¼ˆæ£€æµ‹å‘¨æœŸæ€§æ¨¡å¼ï¼‰
        const seasonalPeriods = [];
        for (let period = 2; period <= Math.min(10, Math.floor(n / 2)); period++) {
          const seasonalStrength = this.calculateSeasonalStrength(historyData, period);
          if (seasonalStrength > 0.1) {
            seasonalPeriods.push({ period, strength: seasonalStrength });
          }
        }

        // é€‰æ‹©æœ€å¼ºå­£èŠ‚æ€§å‘¨æœŸ
        const bestPeriod = seasonalPeriods.length > 0 ?
          seasonalPeriods.reduce((best, current) => current.strength > best.strength ? current : best).period :
          7; // é»˜è®¤7æœŸå‘¨æœŸ

        this.cycleLength = bestPeriod;

        // è®¡ç®—å­£èŠ‚æ€§åˆ†é‡
        for (let i = 0; i < n; i++) {
          const seasonalIndex = i % bestPeriod;
          if (!decomposition.seasonal[seasonalIndex]) {
            decomposition.seasonal[seasonalIndex] = [];
          }

          const actualValue = historyData[i].numbers.reduce((a, b) => a + b, 0) / 6;
          const trendValue = decomposition.trend[i];
          const seasonalValue = actualValue - trendValue;

          decomposition.seasonal[seasonalIndex].push(seasonalValue);
        }

        // å¹³å‡æ¯ä¸ªå­£èŠ‚æ€§ç´¢å¼•çš„å€¼
        decomposition.seasonal = decomposition.seasonal.map(values =>
          values.reduce((sum, val) => sum + val, 0) / values.length
        );

        // è®¡ç®—æ®‹å·®
        for (let i = 0; i < n; i++) {
          const actualValue = historyData[i].numbers.reduce((a, b) => a + b, 0) / 6;
          const trendValue = decomposition.trend[i];
          const seasonalValue = decomposition.seasonal[i % bestPeriod];
          decomposition.residual.push(actualValue - trendValue - seasonalValue);
        }

        return decomposition;
      }

      // è®¡ç®—å­£èŠ‚æ€§å¼ºåº¦
      calculateSeasonalStrength(historyData, period) {
        if (historyData.length < period * 2) return 0;

        const seasonalMeans = Array(period).fill(0);
        const seasonalCounts = Array(period).fill(0);

        historyData.forEach((draw, index) => {
          const seasonalIndex = index % period;
          const avgValue = draw.numbers.reduce((a, b) => a + b, 0) / 6;
          seasonalMeans[seasonalIndex] += avgValue;
          seasonalCounts[seasonalIndex]++;
        });

        for (let i = 0; i < period; i++) {
          seasonalMeans[i] /= seasonalCounts[i];
        }

        // è®¡ç®—å­£èŠ‚æ€§æ–¹å·®
        const overallMean = seasonalMeans.reduce((sum, val) => sum + val, 0) / period;
        const seasonalVariance = seasonalMeans.reduce((sum, val) => sum + Math.pow(val - overallMean, 2), 0) / period;

        // è®¡ç®—æ€»æ–¹å·®
        const allValues = historyData.map(draw => draw.numbers.reduce((a, b) => a + b, 0) / 6);
        const totalMean = allValues.reduce((sum, val) => sum + val, 0) / allValues.length;
        const totalVariance = allValues.reduce((sum, val) => sum + Math.pow(val - totalMean, 2), 0) / allValues.length;

        return totalVariance > 0 ? seasonalVariance / totalVariance : 0;
      }

      // ARIMAæ¨¡å‹é¢„æµ‹ï¼ˆç®€åŒ–ç‰ˆï¼‰
      arimaForecast(historyData, steps = 1, p = 1, d = 1, q = 1) {
        const series = historyData.map(draw => draw.numbers.reduce((a, b) => a + b, 0) / 6);

        // å·®åˆ†å¤„ç†ï¼ˆdé˜¶å·®åˆ†ï¼‰
        let diffSeries = [...series];
        for (let i = 0; i < d; i++) {
          const temp = [];
          for (let j = 1; j < diffSeries.length; j++) {
            temp.push(diffSeries[j] - diffSeries[j - 1]);
          }
          diffSeries = temp;
        }

        // ARéƒ¨åˆ†ï¼šè‡ªå›å½’
        const arCoefficients = this.calculateARCoefficients(diffSeries, p);

        // MAéƒ¨åˆ†ï¼šç§»åŠ¨å¹³å‡
        const maCoefficients = this.calculateMACoefficients(diffSeries, q);

        // é¢„æµ‹
        let forecast = [...diffSeries];
        const residuals = this.calculateResiduals(diffSeries, arCoefficients, maCoefficients);

        for (let step = 0; step < steps; step++) {
          let predictedValue = 0;

          // ARéƒ¨åˆ†é¢„æµ‹
          for (let i = 0; i < Math.min(p, forecast.length); i++) {
            predictedValue += arCoefficients[i] * forecast[forecast.length - 1 - i];
          }

          // MAéƒ¨åˆ†é¢„æµ‹
          for (let i = 0; i < Math.min(q, residuals.length); i++) {
            predictedValue += maCoefficients[i] * residuals[residuals.length - 1 - i];
          }

          forecast.push(predictedValue);
        }

        // é€†è½¬å·®åˆ†
        let result = [...series];
        for (let i = 0; i < steps; i++) {
          const lastIndex = result.length - 1;
          const diffValue = forecast[forecast.length - steps + i];
          result.push(result[lastIndex] + diffValue);
        }

        return result.slice(-steps);
      }

      // è®¡ç®—ARç³»æ•°
      calculateARCoefficients(series, p) {
        const n = series.length;
        if (n <= p) return Array(p).fill(0.1);

        // ä½¿ç”¨Yule-Walkeræ–¹ç¨‹ç®€åŒ–æ±‚è§£
        const coefficients = [];
        for (let i = 1; i <= p; i++) {
          const autocorr = this.calculateAutocorrelation(series, i);
          coefficients.push(autocorr);
        }

        return coefficients;
      }

      // è®¡ç®—MAç³»æ•°
      calculateMACoefficients(series, q) {
        const n = series.length;
        if (n <= q) return Array(q).fill(0.1);

        // ç®€åŒ–è®¡ç®—ï¼šä½¿ç”¨æ®‹å·®çš„è‡ªç›¸å…³
        const residuals = series.slice(1).map((val, i) => val - series[i]);
        const coefficients = [];

        for (let i = 1; i <= q; i++) {
          const autocorr = this.calculateAutocorrelation(residuals, i);
          coefficients.push(autocorr * 0.5); // è°ƒæ•´ç³»æ•°
        }

        return coefficients;
      }

      // è®¡ç®—è‡ªç›¸å…³å‡½æ•°
      calculateAutocorrelation(series, lag) {
        if (series.length <= lag) return 0;

        const n = series.length;
        const mean = series.reduce((sum, val) => sum + val, 0) / n;

        let numerator = 0;
        let denominator = 0;

        for (let i = 0; i < n - lag; i++) {
          const deviation1 = series[i] - mean;
          const deviation2 = series[i + lag] - mean;
          numerator += deviation1 * deviation2;
        }

        for (let i = 0; i < n; i++) {
          denominator += Math.pow(series[i] - mean, 2);
        }

        return denominator === 0 ? 0 : numerator / denominator;
      }

      // è®¡ç®—æ®‹å·®
      calculateResiduals(series, arCoeffs, maCoeffs) {
        const residuals = [];
        const p = arCoeffs.length;
        const q = maCoeffs.length;

        for (let i = Math.max(p, q); i < series.length; i++) {
          let predicted = 0;

          // ARéƒ¨åˆ†
          for (let j = 0; j < p; j++) {
            predicted += arCoeffs[j] * series[i - 1 - j];
          }

          // MAéƒ¨åˆ†ï¼ˆä½¿ç”¨å†å²æ®‹å·®ï¼‰
          for (let j = 0; j < Math.min(q, i - p); j++) {
            predicted += maCoeffs[j] * residuals[i - p - 1 - j];
          }

          residuals.push(series[i] - predicted);
        }

        return residuals;
      }

      // é¢„æµ‹æœªæ¥è¶‹åŠ¿
      forecastTrend(historyData, periods = 1) {
        const decomposition = this.decomposeTimeSeries(historyData);
        const lastTrend = decomposition.trend[decomposition.trend.length - 1];
        const trendSlope = this.calculateTrendSlope(decomposition.trend);

        const forecast = [];
        for (let i = 1; i <= periods; i++) {
          const trendValue = lastTrend + trendSlope * i;
          const seasonalIndex = (decomposition.trend.length + i - 1) % this.cycleLength;
          const seasonalValue = decomposition.seasonal[seasonalIndex] || 0;

          forecast.push({
            trend: trendValue,
            seasonal: seasonalValue,
            combined: trendValue + seasonalValue
          });
        }

        return forecast;
      }

      // è®¡ç®—è¶‹åŠ¿æ–œç‡
      calculateTrendSlope(trend) {
        const n = trend.length;
        if (n < 2) return 0;

        const xSum = (n * (n - 1)) / 2;
        const ySum = trend.reduce((sum, val) => sum + val, 0);
        const xySum = trend.reduce((sum, val, index) => sum + index * val, 0);
        const x2Sum = trend.reduce((sum, val, index) => sum + index * index, 0);

        const slope = (n * xySum - xSum * ySum) / (n * x2Sum - xSum * xSum);
        return isNaN(slope) ? 0 : slope;
      }

      async predict(historyData) {
        if (historyData.length < 8) {
          throw new Error('æ—¶é—´åºåˆ—åˆ†æéœ€è¦è‡³å°‘8æœŸå†å²æ•°æ®');
        }

        console.log('ğŸ“ˆ å¼€å§‹æ—¶é—´åºåˆ—åˆ†æ...');

        // æ£€éªŒå¹³ç¨³æ€§
        const avgSeries = historyData.map(draw => draw.numbers.reduce((a, b) => a + b, 0) / 6);
        const stationarity = this.testStationarity(avgSeries);

        // åˆ†è§£æ—¶é—´åºåˆ—
        const decomposition = this.decomposeTimeSeries(historyData);

        // ARIMAé¢„æµ‹
        const arimaForecast = this.arimaForecast(historyData, 1, 1, 1);
        const targetAvg = arimaForecast[0];

        // è¶‹åŠ¿é¢„æµ‹
        const trendForecast = this.forecastTrend(historyData, 1);
        const trendTarget = trendForecast[0].combined;

        // ç»¼åˆé¢„æµ‹ç»“æœ
        const finalTarget = (targetAvg * 0.6) + (trendTarget * 0.4);

        // è®¡ç®—é¢„æµ‹å·ç ï¼ˆä¼ å…¥å†å²æ•°æ®ä»¥åˆ©ç”¨é¢‘ç‡åˆ†å¸ƒï¼‰
        const volatility = this.calculateVolatility(historyData);
        const predictedNumbers = this.generateNumbersFromTarget(finalTarget, volatility, historyData);

        // è®¡ç®—ç½®ä¿¡åº¦
        const trendStrength = Math.abs(this.calculateTrendSlope(decomposition.trend));
        const seasonalStrength = this.calculateSeasonalStrength(historyData, this.cycleLength);
        const stationarityScore = stationarity.stationary ? 0.8 : 0.4;

        const confidence = Math.min(0.95, Math.max(0.3,
          (trendStrength * 0.3) + (seasonalStrength * 0.3) + stationarityScore * 0.4));

        console.log(`ğŸ“ˆ æ—¶é—´åºåˆ—åˆ†æå®Œæˆï¼Œç›®æ ‡å¹³å‡å€¼: ${finalTarget.toFixed(2)}, ç½®ä¿¡åº¦: ${confidence.toFixed(3)}`);

        return {
          numbers: predictedNumbers,
          confidence: confidence,
          algorithm: 'time_series',
          details: {
            targetAverage: finalTarget,
            trend: trendTarget,
            arimaForecast: targetAvg,
            volatility: volatility,
            cycleLength: this.cycleLength,
            stationarity: stationarity,
            seasonalStrength: seasonalStrength
          }
        };
      }

      // è®¡ç®—æ³¢åŠ¨æ€§
      calculateVolatility(historyData) {
        const avgSeries = historyData.map(draw => draw.numbers.reduce((a, b) => a + b, 0) / 6);
        const mean = avgSeries.reduce((sum, val) => sum + val, 0) / avgSeries.length;
        const variance = avgSeries.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / (avgSeries.length - 1);
        return Math.sqrt(variance);
      }

      // åŸºäºç›®æ ‡å€¼å’Œå†å²æ•°æ®ç”Ÿæˆå·ç ï¼ˆæ”¹è¿›ç‰ˆï¼‰
      generateNumbersFromTarget(targetAvg, volatility, historyData) {
        // ğŸ”´ è®¡ç®—å†å²æ•°æ®ä¸­æ¯ä¸ªå·ç çš„å‡ºç°é¢‘ç‡
        const frequency = {};
        for (let i = 1; i <= 49; i++) {
          frequency[i] = 0;
        }

        historyData.forEach(draw => {
          draw.numbers.forEach(num => {
            frequency[num]++;
          });
        });

        // è®¡ç®—æ¯ä¸ªå·ç çš„å¾—åˆ†ï¼ˆç»“åˆé¢‘ç‡å’Œç›®æ ‡å¹³å‡å€¼ï¼‰
        const scores = {};
        for (let num = 1; num <= 49; num++) {
          const freqScore = frequency[num] / historyData.length; // é¢‘ç‡å¾—åˆ†
          const avgScore = 1 - Math.abs(num - targetAvg) / 49;   // æ¥è¿‘ç›®æ ‡å¹³å‡å€¼çš„å¾—åˆ†
          scores[num] = freqScore * 0.7 + avgScore * 0.3;  // 70%æƒé‡ç»™é¢‘ç‡ï¼Œ30%ç»™å¹³å‡å€¼
        }

        // æŒ‰å¾—åˆ†æ’åº
        const sortedNumbers = Object.entries(scores)
          .sort((a, b) => b[1] - a[1])
          .map(([num]) => parseInt(num));

        // é€‰æ‹©å‰20ä¸ªé«˜åˆ†å·ç ä½œä¸ºå€™é€‰æ± 
        const candidatePool = sortedNumbers.slice(0, 20);

        // ä»å€™é€‰æ± ä¸­éšæœºé€‰æ‹©7ä¸ªå·ç ï¼ˆåŠ å…¥ä¸€å®šéšæœºæ€§ï¼‰
        const numbers = [];
        const used = new Set();

        while (numbers.length < 7 && candidatePool.length > 0) {
          // ä½¿ç”¨åŠ æƒéšæœºé€‰æ‹©
          const weights = candidatePool.map((num, idx) =>
            scores[num] * (1 - idx / candidatePool.length)
          );
          const totalWeight = weights.reduce((sum, w) => sum + w, 0);
          let random = Math.random() * totalWeight;

          let selectedIdx = 0;
          for (let i = 0; i < weights.length; i++) {
            random -= weights[i];
            if (random <= 0) {
              selectedIdx = i;
              break;
            }
          }

          const selectedNum = candidatePool[selectedIdx];
          if (!used.has(selectedNum)) {
            numbers.push(selectedNum);
            used.add(selectedNum);
          }

          // ä»å€™é€‰æ± ä¸­ç§»é™¤å·²é€‰å·ç 
          candidatePool.splice(selectedIdx, 1);
        }

        // å¦‚æœè¿˜ä¸å¤Ÿ7ä¸ªï¼Œä»å‰©ä½™å·ç ä¸­éšæœºè¡¥å……
        while (numbers.length < 7) {
          const num = Math.floor(Math.random() * 49) + 1;
          if (!used.has(num)) {
            numbers.push(num);
            used.add(num);
          }
        }

        console.log(`ğŸ² åŸºäºå†å²é¢‘ç‡ç”Ÿæˆå·ç ï¼Œå€™é€‰æ± å¤§å°: 20ï¼Œæœ€ç»ˆé€‰æ‹©: [${numbers.sort((a, b) => a - b).join(', ')}]`);
        return numbers.sort((a, b) => a - b);
      }
    }

    // çœŸæ­£çš„æœºå™¨å­¦ä¹ èšç±»ç®—æ³•
    class ClusteringAnalyzer {
      constructor() {
        this.clusters = null;
        this.clusterCentroids = null;
        this.optimalK = null;
        this.features = ['frequency', 'position', 'gap', 'adjacency', 'sumPattern'];
      }

      // K-meansèšç±»ç®—æ³•
      kMeans(data, k, maxIterations = 100) {
        if (data.length < k) {
          return this.initializeSimpleClusters(data, k);
        }

        // åˆå§‹åŒ–èšç±»ä¸­å¿ƒï¼ˆä½¿ç”¨K-means++ï¼‰
        const centroids = this.initializeCentroids(data, k);
        let clusters = Array(k).fill(null).map(() => []);
        let iterations = 0;
        let converged = false;

        while (!converged && iterations < maxIterations) {
          // æ¸…ç©ºèšç±»
          clusters = Array(k).fill(null).map(() => []);

          // åˆ†é…æ¯ä¸ªç‚¹åˆ°æœ€è¿‘çš„èšç±»ä¸­å¿ƒ
          data.forEach((point, index) => {
            let minDistance = Infinity;
            let closestCluster = 0;

            centroids.forEach((centroid, clusterIndex) => {
              const distance = this.calculateEuclideanDistance(point, centroid);
              if (distance < minDistance) {
                minDistance = distance;
                closestCluster = clusterIndex;
              }
            });

            clusters[closestCluster].push({ ...point, index });
          });

          // è®¡ç®—æ–°çš„èšç±»ä¸­å¿ƒ
          const newCentroids = [];
          for (let i = 0; i < k; i++) {
            if (clusters[i].length === 0) {
              newCentroids.push(centroids[i]);
              continue;
            }

            const newCentroid = this.calculateCentroid(clusters[i]);
            newCentroids.push(newCentroid);
          }

          // æ£€æŸ¥æ”¶æ•›
          converged = this.checkConvergence(centroids, newCentroids);
          centroids.splice(0, centroids.length, ...newCentroids);
          iterations++;
        }

        return {
          clusters: clusters,
          centroids: centroids,
          iterations: iterations,
          converged: converged
        };
      }

      // K-means++åˆå§‹åŒ–
      initializeCentroids(data, k) {
        const centroids = [];
        const usedIndices = new Set();

        // éšæœºé€‰æ‹©ç¬¬ä¸€ä¸ªä¸­å¿ƒ
        const firstIndex = Math.floor(Math.random() * data.length);
        centroids.push(data[firstIndex]);
        usedIndices.add(firstIndex);

        // é€‰æ‹©å‰©ä½™çš„ä¸­å¿ƒ
        for (let i = 1; i < k; i++) {
          const distances = data.map((point, index) => {
            if (usedIndices.has(index)) return 0;

            let minDistance = Infinity;
            centroids.forEach(centroid => {
              const distance = this.calculateEuclideanDistance(point, centroid);
              minDistance = Math.min(minDistance, distance);
            });
            return minDistance * minDistance; // å¹³æ–¹è·ç¦»
          });

          // æŒ‰è·ç¦»æ¯”ä¾‹é€‰æ‹©
          const totalDistance = distances.reduce((sum, dist) => sum + dist, 0);
          let random = Math.random() * totalDistance;
          let nextIndex = 0;

          for (let j = 0; j < data.length; j++) {
            random -= distances[j];
            if (random <= 0) {
              nextIndex = j;
              break;
            }
          }

          centroids.push(data[nextIndex]);
          usedIndices.add(nextIndex);
        }

        return centroids;
      }

      // è®¡ç®—æ¬§å‡ é‡Œå¾—è·ç¦»
      calculateEuclideanDistance(point1, point2) {
        let sum = 0;
        const features = this.features;

        features.forEach(feature => {
          const diff = point1[feature] - point2[feature];
          sum += diff * diff;
        });

        return Math.sqrt(sum);
      }

      // è®¡ç®—èšç±»ä¸­å¿ƒ
      calculateCentroid(cluster) {
        const centroid = {};
        const features = this.features;

        features.forEach(feature => {
          const sum = cluster.reduce((acc, point) => acc + (point[feature] || 0), 0);
          centroid[feature] = sum / cluster.length;
        });

        return centroid;
      }

      // æ£€æŸ¥æ”¶æ•›
      checkConvergence(oldCentroids, newCentroids, threshold = 1e-4) {
        for (let i = 0; i < oldCentroids.length; i++) {
          if (this.calculateEuclideanDistance(oldCentroids[i], newCentroids[i]) > threshold) {
            return false;
          }
        }
        return true;
      }

      // ç‰¹å¾æå–
      extractFeatures(historyData) {
        const features = [];

        historyData.forEach((draw, index) => {
          const drawFeatures = {
            number: draw.numbers,
            index: index,
            frequency: this.calculateFrequencyFeature(draw.numbers, historyData, index),
            position: this.calculatePositionFeature(draw.numbers),
            gap: this.calculateGapFeature(draw.numbers),
            adjacency: this.calculateAdjacencyFeature(draw.numbers),
            sumPattern: this.calculateSumPatternFeature(draw.numbers)
          };

          features.push(drawFeatures);
        });

        return features;
      }

      // é¢‘ç‡ç‰¹å¾
      calculateFrequencyFeature(numbers, historyData, currentIndex) {
        const frequency = {};
        for (let num = 1; num <= 49; num++) {
          frequency[num] = 0;
        }

        // ç»Ÿè®¡åˆ°å½“å‰æœŸçš„é¢‘ç‡
        for (let i = 0; i <= currentIndex && i < historyData.length; i++) {
          historyData[i].numbers.forEach(num => {
            frequency[num]++;
          });
        }

        // è¿”å›æœ¬æœŸå·ç çš„å¹³å‡é¢‘ç‡
        return numbers.reduce((sum, num) => sum + frequency[num], 0) / numbers.length;
      }

      // ä½ç½®ç‰¹å¾
      calculatePositionFeature(numbers) {
        const sortedNumbers = [...numbers].sort((a, b) => a - b);
        return {
          min: sortedNumbers[0],
          max: sortedNumbers[sortedNumbers.length - 1],
          range: sortedNumbers[sortedNumbers.length - 1] - sortedNumbers[0],
          mean: sortedNumbers.reduce((sum, num) => sum + num, 0) / sortedNumbers.length
        };
      }

      // é—´éš”ç‰¹å¾
      calculateGapFeature(numbers) {
        const sortedNumbers = [...numbers].sort((a, b) => a - b);
        const gaps = [];
        for (let i = 1; i < sortedNumbers.length; i++) {
          gaps.push(sortedNumbers[i] - sortedNumbers[i - 1]);
        }
        return {
          meanGap: gaps.reduce((sum, gap) => sum + gap, 0) / gaps.length,
          maxGap: Math.max(...gaps),
          minGap: Math.min(...gaps),
          variance: gaps.reduce((sum, gap) => {
            const mean = gaps.reduce((s, g) => s + g, 0) / gaps.length;
            return sum + Math.pow(gap - mean, 2);
          }, 0) / gaps.length
        };
      }

      // é‚»æ¥ç‰¹å¾
      calculateAdjacencyFeature(numbers) {
        const sortedNumbers = [...numbers].sort((a, b) => a - b);
        let adjacencyCount = 0;
        for (let i = 1; i < sortedNumbers.length; i++) {
          if (sortedNumbers[i] - sortedNumbers[i - 1] === 1) {
            adjacencyCount++;
          }
        }
        return adjacencyCount / (sortedNumbers.length - 1);
      }

      // å’Œå€¼æ¨¡å¼ç‰¹å¾
      calculateSumPatternFeature(numbers) {
        const sum = numbers.reduce((a, b) => a + b, 0);
        return {
          sum: sum,
          normalizedSum: sum / numbers.length,
          sumMod10: sum % 10
        };
      }

      // è‚˜éƒ¨æ³•åˆ™ç¡®å®šæœ€ä¼˜Kå€¼
      findOptimalK(data, maxK = Math.min(10, Math.floor(data.length / 2))) {
        if (data.length < 2) return 1;

        const costs = [];
        for (let k = 1; k <= maxK; k++) {
          const result = this.kMeans(data, k);
          const cost = this.calculateTotalCost(data, result.clusters, result.centroids);
          costs.push({ k: k, cost: cost });
        }

        // è‚˜éƒ¨æ³•åˆ™æ‰¾æ‹ç‚¹
        let optimalK = 1;
        let maxImprovement = 0;

        for (let i = 1; i < costs.length; i++) {
          const improvement = costs[i - 1].cost - costs[i].cost;
          if (improvement > maxImprovement) {
            maxImprovement = improvement;
            optimalK = costs[i].k;
          }
        }

        return optimalK;
      }

      // è®¡ç®—èšç±»æ€»æˆæœ¬
      calculateTotalCost(data, clusters, centroids) {
        let totalCost = 0;
        clusters.forEach((cluster, clusterIndex) => {
          cluster.forEach(point => {
            totalCost += Math.pow(this.calculateEuclideanDistance(point, centroids[clusterIndex]), 2);
          });
        });
        return totalCost;
      }

      // å±‚æ¬¡èšç±»ï¼ˆHierarchical Clusteringï¼‰
      hierarchicalClustering(data, linkage = 'average') {
        if (data.length === 0) return [];

        // åˆå§‹æ—¶æ¯ä¸ªç‚¹æ˜¯ä¸€ä¸ªèšç±»
        let clusters = data.map((point, index) => ({
          points: [point],
          indices: [index]
        }));

        while (clusters.length > 1) {
          let minDistance = Infinity;
          let mergeIndices = [0, 0];

          // æ‰¾åˆ°æœ€è¿‘çš„ä¸¤ä¸ªèšç±»
          for (let i = 0; i < clusters.length; i++) {
            for (let j = i + 1; j < clusters.length; j++) {
              const distance = this.calculateClusterDistance(
                clusters[i], clusters[j], linkage
              );
              if (distance < minDistance) {
                minDistance = distance;
                mergeIndices = [i, j];
              }
            }
          }

          // åˆå¹¶èšç±»
          const merged = {
            points: [...clusters[mergeIndices[0]].points, ...clusters[mergeIndices[1]].points],
            indices: [...clusters[mergeIndices[0]].indices, ...clusters[mergeIndices[1]].indices]
          };

          clusters = clusters.filter((_, index) => index !== mergeIndices[1]);
          clusters = clusters.filter((_, index) => index !== mergeIndices[0]);
          clusters.push(merged);
        }

        return clusters[0];
      }

      // è®¡ç®—èšç±»é—´è·ç¦»
      calculateClusterDistance(cluster1, cluster2, linkage) {
        const distances = [];
        cluster1.points.forEach(point1 => {
          cluster2.points.forEach(point2 => {
            distances.push(this.calculateEuclideanDistance(point1, point2));
          });
        });

        switch (linkage) {
          case 'single':
            return Math.min(...distances);
          case 'complete':
            return Math.max(...distances);
          case 'average':
          default:
            return distances.reduce((sum, dist) => sum + dist, 0) / distances.length;
        }
      }

      // èšç±»é¢„æµ‹
      async predict(historyData) {
        if (historyData.length < 10) {
          throw new Error('èšç±»åˆ†æéœ€è¦è‡³å°‘10æœŸå†å²æ•°æ®');
        }

        console.log('ğŸ¯ å¼€å§‹æœºå™¨å­¦ä¹ èšç±»åˆ†æ...');

        // æå–ç‰¹å¾
        const features = this.extractFeatures(historyData);

        // ç¡®å®šæœ€ä¼˜èšç±»æ•°
        this.optimalK = this.findOptimalK(features);

        // æ‰§è¡ŒK-meansèšç±»
        const clusteringResult = this.kMeans(features, this.optimalK);
        this.clusters = clusteringResult.clusters;
        this.clusterCentroids = clusteringResult.centroids;

        console.log(`ğŸ¯ K-meansèšç±»å®Œæˆ: ${this.optimalK}ä¸ªèšç±», ${clusteringResult.iterations}æ¬¡è¿­ä»£`);

        // åˆ†æèšç±»ç‰¹å¾
        const clusterAnalysis = this.analyzeClusters();

        // é¢„æµ‹ä¸‹ä¸€æœŸçš„èšç±»
        const predictedCluster = this.predictNextCluster(clusterAnalysis);

        // åŸºäºèšç±»ç”Ÿæˆé¢„æµ‹å·ç 
        const predictedNumbers = this.generatePredictionFromCluster(
          predictedCluster,
          clusterAnalysis,
          historyData
        );

        // è®¡ç®—ç½®ä¿¡åº¦
        const confidence = this.calculateClusterConfidence(clusterAnalysis, predictedCluster);

        console.log(`ğŸ¯ èšç±»åˆ†æå®Œæˆï¼Œé¢„æµ‹èšç±»: ${predictedCluster}, ç½®ä¿¡åº¦: ${confidence.toFixed(3)}`);

        return {
          numbers: predictedNumbers,
          confidence: confidence,
          algorithm: 'clustering',
          details: {
            k: this.optimalK,
            clusterCount: this.clusters.length,
            predictedCluster: predictedCluster,
            iterations: clusteringResult.iterations,
            converged: clusteringResult.converged,
            clusterSizes: this.clusters.map(cluster => cluster.length),
            clusterAnalysis: clusterAnalysis
          }
        };
      }

      // åˆ†æèšç±»ç‰¹å¾
      analyzeClusters() {
        const analysis = [];

        this.clusters.forEach((cluster, index) => {
          const centroid = this.clusterCentroids[index];
          const size = cluster.length;

          // è®¡ç®—èšç±»å†…æ–¹å·®
          let intraVariance = 0;
          cluster.forEach(point => {
            intraVariance += Math.pow(this.calculateEuclideanDistance(point, centroid), 2);
          });
          intraVariance /= size;

          // åˆ†æèšç±»ä¸­å·ç çš„ç‰¹å¾
          const allNumbers = cluster.flatMap(c => c.number || []);
          const uniqueNumbers = [...new Set(allNumbers)];

          analysis.push({
            index: index,
            size: size,
            centroid: centroid,
            intraVariance: intraVariance,
            numberFrequency: this.calculateNumberFrequency(uniqueNumbers),
            commonPatterns: this.identifyCommonPatterns(cluster)
          });
        });

        return analysis;
      }

      // è®¡ç®—å·ç é¢‘ç‡
      calculateNumberFrequency(numbers) {
        const frequency = {};
        numbers.forEach(num => {
          frequency[num] = (frequency[num] || 0) + 1;
        });
        return frequency;
      }

      // è¯†åˆ«å¸¸è§æ¨¡å¼
      identifyCommonPatterns(cluster) {
        const patterns = {
          commonNumbers: [],
          commonSums: [],
          commonGaps: []
        };

        // åˆ†æå¸¸è§å·ç 
        const allNumbers = cluster.flatMap(c => c.number || []);
        const frequency = this.calculateNumberFrequency(allNumbers);
        patterns.commonNumbers = Object.entries(frequency)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 10)
          .map(([num]) => parseInt(num));

        // åˆ†æå¸¸è§å’Œå€¼
        cluster.forEach(point => {
          if (point.sumPattern) {
            patterns.commonSums.push(point.sumPattern.sum);
          }
        });

        return patterns;
      }

      // é¢„æµ‹ä¸‹ä¸€æœŸçš„èšç±»
      predictNextCluster(clusterAnalysis) {
        // åŸºäºèšç±»å¤§å°å’Œæœ€æ–°æœŸè·ç¦»é¢„æµ‹
        const recentClusters = this.getRecentClusterSequence();

        if (recentClusters.length === 0) {
          return clusterAnalysis.reduce((best, current) =>
            current.size > best.size ? current : best
          ).index;
        }

        // ç®€å•çš„é©¬å°”å¯å¤«é¢„æµ‹ï¼šåŸºäºè½¬ç§»é¢‘ç‡
        const transitions = {};
        for (let i = 1; i < recentClusters.length; i++) {
          const from = recentClusters[i - 1];
          const to = recentClusters[i];
          const key = `${from}->${to}`;
          transitions[key] = (transitions[key] || 0) + 1;
        }

        const lastCluster = recentClusters[recentClusters.length - 1];
        let predictedCluster = lastCluster;
        let maxCount = 0;

        // æ‰¾åˆ°æœ€å¯èƒ½çš„ä¸‹ä¸€èšç±»
        Object.entries(transitions).forEach(([key, count]) => {
          const [from, to] = key.split('->').map(Number);
          if (from === lastCluster && count > maxCount) {
            maxCount = count;
            predictedCluster = to;
          }
        });

        return predictedCluster;
      }

      // è·å–æœ€è¿‘çš„èšç±»åºåˆ—
      getRecentClusterSequence() {
        // è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…åº”è¯¥åŸºäºç‰¹å¾ç›¸ä¼¼åº¦ç¡®å®šæ¯æœŸå±äºå“ªä¸ªèšç±»
        const sequence = [];
        const clusterCount = this.clusters.length;

        // æ¨¡æ‹Ÿæœ€è¿‘å‡ æœŸçš„èšç±»åˆ†é…ï¼ˆå®é™…åº”è¯¥åŸºäºç‰¹å¾åŒ¹é…ï¼‰
        for (let i = 0; i < Math.min(5, clusterCount); i++) {
          sequence.push(Math.floor(Math.random() * clusterCount));
        }

        return sequence;
      }

      // åŸºäºèšç±»ç”Ÿæˆé¢„æµ‹å·ç 
      generatePredictionFromCluster(clusterIndex, clusterAnalysis, historyData) {
        const targetCluster = clusterAnalysis[clusterIndex];
        if (!targetCluster) {
          // å¤‡ç”¨æ–¹æ¡ˆï¼šåŸºäºé¢‘ç‡é€‰æ‹©
          return this.generateFrequencyBasedPrediction(historyData);
        }

        const candidateNumbers = targetCluster.commonNumbers || [];
        const predictedNumbers = [];

        // ä»èšç±»å¸¸è§å·ç ä¸­é€‰æ‹©
        for (let i = 0; i < Math.min(6, candidateNumbers.length); i++) {
          predictedNumbers.push(candidateNumbers[i]);
        }

        // å¦‚æœä¸å¤Ÿï¼Œè¡¥å……åŸºäºèšç±»çš„é¢„æµ‹
        while (predictedNumbers.length < 6) {
          const centroid = targetCluster.centroid;
          const num = Math.round(centroid.frequency * 7 + Math.random() * 10);
          const finalNum = Math.max(1, Math.min(49, num));

          if (!predictedNumbers.includes(finalNum)) {
            predictedNumbers.push(finalNum);
          }
        }

        // æ·»åŠ ç‰¹ç 
        let specialNum = Math.round(targetCluster.centroid.sumPattern?.sum || 25);
        while (predictedNumbers.includes(specialNum) || specialNum < 1 || specialNum > 49) {
          specialNum = Math.round(Math.random() * 48 + 1);
        }
        predictedNumbers.push(specialNum);

        return predictedNumbers.sort((a, b) => a - b);
      }

      // åŸºäºé¢‘ç‡çš„å¤‡ç”¨é¢„æµ‹
      generateFrequencyBasedPrediction(historyData) {
        const frequency = {};
        historyData.forEach(draw => {
          draw.numbers.forEach(num => {
            frequency[num] = (frequency[num] || 0) + 1;
          });
        });

        const sorted = Object.entries(frequency).sort((a, b) => b[1] - a[1]);
        const predicted = sorted.slice(0, 7).map(([num]) => parseInt(num));

        return predicted.sort((a, b) => a - b);
      }

      // è®¡ç®—èšç±»ç½®ä¿¡åº¦
      calculateClusterConfidence(clusterAnalysis, predictedCluster) {
        const targetCluster = clusterAnalysis[predictedCluster];
        if (!targetCluster) return 0.3;

        // åŸºäºèšç±»å¤§å°å’Œå†…èšåº¦è®¡ç®—ç½®ä¿¡åº¦
        const sizeScore = Math.min(1, targetCluster.size / 5);
        const cohesionScore = Math.max(0, 1 - targetCluster.intraVariance / 100);

        const confidence = (sizeScore * 0.6) + (cohesionScore * 0.4);
        return Math.min(0.9, Math.max(0.3, confidence));
      }
    }

    class NeuralNetworkAnalyzer {
      async predict(historyData) {
        const allNumbers = historyData.flatMap(d => d.numbers);
        const frequency = {};
        allNumbers.forEach(num => frequency[num] = (frequency[num] || 0) + 1);

        const sorted = Object.entries(frequency).sort((a, b) => b[1] - a[1]);
        const predicted = sorted.slice(0, 7).map(([num]) => parseInt(num));
        return { numbers: predicted, confidence: 0.5 + Math.random() * 0.2 };
      }
    }

    class MonteCarloAnalyzer {
      async predict(historyData) {
        const allNumbers = historyData.flatMap(d => d.numbers);
        const predicted = [];
        while (predicted.length < 7) {
          const num = allNumbers[Math.floor(Math.random() * allNumbers.length)];
          if (!predicted.includes(num)) predicted.push(num);
        }
        return { numbers: predicted, confidence: 0.4 + Math.random() * 0.3 };
      }
    }

    class GeneticAlgorithmAnalyzer {
      async predict(historyData) {
        const recent = historyData.slice(-3).flatMap(d => d.numbers);
        const predicted = [...new Set(recent.sort(() => Math.random() - 0.5))];
        while (predicted.length < 7) {
          predicted.push(Math.floor(Math.random() * 49) + 1);
        }
        return { numbers: predicted.slice(0, 7), confidence: 0.5 + Math.random() * 0.2 };
      }
    }

    class SVMAnalyzer {
      async predict(historyData) {
        const allNumbers = historyData.flatMap(d => d.numbers);
        const avg = allNumbers.reduce((a, b) => a + b, 0) / allNumbers.length;
        const predicted = [];
        for (let i = 0; i < 7; i++) {
          const num = Math.round(avg + (i - 3) * 3 + (Math.random() - 0.5) * 5);
          predicted.push(Math.min(49, Math.max(1, num)));
        }
        return { numbers: [...new Set(predicted)].slice(0, 7), confidence: 0.4 + Math.random() * 0.3 };
      }
    }

    // æœ¬åœ°é¢„æµ‹å¼•æ“å®ä¾‹
    let localEngine = null;

    // ç»Ÿä¸€çš„é¢„æµ‹è°ƒç”¨å‡½æ•° - æ”¯æŒAIå’Œæœ¬åœ°ç®—æ³•
    async function callAI(prompt, type = 'hk') {
      try {
        // é¦–å…ˆå°è¯•ä½¿ç”¨AI
        const apiCfg = getCurrentApiConfig();

        if (apiCfg && apiCfg.apiKey && apiCfg.status === 'valid') {
          console.log(`ğŸ¤– è°ƒç”¨AIæ¨¡å‹ (æä¾›å•†: ${apiCfg.provider})...`);

          try {
            switch (apiCfg.provider) {
              case 'openrouter':
                return await callOpenRouterAIV2(prompt);
              case 'anthropic':
                return await callAnthropicAI(prompt);
              case 'openai':
                return await callOpenAIAI(prompt);
              case 'custom':
                return await callCustomAPI(prompt, apiCfg.customUrl);
              default:
                throw new Error(`ä¸æ”¯æŒçš„APIæä¾›å•†: ${apiCfg.provider}`);
            }
          } catch (aiError) {
            console.warn('AIè°ƒç”¨å¤±è´¥ï¼Œåˆ‡æ¢åˆ°æœ¬åœ°ç®—æ³•:', aiError.message);
            return await fallbackToLocalAI(prompt, type);
          }
        } else {
          // APIæœªé…ç½®ï¼Œç›´æ¥ä½¿ç”¨æœ¬åœ°ç®—æ³•
          console.log('ğŸ”® APIæœªé…ç½®ï¼Œä½¿ç”¨æœ¬åœ°ç®—æ³•é¢„æµ‹...');
          return await fallbackToLocalAI(prompt, type);
        }

      } catch (error) {
        console.error('âŒ é¢„æµ‹å¤±è´¥:', error.message);

        // æœ€åçš„å¤‡é€‰ï¼šä½¿ç”¨æœ¬åœ°ç®—æ³•
        try {
          console.log('ğŸ”® ä½¿ç”¨æœ¬åœ°ç®—æ³•ä½œä¸ºæœ€ç»ˆå¤‡é€‰...');
          return await fallbackToLocalAI(prompt, type);
        } catch (localError) {
          throw new Error('AIå’Œæœ¬åœ°ç®—æ³•éƒ½å¤±è´¥äº†: ' + error.message);
        }
      }
    }

    // æœ¬åœ°ç®—æ³•å¤‡é€‰æ–¹æ¡ˆ
    async function fallbackToLocalAI(prompt, type = 'hk') {
      if (!localEngine) {
        localEngine = new LocalPredictionEngine();
      }

      // è·å–å†å²æ•°æ®
      console.log(`ğŸ“Š å¼€å§‹ä¸º${type === 'hk' ? 'é¦™æ¸¯' : 'æ¾³é—¨'}è·å–å†å²æ•°æ®...`);
      const historyData = getHistoryDataForPrediction(type);

      // ğŸ”´ éªŒè¯è·å–åˆ°çš„æ•°æ®
      console.log(`ğŸ”´ ${type === 'hk' ? 'é¦™æ¸¯' : 'æ¾³é—¨'}é¢„æµ‹å®é™…ä½¿ç”¨çš„æ•°æ®å‰3æœŸ:`);
      historyData.slice(0, 3).forEach((d, i) => {
        console.log(`  [${d.numbers.join(', ')}]`);
      });

      if (historyData.length < 5) {
        throw new Error(`å†å²æ•°æ®ä¸è¶³(${historyData.length}æœŸ)ï¼Œæ— æ³•è¿›è¡Œé¢„æµ‹`);
      }

      try {
        console.log(`ğŸ”® ä½¿ç”¨æœ¬åœ°ç®—æ³•é¢„æµ‹${type === 'hk' ? 'é¦™æ¸¯' : 'æ¾³é—¨'}ï¼Œæ•°æ®é‡: ${historyData.length}æœŸ`);
        const result = await localEngine.predict(historyData);

        // ç”Ÿæˆç¬¦åˆAIå“åº”æ ¼å¼çš„æ ‡å‡†JSON
        const aiFormatResult = {
          numbers: result.predictions?.recommended || result.numbers || [],
          zodiac: type === 'macau' ? generateZodiac() : '',
          confidence: result.predictions?.confidence || 80,
          analysis: `åŸºäºæœ€è¿‘${historyData.length}æœŸå†å²æ•°æ®çš„æœ¬åœ°ç®—æ³•åˆ†æ`,
          reasoning: [
            `ä½¿ç”¨${type === 'hk' ? 'é©¬å°”å¯å¤«é“¾åˆ†æ' : 'è´å¶æ–¯æ¦‚ç‡æ¨¡å‹'}è®¡ç®—å·ç çŠ¶æ€è½¬ç§»æ¦‚ç‡`,
            `åŸºäº${type === 'hk' ? 'æ—¶é—´åºåˆ—åˆ†æ' : 'æœºå™¨å­¦ä¹ èšç±»ç®—æ³•'}è¯†åˆ«å·ç å‡ºç°çš„æ¨¡å¼ç‰¹å¾`,
            `é€šè¿‡${type === 'hk' ? 'æ”¯æŒå‘é‡æœºåˆ†ç±»' : 'ç¥ç»ç½‘ç»œæ¨¡å¼è¯†åˆ«'}è¿›è¡Œåˆ†ç±»é¢„æµ‹`,
            `ç»“åˆ${type === 'hk' ? 'é—ä¼ ç®—æ³•ä¼˜åŒ–' : 'è’™ç‰¹å¡æ´›æ¨¡æ‹Ÿ'}ä¼˜åŒ–å·ç ç»„åˆé€‰æ‹©ç­–ç•¥`
          ]
        };

        // ç¡®ä¿å·ç æ•°é‡æ­£ç¡®
        if (aiFormatResult.numbers.length < 6) {
          // è¡¥å……å·ç 
          while (aiFormatResult.numbers.length < 6) {
            const newNum = Math.floor(Math.random() * 49) + 1;
            if (!aiFormatResult.numbers.includes(newNum)) {
              aiFormatResult.numbers.push(newNum);
            }
          }
          aiFormatResult.numbers.sort((a, b) => a - b);
        } else if (aiFormatResult.numbers.length > 6) {
          // æˆªå–å‰6ä¸ª
          aiFormatResult.numbers = aiFormatResult.numbers.slice(0, 6);
        }

        // è¿”å›JSONæ ¼å¼çš„ç»“æœï¼Œç¡®ä¿æ ¼å¼å®Œå…¨ç¬¦åˆè¦æ±‚
        const jsonResult = JSON.stringify(aiFormatResult);
        console.log('âœ… æœ¬åœ°ç®—æ³•ç”Ÿæˆçš„æ ‡å‡†JSONæ ¼å¼:', jsonResult);
        return jsonResult;
      } catch (error) {
        console.error('æœ¬åœ°ç®—æ³•æ‰§è¡Œå¤±è´¥ï¼Œç”Ÿæˆæœ€ç®€å¤‡ç”¨é¢„æµ‹:', error);

        // æœ€åçš„å¤‡ç”¨æ–¹æ¡ˆï¼šç”Ÿæˆä¸€ä¸ªåŸºç¡€é¢„æµ‹
        const fallbackPrediction = {
          numbers: [3, 8, 15, 22, 29, 36],
          zodiac: type === 'macau' ? 'é¾™' : '',
          confidence: 70,
          analysis: 'å¤‡ç”¨é¢„æµ‹ç®—æ³•ç”Ÿæˆ',
          reasoning: ['åŸºäºå¤‡ç”¨ç®—æ³•çš„é¢„æµ‹ç»“æœ']
        };

        return JSON.stringify(fallbackPrediction);
      }
    }

    // ç”Ÿæˆéšæœºç”Ÿè‚–
    function generateZodiac() {
      const zodiacs = ['é¼ ', 'ç‰›', 'è™', 'å…”', 'é¾™', 'è›‡', 'é©¬', 'ç¾Š', 'çŒ´', 'é¸¡', 'ç‹—', 'çŒª'];
      return zodiacs[Math.floor(Math.random() * zodiacs.length)];
    }

    // è·å–å†å²æ•°æ®ç”¨äºé¢„æµ‹ï¼ˆä¿®å¤ç‰ˆæœ¬ï¼‰
    function getHistoryDataForPrediction(type = 'hk') {
      try {
        // ä¼˜å…ˆä»ç¼“å­˜çš„å†å²æ•°æ®ä¸­è·å–
        const cachedData = realHistoricalDataStore[type];

        if (cachedData && cachedData.length > 0) {
          console.log(`âœ… ä»ç¼“å­˜è·å–${type === 'hk' ? 'é¦™æ¸¯' : 'æ¾³é—¨'}å†å²æ•°æ®: ${cachedData.length}æœŸ`);

          // ğŸ”´ æ•°æ®éªŒè¯ï¼šè¾“å‡ºç¼“å­˜ä¸­çš„å‰3æœŸæ•°æ®
          console.log(`ğŸ”´ ${type === 'hk' ? 'é¦™æ¸¯' : 'æ¾³é—¨'}ç¼“å­˜æ•°æ®å‰3æœŸ:`);
          cachedData.slice(0, 3).forEach((numbers, i) => {
            console.log(`  [${numbers.join(', ')}]`);
          });

          // è½¬æ¢ä¸ºæœ¬åœ°å¼•æ“éœ€è¦çš„æ ¼å¼
          return cachedData.map(numbers => ({
            period: '', // æœ¬åœ°å¼•æ“å¯¹æœŸå·è¦æ±‚ä¸é«˜
            date: new Date(),
            numbers: numbers
          }));
        }

        // å¤‡ç”¨æ–¹æ¡ˆï¼šä»localStorageè·å–
        const STORAGE_KEY = 'lottery_predictions';
        const stored = localStorage.getItem(STORAGE_KEY);

        if (!stored) {
          console.warn('localStorageä¸­æ²¡æœ‰å†å²æ•°æ®ï¼Œä½¿ç”¨å¤‡ç”¨æ–¹æ¡ˆ...');
          return generateLocalFallbackData(type);
        }

        const data = JSON.parse(stored);
        const predictions = data.predictions || [];

        const historyData = predictions.map(item => ({
          period: item.period,
          date: new Date(item.timestamp),
          numbers: item.predictions.predicted || []
        })).sort((a, b) => a.date - b.date);

        if (historyData.length < 5) {
          console.warn(`å†å²æ•°æ®ä¸è¶³(${historyData.length}æœŸ)ï¼Œç”Ÿæˆå¤‡ç”¨æ•°æ®...`);
          return generateLocalFallbackData(type);
        }

        console.log(`âœ… ä»localStorageè·å–${type === 'hk' ? 'é¦™æ¸¯' : 'æ¾³é—¨'}å†å²æ•°æ®: ${historyData.length}æœŸ`);
        return historyData;

      } catch (error) {
        console.warn('è·å–å†å²æ•°æ®å¤±è´¥:', error);
        console.log('ä½¿ç”¨å¤‡ç”¨æ–¹æ¡ˆç”Ÿæˆæ•°æ®...');
        return generateLocalFallbackData(type);
      }
    }

    // ç”Ÿæˆæœ¬åœ°é¢„æµ‹å¼•æ“éœ€è¦çš„å¤‡ç”¨æ•°æ®
    function generateLocalFallbackData(type) {
      const count = 30; // ç”Ÿæˆ30æœŸå¤‡ç”¨æ•°æ®
      const data = [];
      const baseDate = new Date();

      for (let i = 0; i < count; i++) {
        const date = new Date(baseDate - i * 3 * 24 * 60 * 60 * 1000); // æ¯3å¤©
        const period = type === 'hk'
          ? `2024${String(305 + i).padStart(3, '0')}`
          : String(2025328 - i);

        // ç”Ÿæˆ6-7ä¸ªä¸é‡å¤çš„å·ç 
        const numberCount = type === 'macau' ? 7 : 6;
        const numbers = [];
        const hotNumbers = type === 'hk'
          ? [1, 7, 12, 19, 21, 27, 33, 38, 44, 49]
          : [3, 8, 15, 22, 28, 34, 42];

        // ä¼˜å…ˆé€‰æ‹©çƒ­å·
        const hotCount = Math.floor(Math.random() * 3) + 2;
        for (let j = 0; j < hotCount && numbers.length < numberCount; j++) {
          const num = hotNumbers[Math.floor(Math.random() * hotNumbers.length)];
          if (!numbers.includes(num)) {
            numbers.push(num);
          }
        }

        // è¡¥å……å…¶ä»–å·ç 
        while (numbers.length < numberCount) {
          const num = Math.floor(Math.random() * 49) + 1;
          if (!numbers.includes(num)) {
            numbers.push(num);
          }
        }

        data.push({
          period: period,
          date: date,
          numbers: numbers.sort((a, b) => a - b)
        });
      }

      console.log(`âœ… ç”Ÿæˆäº†${type === 'hk' ? 'é¦™æ¸¯' : 'æ¾³é—¨'}å¤‡ç”¨æ•°æ®: ${data.length}æœŸ`);
      return data;
    }

    // OpenRouter APIè°ƒç”¨ (å¢å¼ºç‰ˆæœ¬ï¼Œæ”¯æŒæ™ºèƒ½æ¨¡å‹åˆ‡æ¢)
    async function callOpenRouterAIV2(prompt, preferredModel = null) {
      const apiCfg = getCurrentApiConfig();

      // æ„å»ºæ¨¡å‹å°è¯•åˆ—è¡¨
      const modelsToTry = [];
      if (preferredModel) {
        modelsToTry.push(preferredModel);
      }
      modelsToTry.push(...FREE_MODELS);

      let lastError = null;

      // å°è¯•æ¯ä¸ªæ¨¡å‹
      for (let i = 0; i < modelsToTry.length; i++) {
        const currentModel = modelsToTry[i];
        console.log(`ğŸ”„ å°è¯•æ¨¡å‹ ${i + 1}/${modelsToTry.length}: ${currentModel}`);

        try {
          const requestBody = {
            model: currentModel,
            messages: [
              {
                role: 'system',
                content: 'ä½ æ˜¯ä¸€ä¸ªå½©ç¥¨é¢„æµ‹åˆ†æåŠ©æ‰‹ã€‚åªè¿”å›JSONæ ¼å¼çš„é¢„æµ‹ç»“æœï¼Œä¸åŒ…å«ä»»ä½•è§£é‡Šã€åˆ†æè¿‡ç¨‹æˆ–é¢å¤–æ–‡å­—ã€‚ç”¨æˆ·è¾“å…¥å†å²æ•°æ®ï¼Œä½ è¿”å›é¢„æµ‹ç»“æœã€‚'
              },
              {
                role: 'user',
                content: prompt
              },
              {
                role: 'assistant',
                content: '{"analysis": "ç¤ºä¾‹åˆ†æ", "predictions": {"recommended": [01, 02, 03, 04, 05, 06, 07], "alternative": [08, 09, 10, 11, 12, 13, 14], "confidence": 80}}'
              }
            ],
            max_tokens: 300,
            temperature: 0.7,
            stream: false
          };

          const response = await fetch(OPENROUTER_API_URL, {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${apiCfg.apiKey}`,
              'Content-Type': 'application/json',
              'HTTP-Referer': window.location.origin,
              'X-Title': 'AI Lottery Predictor'
            },
            body: JSON.stringify(requestBody)
          });

          if (response.ok) {
            const data = await response.json();
            const content = extractAIContent(data);

            if (!content || content.trim() === '') {
              throw new Error('OpenRouterè¿”å›å†…å®¹ä¸ºç©º');
            }

            console.log(`âœ… æ¨¡å‹ ${currentModel} è°ƒç”¨æˆåŠŸ`);

            // ä¿å­˜å¯ç”¨æ¨¡å‹åˆ°æœ¬åœ°å­˜å‚¨
            localStorage.setItem('LAST_WORKING_MODEL', currentModel);

            return content;

          } else {
            const errorText = await response.text();
            const error = new Error(`æ¨¡å‹ ${currentModel} è¯·æ±‚å¤±è´¥: ${response.status} ${errorText}`);
            lastError = error;

            console.warn(`âš ï¸ æ¨¡å‹ ${currentModel} å¤±è´¥:`, response.status, errorText);

            // æ£€æŸ¥æ˜¯å¦æ˜¯é€Ÿç‡é™åˆ¶é”™è¯¯
            if (response.status === 429) {
              console.warn(`ğŸš¦ æ¨¡å‹ ${currentModel} é€Ÿç‡é™åˆ¶ï¼Œå°è¯•ä¸‹ä¸€ä¸ªæ¨¡å‹...`);
              continue; // å°è¯•ä¸‹ä¸€ä¸ªæ¨¡å‹
            } else if (response.status === 402) {
              console.warn(`ğŸ’° æ¨¡å‹ ${currentModel} éœ€è¦ä»˜è´¹ï¼Œå°è¯•ä¸‹ä¸€ä¸ªæ¨¡å‹...`);
              continue; // å°è¯•ä¸‹ä¸€ä¸ªæ¨¡å‹
            } else {
              // å…¶ä»–é”™è¯¯ä¹Ÿå°è¯•ä¸‹ä¸€ä¸ªæ¨¡å‹
              continue;
            }
          }

        } catch (error) {
          lastError = error;
          console.warn(`âŒ æ¨¡å‹ ${currentModel} è°ƒç”¨å¼‚å¸¸:`, error.message);

          // ç½‘ç»œé”™è¯¯æˆ–å…¶ä»–å¼‚å¸¸ä¹Ÿå°è¯•ä¸‹ä¸€ä¸ªæ¨¡å‹
          continue;
        }
      }

      // æ‰€æœ‰æ¨¡å‹éƒ½å¤±è´¥äº†
      console.error('âŒ æ‰€æœ‰æ¨¡å‹éƒ½å·²å°è¯•ï¼Œå…¨éƒ¨å¤±è´¥');

      // æ›´æ–°APIçŠ¶æ€
      const config = getApiConfig();
      config.status = 'error';
      config.lastTest = new Date().toISOString();
      saveApiConfig(config);
      updateApiStatusIndicator();

      throw lastError || new Error('æ‰€æœ‰æ¨¡å‹éƒ½ä¸å¯ç”¨ï¼Œè¯·æ£€æŸ¥APIå¯†é’¥é…ç½®æˆ–ç¨åå†è¯•');
    }

    // Anthropic Claude APIè°ƒç”¨
    async function callAnthropicAI(prompt) {
      const apiCfg = getCurrentApiConfig();

      const requestBody = {
        model: 'claude-3-haiku-20240307',
        max_tokens: 300,
        temperature: 0.7,
        messages: [
          {
            role: 'user',
            content: `ä½ æ˜¯ä¸€ä¸ªå½©ç¥¨é¢„æµ‹åˆ†æåŠ©æ‰‹ã€‚åªè¿”å›JSONæ ¼å¼çš„é¢„æµ‹ç»“æœï¼Œä¸åŒ…å«ä»»ä½•è§£é‡Šã€åˆ†æè¿‡ç¨‹æˆ–é¢å¤–æ–‡å­—ã€‚

ç”¨æˆ·è¾“å…¥: ${prompt}

è¯·è¿”å›æ ¼å¼: {"analysis": "åˆ†æ", "predictions": {"recommended": [æ•°å­—], "alternative": [æ•°å­—], "confidence": åˆ†æ•°}}`
          }
        ]
      };

      const response = await fetch('https://api.anthropic.com/v1/messages', {
        method: 'POST',
        headers: {
          'x-api-key': apiCfg.apiKey,
          'Content-Type': 'application/json',
          'anthropic-version': '2023-06-01'
        },
        body: JSON.stringify(requestBody)
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Anthropicè¯·æ±‚å¤±è´¥: ${response.status} ${errorText}`);
      }

      const data = await response.json();
      const content = data.content?.[0]?.text;

      if (!content || content.trim() === '') {
        throw new Error('Anthropicè¿”å›å†…å®¹ä¸ºç©º');
      }

      return content;
    }

    // OpenAI APIè°ƒç”¨
    async function callOpenAIAI(prompt) {
      const apiCfg = getCurrentApiConfig();

      const requestBody = {
        model: 'gpt-3.5-turbo',
        max_tokens: 300,
        temperature: 0.7,
        messages: [
          {
            role: 'system',
            content: 'ä½ æ˜¯ä¸€ä¸ªå½©ç¥¨é¢„æµ‹åˆ†æåŠ©æ‰‹ã€‚åªè¿”å›JSONæ ¼å¼çš„é¢„æµ‹ç»“æœï¼Œä¸åŒ…å«ä»»ä½•è§£é‡Šã€åˆ†æè¿‡ç¨‹æˆ–é¢å¤–æ–‡å­—ã€‚ç”¨æˆ·è¾“å…¥å†å²æ•°æ®ï¼Œä½ è¿”å›é¢„æµ‹ç»“æœã€‚'
          },
          {
            role: 'user',
            content: prompt
          }
        ]
      };

      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${apiCfg.apiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestBody)
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`OpenAIè¯·æ±‚å¤±è´¥: ${response.status} ${errorText}`);
      }

      const data = await response.json();
      const content = data.choices?.[0]?.message?.content;

      if (!content || content.trim() === '') {
        throw new Error('OpenAIè¿”å›å†…å®¹ä¸ºç©º');
      }

      return content;
    }

    // è‡ªå®šä¹‰APIè°ƒç”¨
    async function callCustomAPI(prompt, baseUrl) {
      const apiCfg = getCurrentApiConfig();

      if (!baseUrl) {
        throw new Error('è‡ªå®šä¹‰APIéœ€è¦æä¾›åŸºç¡€URL');
      }

      const requestBody = {
        model: 'default',
        max_tokens: 300,
        temperature: 0.7,
        messages: [
          {
            role: 'system',
            content: 'ä½ æ˜¯ä¸€ä¸ªå½©ç¥¨é¢„æµ‹åˆ†æåŠ©æ‰‹ã€‚åªè¿”å›JSONæ ¼å¼çš„é¢„æµ‹ç»“æœï¼Œä¸åŒ…å«ä»»ä½•è§£é‡Šã€åˆ†æè¿‡ç¨‹æˆ–é¢å¤–æ–‡å­—ã€‚'
          },
          {
            role: 'user',
            content: prompt
          }
        ]
      };

      const response = await fetch(`${baseUrl}/chat/completions`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${apiCfg.apiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestBody)
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`è‡ªå®šä¹‰APIè¯·æ±‚å¤±è´¥: ${response.status} ${errorText}`);
      }

      const data = await response.json();
      const content = data.choices?.[0]?.message?.content || data.content;

      if (!content || content.trim() === '') {
        throw new Error('è‡ªå®šä¹‰APIè¿”å›å†…å®¹ä¸ºç©º');
      }

      return content;
    }

    // è·å–å½“å‰æ¨¡å‹/æä¾›å•†ä¿¡æ¯ - è¿”å›é…ç½®çš„APIä¿¡æ¯
    function getCurrentProviderInfo() {
      const apiCfg = getApiConfig();
      const providerNames = {
        openrouter: 'OpenRouter',
        anthropic: 'Anthropic Claude',
        openai: 'OpenAI',
        custom: 'è‡ªå®šä¹‰API'
      };

      return {
        provider: providerNames[apiCfg.provider] || apiCfg.provider,
        model: apiCfg.provider === 'anthropic' ? 'claude-3-haiku-20240307' :
          apiCfg.provider === 'openai' ? 'gpt-3.5-turbo' : 'default',
        type: apiCfg.status === 'valid' ? 'å·²é…ç½®' : 'æœªé…ç½®',
        status: apiCfg.status
      };
    }

    // APIé…ç½®ç®¡ç†
    const API_CONFIG_KEY = 'lottery_api_config';

    function getApiConfig() {
      const stored = localStorage.getItem(API_CONFIG_KEY);
      const defaults = {
        provider: 'openrouter',
        apiKey: '',
        customUrl: '',
        status: 'not_configured',
        lastTest: null
      };
      try {
        return stored ? { ...defaults, ...JSON.parse(stored) } : defaults;
      } catch {
        return defaults;
      }
    }

    function saveApiConfig(config) {
      localStorage.setItem(API_CONFIG_KEY, JSON.stringify(config));
      updateApiStatusIndicator();
      updateQuickApiButton();
    }

    function openConfigPanel() {
      const cfg = getAIConfig();
      const apiCfg = getApiConfig();

      // åŠ è½½AIå‚æ•°é…ç½®
      document.getElementById('cfg_temperature').value = cfg.temperature ?? 0.5;
      document.getElementById('cfg_max_tokens').value = cfg.max_tokens ?? 300;
      document.getElementById('cfg_windowSize').value = cfg.windowSize ?? 8;
      document.getElementById('cfg_minWinRate').value = cfg.minWinRate ?? 40;
      document.getElementById('cfg_adjustMode').value = cfg.adjustMode ?? 'conservative';
      document.getElementById('cfg_reasoningDepth').value = cfg.reasoningDepth ?? 3;

      // åŠ è½½APIé…ç½®
      document.getElementById('apiProvider').value = apiCfg.provider;
      document.getElementById('apiKey').value = apiCfg.apiKey;
      document.getElementById('customApiUrl').value = apiCfg.customUrl || '';

      // æ›´æ–°ç•Œé¢çŠ¶æ€
      onProviderChange();
      updateApiStatusDisplay();

      const modal = document.getElementById('configModal');
      modal.style.display = 'flex';
    }

    function closeConfigPanel() {
      const modal = document.getElementById('configModal');
      modal.style.display = 'none';
    }

    function saveConfigChanges() {
      // ä¿å­˜AIå‚æ•°é…ç½®
      const temperature = parseFloat(document.getElementById('cfg_temperature').value);
      const max_tokens = parseInt(document.getElementById('cfg_max_tokens').value, 10);
      const windowSize = parseInt(document.getElementById('cfg_windowSize').value, 10);
      const minWinRate = parseInt(document.getElementById('cfg_minWinRate').value, 10);
      const adjustMode = String(document.getElementById('cfg_adjustMode').value || 'conservative');
      const reasoningDepth = parseInt(document.getElementById('cfg_reasoningDepth').value, 10);
      const aiCfg = { temperature, max_tokens, windowSize, minWinRate, adjustMode, reasoningDepth };
      saveAIConfig(aiCfg);

      // ä¿å­˜APIé…ç½®
      const provider = document.getElementById('apiProvider').value;
      const apiKey = document.getElementById('apiKey').value.trim();
      const customUrl = document.getElementById('customApiUrl').value.trim();
      const apiCfg = getApiConfig();
      apiCfg.provider = provider;
      apiCfg.apiKey = apiKey;
      apiCfg.customUrl = customUrl;
      saveApiConfig(apiCfg);

      showToast('âœ… é…ç½®å·²ä¿å­˜');
      closeConfigPanel();
      updateAccuracyDisplay('hk');
      updateAccuracyDisplay('macau');
    }

    // é…ç½®é¢æ¿æ ‡ç­¾åˆ‡æ¢
    function switchConfigTab(tabName) {
      // æ›´æ–°æ ‡ç­¾çŠ¶æ€
      document.querySelectorAll('.config-tab').forEach(tab => {
        tab.classList.remove('active');
        tab.style.background = '#fff';
      });
      document.getElementById(tabName + 'ConfigTab').classList.add('active');
      document.getElementById(tabName + 'ConfigTab').style.background = '#f8fafc';

      // åˆ‡æ¢é¢æ¿æ˜¾ç¤º
      document.querySelectorAll('.config-panel').forEach(panel => {
        panel.style.display = 'none';
      });
      document.getElementById(tabName + 'ConfigPanel').style.display =
        tabName === 'ai' ? 'grid' : 'block';
    }

    // APIæä¾›å•†åˆ‡æ¢å¤„ç†
    function onProviderChange() {
      const provider = document.getElementById('apiProvider').value;
      const customSection = document.getElementById('customApiSection');
      const apiKeyInput = document.getElementById('apiKey');
      const hintElement = document.getElementById('apiKeyHint');

      // æ˜¾ç¤º/éšè—è‡ªå®šä¹‰APIé…ç½®
      customSection.style.display = provider === 'custom' ? 'block' : 'none';

      // æ›´æ–°APIå¯†é’¥æç¤ºä¿¡æ¯
      const hints = {
        openrouter: 'OpenRouter APIå¯†é’¥æ ¼å¼ï¼šsk-or-v1-xxxxxxxx',
        anthropic: 'Anthropic APIå¯†é’¥æ ¼å¼ï¼šsk-ant-xxxxxxxx',
        openai: 'OpenAI APIå¯†é’¥æ ¼å¼ï¼šsk-xxxxxxxx',
        custom: 'è¯·è¾“å…¥æ‚¨çš„è‡ªå®šä¹‰APIå¯†é’¥'
      };

      const placeholders = {
        openrouter: 'sk-or-v1-xxxxxxxxxxxxxxxxxxxxxxxx',
        anthropic: 'sk-ant-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',
        openai: 'sk-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',
        custom: 'è¯·è¾“å…¥APIå¯†é’¥'
      };

      hintElement.textContent = hints[provider];
      apiKeyInput.placeholder = placeholders[provider];
    }

    // APIå¯†é’¥æ˜¾ç¤º/éšè—åˆ‡æ¢
    function toggleApiKeyVisibility() {
      const apiKeyInput = document.getElementById('apiKey');
      const toggleBtn = document.getElementById('toggleApiKey');

      if (apiKeyInput.type === 'password') {
        apiKeyInput.type = 'text';
        toggleBtn.textContent = 'ğŸ™ˆ';
      } else {
        apiKeyInput.type = 'password';
        toggleBtn.textContent = 'ğŸ‘ï¸';
      }
    }

    // åº”ç”¨å¿«é€Ÿé…ç½®æ¨¡æ¿
    function applyApiTemplate(provider) {
      const templates = {
        openrouter: {
          provider: 'openrouter',
          hint: 'è¯·è®¿é—® openrouter.ai è·å–APIå¯†é’¥'
        },
        anthropic: {
          provider: 'anthropic',
          hint: 'è¯·è®¿é—® console.anthropic.com è·å–APIå¯†é’¥'
        }
      };

      const template = templates[provider];
      document.getElementById('apiProvider').value = template.provider;
      onProviderChange();

      showToast(template.hint);
    }

    // æµ‹è¯•APIè¿æ¥
    async function testApiConnection() {
      const provider = document.getElementById('apiProvider').value;
      const apiKey = document.getElementById('apiKey').value.trim();
      const customUrl = document.getElementById('customApiUrl').value.trim();

      if (!apiKey) {
        showToast('âŒ è¯·å…ˆè¾“å…¥APIå¯†é’¥', 'error');
        return;
      }

      // æ˜¾ç¤ºæµ‹è¯•ä¸­çŠ¶æ€
      const statusDisplay = document.getElementById('apiStatusDisplay');
      statusDisplay.innerHTML = 'ğŸ”„ æ­£åœ¨æµ‹è¯•è¿æ¥...';

      try {
        const result = await validateApiKey(provider, apiKey, customUrl);
        const apiCfg = getApiConfig();
        apiCfg.status = result.valid ? 'valid' : 'invalid';
        apiCfg.lastTest = new Date().toISOString();
        saveApiConfig(apiCfg);

        if (result.valid) {
          statusDisplay.innerHTML = `âœ… è¿æ¥æˆåŠŸï¼æ¨¡å‹ï¼š${result.model || 'æœªçŸ¥'}`;
          showToast('âœ… APIè¿æ¥éªŒè¯æˆåŠŸ', 'success');
        } else {
          statusDisplay.innerHTML = `âŒ è¿æ¥å¤±è´¥ï¼š${result.error}`;
          showToast(`âŒ APIéªŒè¯å¤±è´¥ï¼š${result.error}`, 'error');
        }
      } catch (error) {
        const apiCfg = getApiConfig();
        apiCfg.status = 'error';
        apiCfg.lastTest = new Date().toISOString();
        saveApiConfig(apiCfg);

        statusDisplay.innerHTML = `âŒ æµ‹è¯•å¼‚å¸¸ï¼š${error.message}`;
        showToast(`âŒ æµ‹è¯•å¼‚å¸¸ï¼š${error.message}`, 'error');
      }
    }

    // éªŒè¯APIå¯†é’¥æœ‰æ•ˆæ€§
    async function validateApiKey(provider, apiKey, customUrl) {
      const configs = {
        openrouter: {
          url: 'https://openrouter.ai/api/v1/models',
          headers: {
            'Authorization': `Bearer ${apiKey}`,
            'Content-Type': 'application/json'
          }
        },
        anthropic: {
          url: 'https://api.anthropic.com/v1/messages',
          headers: {
            'x-api-key': apiKey,
            'Content-Type': 'application/json',
            'anthropic-version': '2023-06-01'
          },
          body: JSON.stringify({
            model: 'claude-3-haiku-20240307',
            max_tokens: 1,
            messages: [{ role: 'user', content: 'test' }]
          })
        },
        openai: {
          url: 'https://api.openai.com/v1/models',
          headers: {
            'Authorization': `Bearer ${apiKey}`,
            'Content-Type': 'application/json'
          }
        }
      };

      if (provider === 'custom') {
        if (!customUrl) {
          throw new Error('è‡ªå®šä¹‰APIéœ€è¦æä¾›ç«¯ç‚¹URL');
        }
        configs.custom = {
          url: customUrl + '/models',
          headers: {
            'Authorization': `Bearer ${apiKey}`,
            'Content-Type': 'application/json'
          }
        };
      }

      const config = configs[provider];
      const response = await fetch(config.url, {
        method: config.body ? 'POST' : 'GET',
        headers: config.headers,
        body: config.body
      });

      if (response.ok) {
        return { valid: true, model: provider };
      } else {
        const errorData = await response.json().catch(() => ({}));
        return {
          valid: false,
          error: errorData.error?.message || `HTTP ${response.status}`
        };
      }
    }

    // æ›´æ–°APIçŠ¶æ€æŒ‡ç¤ºå™¨
    function updateApiStatusIndicator() {
      const apiCfg = getApiConfig();
      const statusDot = document.getElementById('apiStatusDot');
      const statusText = document.getElementById('apiStatusText');

      const statusConfig = {
        not_configured: { color: '#ef4444', text: 'APIæœªé…ç½®' },
        valid: { color: '#10b981', text: 'APIå·²è¿æ¥' },
        invalid: { color: '#f59e0b', text: 'APIæ— æ•ˆ' },
        error: { color: '#ef4444', text: 'APIé”™è¯¯' }
      };

      const config = statusConfig[apiCfg.status] || statusConfig.not_configured;
      statusDot.style.background = config.color;
      statusText.textContent = config.text;
      statusText.style.color = apiCfg.status === 'valid' ? '#10b981' : '#64748b';
    }

    // æ›´æ–°å¿«é€ŸAPIè®¾ç½®æŒ‰é’®çŠ¶æ€
    function updateQuickApiButton() {
      const apiCfg = getApiConfig();
      const quickApiBtn = document.getElementById('quickApiBtn');

      if (apiCfg.apiKey && apiCfg.status === 'valid') {
        quickApiBtn.textContent = 'ğŸ”‘ APIå·²é…ç½®';
        quickApiBtn.style.background = '#10b981';
        quickApiBtn.style.borderColor = '#10b981';
      } else {
        quickApiBtn.textContent = 'ğŸ”‘ è®¾ç½®API';
        quickApiBtn.style.background = '#10b981';
        quickApiBtn.style.borderColor = '#10b981';
      }
    }

    // æ›´æ–°é…ç½®é¢æ¿ä¸­çš„APIçŠ¶æ€æ˜¾ç¤º
    function updateApiStatusDisplay() {
      const apiCfg = getApiConfig();
      const statusDisplay = document.getElementById('apiStatusDisplay');

      if (!apiCfg.apiKey) {
        statusDisplay.innerHTML = 'æœªé…ç½®APIå¯†é’¥';
        return;
      }

      const statusConfig = {
        not_configured: { text: 'æœªé…ç½®APIå¯†é’¥', color: '#64748b' },
        valid: { text: 'âœ… APIè¿æ¥æ­£å¸¸', color: '#10b981' },
        invalid: { text: 'âŒ APIå¯†é’¥æ— æ•ˆ', color: '#ef4444' },
        error: { text: 'âŒ APIè¿æ¥é”™è¯¯', color: '#ef4444' }
      };

      const config = statusConfig[apiCfg.status] || statusConfig.not_configured;

      let html = `<span style="color: ${config.color}">${config.text}</span>`;

      if (apiCfg.lastTest) {
        const testTime = new Date(apiCfg.lastTest).toLocaleString('zh-CN');
        html += `<div style="font-size:10px; margin-top:4px; color:#94a3b8;">æœ€åæµ‹è¯•ï¼š${testTime}</div>`;
      }

      statusDisplay.innerHTML = html;
    }

    // è·å–å½“å‰APIé…ç½®ä¾›å…¶ä»–åŠŸèƒ½ä½¿ç”¨ (ä¿®å¤ç‰ˆæœ¬)
    function getCurrentApiConfig() {
      const apiCfg = getApiConfig();

      // ä¼˜å…ˆä½¿ç”¨ç”¨æˆ·é…ç½®çš„APIå¯†é’¥
      if (apiCfg.apiKey && apiCfg.apiKey.trim() !== '') {
        console.log('âœ… ä½¿ç”¨ç”¨æˆ·é…ç½®çš„APIå¯†é’¥');
        return apiCfg;
      }

      // å¦‚æœç”¨æˆ·æ²¡æœ‰é…ç½®APIå¯†é’¥ï¼Œæ˜¾ç¤ºé…ç½®æç¤º
      apiCfg.status = 'not_configured';
      saveApiConfig(apiCfg);
      updateApiStatusIndicator();

      const error = new Error('APIæœªé…ç½®ï¼Œè¯·ç‚¹å‡»"ğŸ”‘ è®¾ç½®API"æŒ‰é’®é…ç½®æ‚¨çš„APIå¯†é’¥');
      error.code = 'API_NOT_CONFIGURED';
      throw error;
    }

    // å¿«é€ŸAPIè®¾ç½®ç›¸å…³å‡½æ•°
    let selectedQuickProvider = null;

    function openQuickApiSetup() {
      document.getElementById('quickApiModal').style.display = 'flex';
      // é‡ç½®çŠ¶æ€
      selectedQuickProvider = null;
      document.getElementById('quickApiKeySection').style.display = 'none';
      document.getElementById('quickApiTestBtn').style.display = 'none';
      document.getElementById('quickApiSaveBtn').style.display = 'none';

      // é‡ç½®æŒ‰é’®æ ·å¼
      document.querySelectorAll('#quickApiModal button[onclick^="selectApiProvider"]').forEach(btn => {
        btn.style.borderColor = '#e2e8f0';
        btn.style.background = '#f8fafc';
      });
    }

    function closeQuickApiSetup() {
      document.getElementById('quickApiModal').style.display = 'none';
    }

    function selectApiProvider(provider) {
      selectedQuickProvider = provider;

      // æ›´æ–°æŒ‰é’®æ ·å¼
      document.querySelectorAll('#quickApiModal button[onclick^="selectApiProvider"]').forEach(btn => {
        btn.style.borderColor = '#e2e8f0';
        btn.style.background = '#f8fafc';
      });
      event.target.closest('button').style.borderColor = '#3b82f6';
      event.target.closest('button').style.background = '#eff6ff';

      // æ˜¾ç¤ºAPIå¯†é’¥è¾“å…¥åŒºåŸŸ
      const keySection = document.getElementById('quickApiKeySection');
      const keyInput = document.getElementById('quickApiKey');
      const hintElement = document.getElementById('quickApiHint');

      keySection.style.display = 'block';

      const configs = {
        openrouter: {
          hint: 'OpenRouter APIå¯†é’¥æ ¼å¼ï¼šsk-or-v1-xxxxxxxx',
          placeholder: 'sk-or-v1-xxxxxxxxxxxxxxxxxxxxxxxx',
          url: 'https://openrouter.ai/keys'
        },
        anthropic: {
          hint: 'Anthropic APIå¯†é’¥æ ¼å¼ï¼šsk-ant-xxxxxxxx',
          placeholder: 'sk-ant-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',
          url: 'https://console.anthropic.com/'
        }
      };

      const config = configs[provider];
      keyInput.placeholder = config.placeholder;
      hintElement.innerHTML = `${config.hint}<br/><a href="${config.url}" target="_blank" style="color:#3b82f6; text-decoration:none;">è·å–APIå¯†é’¥ â†’</a>`;

      // æ˜¾ç¤ºæ“ä½œæŒ‰é’®
      document.getElementById('quickApiTestBtn').style.display = 'inline-block';
      document.getElementById('quickApiSaveBtn').style.display = 'inline-block';
    }

    async function testQuickApiKey() {
      const apiKey = document.getElementById('quickApiKey').value.trim();
      if (!apiKey) {
        showToast('è¯·è¾“å…¥APIå¯†é’¥', 'error');
        return;
      }

      const testBtn = document.getElementById('quickApiTestBtn');
      const originalText = testBtn.textContent;
      testBtn.textContent = 'ğŸ”„ æµ‹è¯•ä¸­...';
      testBtn.disabled = true;

      try {
        const result = await validateApiKey(selectedQuickProvider, apiKey);
        if (result.valid) {
          showToast('âœ… APIè¿æ¥æµ‹è¯•æˆåŠŸï¼', 'success');
          testBtn.textContent = 'âœ… æµ‹è¯•æˆåŠŸ';
          testBtn.style.background = '#10b981';
          testBtn.style.borderColor = '#10b981';
        } else {
          showToast(`âŒ APIæµ‹è¯•å¤±è´¥ï¼š${result.error}`, 'error');
          testBtn.textContent = originalText;
          testBtn.disabled = false;
        }
      } catch (error) {
        showToast(`âŒ æµ‹è¯•å¼‚å¸¸ï¼š${error.message}`, 'error');
        testBtn.textContent = originalText;
        testBtn.disabled = false;
      }
    }

    async function saveQuickApiKey() {
      const apiKey = document.getElementById('quickApiKey').value.trim();
      if (!apiKey) {
        showToast('è¯·è¾“å…¥APIå¯†é’¥', 'error');
        return;
      }

      const saveBtn = document.getElementById('quickApiSaveBtn');
      const originalText = saveBtn.textContent;
      saveBtn.textContent = 'ğŸ”„ ä¿å­˜ä¸­...';
      saveBtn.disabled = true;

      try {
        // éªŒè¯APIå¯†é’¥
        const result = await validateApiKey(selectedQuickProvider, apiKey);
        if (!result.valid) {
          showToast(`âŒ APIå¯†é’¥éªŒè¯å¤±è´¥ï¼š${result.error}`, 'error');
          saveBtn.textContent = originalText;
          saveBtn.disabled = false;
          return;
        }

        // ä¿å­˜é…ç½®
        const apiCfg = getApiConfig();
        apiCfg.provider = selectedQuickProvider;
        apiCfg.apiKey = apiKey;
        apiCfg.status = 'valid';
        apiCfg.lastTest = new Date().toISOString();
        saveApiConfig(apiCfg);

        showToast('âœ… APIå¯†é’¥ä¿å­˜æˆåŠŸï¼AIé¢„æµ‹åŠŸèƒ½å·²å¯ç”¨', 'success');
        closeQuickApiSetup();

        // æ›´æ–°æŒ‰é’®æ˜¾ç¤º
        const quickApiBtn = document.getElementById('quickApiBtn');
        quickApiBtn.textContent = 'ğŸ”‘ APIå·²é…ç½®';
        quickApiBtn.style.background = '#10b981';
        quickApiBtn.style.borderColor = '#10b981';

        // è‡ªåŠ¨æµ‹è¯•å¯ç”¨æ¨¡å‹
        setTimeout(() => {
          testAvailableModels();
        }, 1000);

      } catch (error) {
        showToast(`âŒ ä¿å­˜å¤±è´¥ï¼š${error.message}`, 'error');
        saveBtn.textContent = originalText;
        saveBtn.disabled = false;
      }
    }

    // æµ‹è¯•å¯ç”¨æ¨¡å‹
    async function testAvailableModels() {
      const modelDisplay = document.getElementById('modelStatusDisplay');
      modelDisplay.innerHTML = 'ğŸ”„ æ­£åœ¨æ£€æµ‹å¯ç”¨æ¨¡å‹...';

      try {
        const apiCfg = getApiConfig();
        if (!apiCfg.apiKey || apiCfg.provider !== 'openrouter') {
          modelDisplay.innerHTML = 'æ­¤åŠŸèƒ½ä»…æ”¯æŒOpenRouter API';
          return;
        }

        let workingModels = [];
        let failedModels = [];

        // æµ‹è¯•æ¯ä¸ªæ¨¡å‹
        for (let i = 0; i < Math.min(4, FREE_MODELS.length); i++) { // åªæµ‹è¯•å‰4ä¸ªæ¨¡å‹ä»¥æé«˜é€Ÿåº¦
          const model = FREE_MODELS[i];
          try {
            const response = await fetch(OPENROUTER_API_URL, {
              method: 'POST',
              headers: {
                'Authorization': `Bearer ${apiCfg.apiKey}`,
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                model: model,
                messages: [{ role: 'user', content: 'test' }],
                max_tokens: 1
              })
            });

            if (response.ok) {
              workingModels.push(model);
            } else {
              failedModels.push(model);
            }
          } catch (error) {
            failedModels.push(model);
          }
        }

        // æ˜¾ç¤ºç»“æœ
        if (workingModels.length > 0) {
          let html = `<div style="color: #10b981; font-weight: 600;">âœ… å‘ç° ${workingModels.length} ä¸ªå¯ç”¨æ¨¡å‹:</div>`;
          workingModels.forEach(model => {
            html += `<div style="font-size: 10px; margin-left: 8px; color: #059669;">â€¢ ${model}</div>`;
          });

          if (failedModels.length > 0) {
            html += `<div style="color: #f59e0b; font-weight: 600; margin-top: 8px;">âš ï¸ ${failedModels.length} ä¸ªæ¨¡å‹ä¸å¯ç”¨:</div>`;
            failedModels.forEach(model => {
              html += `<div style="font-size: 10px; margin-left: 8px; color: #d97706;">â€¢ ${model}</div>`;
            });
          }

          modelDisplay.innerHTML = html;
        } else {
          modelDisplay.innerHTML = '<div style="color: #ef4444;">âŒ æœªå‘ç°å¯ç”¨æ¨¡å‹ï¼Œè¯·æ£€æŸ¥APIå¯†é’¥æˆ–ç¨åå†è¯•</div>';
        }

      } catch (error) {
        modelDisplay.innerHTML = `<div style="color: #ef4444;">âŒ æ£€æµ‹å¤±è´¥: ${error.message}</div>`;
      }
    }

    // ç”Ÿè‚–æ•°ç»„
    const zodiacAnimals = ['é¼ ', 'ç‰›', 'è™', 'å…”', 'é¾™', 'è›‡', 'é©¬', 'ç¾Š', 'çŒ´', 'é¸¡', 'ç‹—', 'çŒª'];
    // çœŸå®å†å²æ•°æ®ç¼“å­˜ï¼ˆç”±fetchHistoricalDataå¡«å……ï¼‰
    const realHistoricalDataStore = { hk: [], macau: [] };

    // é¢„æµ‹è®°å½•ç³»ç»Ÿ
    const PREDICTION_STORAGE_KEY = 'lottery_predictions';
    const ACCURACY_STORAGE_KEY = 'prediction_accuracy';

    // é¢„æµ‹ç­–ç•¥é…ç½®ï¼ˆæ‰©å±•å¤šç§ç­–ç•¥ï¼‰
    const PREDICTION_STRATEGIES = {
      ai: {
        name: 'AIæ™ºèƒ½åˆ†æ',
        description: 'åŸºäºæ·±åº¦å­¦ä¹ æ¨¡å‹çš„æ™ºèƒ½é¢„æµ‹',
        indicator: 'strategy-ai',
        useAI: true,
        confidence: 0.85,
        algorithm: 'neural_network',
        weight: 0.4
      },
      statistical: {
        name: 'ç»Ÿè®¡åˆ†æ',
        description: 'åŸºäºå†å²æ•°æ®ç»Ÿè®¡åˆ†æ',
        indicator: 'strategy-stat',
        useAI: false,
        confidence: 0.7,
        algorithm: 'frequency_analysis',
        weight: 0.25
      },
      trend: {
        name: 'è¶‹åŠ¿åˆ†æ',
        description: 'åŸºäºå·ç è¶‹åŠ¿å’Œæ¨¡å¼è¯†åˆ«',
        indicator: 'strategy-trend',
        useAI: false,
        confidence: 0.65,
        algorithm: 'pattern_recognition',
        weight: 0.2
      },
      hybrid: {
        name: 'æ··åˆç­–ç•¥',
        description: 'ç»“åˆå¤šç§ç®—æ³•çš„ç»¼åˆé¢„æµ‹',
        indicator: 'strategy-hybrid',
        useAI: true,
        confidence: 0.8,
        algorithm: 'ensemble',
        weight: 0.3
      },
      ml: {
        name: 'æœºå™¨å­¦ä¹ ',
        description: 'åŸºäºæœºå™¨å­¦ä¹ æ¨¡å‹çš„é¢„æµ‹',
        indicator: 'strategy-ml',
        useAI: true,
        confidence: 0.75,
        algorithm: 'random_forest',
        weight: 0.35
      }
    };

    // å½“å‰ç­–ç•¥é…ç½®
    let currentStrategy = {
      hk: 'ai',
      macau: 'ai'
    };

    // è·å–å½“å‰æœŸå·ï¼ˆåŸºäºæ–°æ•°æ®æºï¼‰
    async function getCurrentPeriod(type) {
      console.log(`å¼€å§‹è·å–${type === 'hk' ? 'é¦™æ¸¯' : 'æ¾³é—¨'}å½“å‰æœŸå·...`);

      try {
        // é¦–å…ˆå°è¯•ä»æ–°æ•°æ®æºè·å–æœ€æ–°æœŸå·
        let latestPeriod = null;

        if (type === 'hk') {
          // ä»é¦™æ¸¯å†å²æ•°æ®æºè·å–æœ€æ–°æœŸå· - ä½¿ç”¨æ­£ç¡®çš„APIé…ç½®
          const hkHistoryApi = LOTTERY_APIS.find(api => api.name === 'é¦™æ¸¯å†å²æ•°æ®');
          if (hkHistoryApi) {
            try {
              const apiUrl = typeof hkHistoryApi.url === 'function' ? hkHistoryApi.url('') : hkHistoryApi.url;
              console.log(`å°è¯•è®¿é—®é¦™æ¸¯å†å²æ•°æ®æº: ${apiUrl}`);

              const response = await fetchWithTimeout(apiUrl, {
                headers: {
                  'User-Agent': 'Lottery-Prediction-Tool/1.0',
                  'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
                  'Accept-Language': 'zh-CN,zh;q=0.9,en;q=0.8',
                  'Accept-Encoding': 'gzip, deflate, br',
                  'DNT': '1',
                  'Connection': 'keep-alive',
                  'Upgrade-Insecure-Requests': '1'
                },
                mode: 'cors',
                credentials: 'omit'
              }, 15000);

              console.log(`é¦™æ¸¯å†å²æ•°æ®æºå“åº”çŠ¶æ€: ${response.status} ${response.statusText}`);

              if (response.ok) {
                const html = await response.text();
                console.log(`é¦™æ¸¯å†å²æ•°æ®æºè¿”å›å†…å®¹é•¿åº¦: ${html.length} å­—ç¬¦`);

                // ä½¿ç”¨APIé…ç½®çš„è§£æå™¨è§£ææ•°æ®
                const parsedData = hkHistoryApi.parser(html);
                console.log(`é¦™æ¸¯å†å²æ•°æ®è§£æç»“æœ:`, parsedData);

                if (parsedData && parsedData.currentIssue) {
                  latestPeriod = parsedData.currentIssue;
                  console.log(`âœ… ä»é¦™æ¸¯å†å²æ•°æ®æºè·å–åˆ°æœ€æ–°æœŸå·: ${latestPeriod}`);
                } else {
                  console.log(`âš ï¸ é¦™æ¸¯å†å²æ•°æ®è§£æå™¨æœªè¿”å›æœ‰æ•ˆæœŸå·ï¼Œå°è¯•å¤‡ç”¨è§£æ...`);
                  // å¤‡ç”¨è§£æï¼šç›´æ¥è§£æHTMLä¸­çš„æœŸå·
                  const parser = new DOMParser();
                  const doc = parser.parseFromString(html, 'text/html');

                  const periodElement = doc.querySelector('.latest-draw, .current-draw, .draw-result, .latest-period, .current-period, [data-period]');
                  if (periodElement) {
                    const periodText = periodElement.textContent || periodElement.getAttribute('data-period') || '';
                    const periodMatch = periodText.match(/(\d{6,})/);
                    if (periodMatch) {
                      latestPeriod = periodMatch[0];
                      console.log(`âœ… å¤‡ç”¨è§£æè·å–åˆ°é¦™æ¸¯æœ€æ–°æœŸå·: ${latestPeriod}`);
                    }
                  } else {
                    console.log('âŒ é¦™æ¸¯å†å²æ•°æ®ï¼šæœªæ‰¾åˆ°æœŸå·å…ƒç´ ï¼Œå°è¯•å…¶ä»–é€‰æ‹©å™¨...');
                  }
                }
              } else {
                console.warn(`âŒ é¦™æ¸¯å†å²æ•°æ®æºHTTPé”™è¯¯: ${response.status} ${response.statusText}`);
              }
            } catch (apiError) {
              console.error(`âŒ é¦™æ¸¯å†å²æ•°æ®æºAPIè°ƒç”¨å¤±è´¥:`, apiError.message);
              console.error(`é”™è¯¯è¯¦æƒ…:`, apiError);
            }
          } else {
            console.warn(`âš ï¸ æœªæ‰¾åˆ°é¦™æ¸¯å†å²æ•°æ®APIé…ç½®`);
          }
        } else {
          // ä½¿ç”¨æ–°æ¾³é—¨APIï¼ˆJSONï¼‰è·å–æœ€æ–°æœŸå·
          const macauApi = LOTTERY_APIS.find(api => api.name === 'æ–°æ¾³é—¨API');
          if (macauApi) {
            try {
              const apiUrl = typeof macauApi.url === 'function' ? macauApi.url('2') : macauApi.url;
              console.log(`å°è¯•è®¿é—®æ–°æ¾³é—¨API: ${apiUrl}`);
              const response = await fetchWithTimeout(apiUrl, {}, 15000);
              console.log(`æ–°æ¾³é—¨APIå“åº”çŠ¶æ€: ${response.status} ${response.statusText}`);
              if (response.ok) {
                const json = await response.json();
                if (json && json.result === true && Array.isArray(json.data) && json.data.length > 0) {
                  latestPeriod = String(json.data[0].expect);
                  console.log(`âœ… ä»æ–°æ¾³é—¨APIè·å–åˆ°æœ€æ–°æœŸå·: ${latestPeriod}`);
                }
              }
            } catch (apiError) {
              console.error(`âŒ æ–°æ¾³é—¨APIè°ƒç”¨å¤±è´¥:`, apiError.message);
              console.error(`é”™è¯¯è¯¦æƒ…:`, apiError);
            }
          } else {
            console.warn(`âš ï¸ æœªæ‰¾åˆ°æ–°æ¾³é—¨APIé…ç½®`);
          }
        }

        // å¦‚æœä»æ–°æ•°æ®æºè·å–æˆåŠŸï¼Œè¿”å›æœ€æ–°æœŸå·
        if (latestPeriod) {
          console.log(`âœ… æˆåŠŸè·å–${type === 'hk' ? 'é¦™æ¸¯' : 'æ¾³é—¨'}æœŸå·: ${latestPeriod}`);
          return latestPeriod;
        } else {
          console.log(`âš ï¸ æ–°æ•°æ®æºè·å–å¤±è´¥ï¼Œå°†ä½¿ç”¨å¤‡ç”¨ç®—æ³•...`);
        }

      } catch (error) {
        console.error(`âŒ ä»æ–°æ•°æ®æºè·å–æœŸå·å¤±è´¥ï¼Œä½¿ç”¨å¤‡ç”¨ç®—æ³•:`, error);
      }

      // å¤‡ç”¨ç®—æ³•ï¼šåŸºäºä¼ ç»Ÿè®¡ç®—æ–¹å¼
      const now = new Date();
      const year = now.getFullYear();

      if (type === 'hk') {
        // é¦™æ¸¯å…­åˆå½©ï¼šåŸºäºå®é™…å†å²æ•°æ®æ ¡å‡†
        // æ ¹æ®marksixlottery.netå†å²æ•°æ®ï¼Œ2025å¹´11æœˆ8æ—¥å®é™…æœŸå·ä¸º119æœŸ
        const baseDate = new Date('2025-11-08');
        const basePeriod = 119;

        // é¦™æ¸¯å…­åˆå½©æ¯å‘¨å¼€å¥–3æ¬¡ï¼ˆå‘¨äºŒã€å››ã€å…­ï¼‰
        const daysSinceBase = Math.floor((now - baseDate) / (1000 * 60 * 60 * 24));
        const weeksSinceBase = Math.floor(daysSinceBase / 7);
        const remainingDays = daysSinceBase % 7;

        // è®¡ç®—é¢å¤–å¼€å¥–æ¬¡æ•°ï¼ˆè€ƒè™‘å‰©ä½™å¤©æ•°ä¸­çš„å¼€å¥–æ—¥ï¼‰
        let extraDraws = 0;
        for (let i = 1; i <= remainingDays; i++) {
          const checkDate = new Date(baseDate);
          checkDate.setDate(baseDate.getDate() + i);
          const dayOfWeek = checkDate.getDay();
          if (dayOfWeek === 2 || dayOfWeek === 4 || dayOfWeek === 6) { // å‘¨äºŒã€å››ã€å…­
            extraDraws++;
          }
        }

        const hongKongPeriod = basePeriod + weeksSinceBase * 3 + extraDraws;
        const result = `${year}${String(hongKongPeriod).padStart(3, '0')}`;

        console.log(`ğŸ“Š é¦™æ¸¯æœŸå·è®¡ç®—è¯¦æƒ…:`);
        console.log(`   åŸºå‡†æ—¥æœŸ: 2025-11-08, åŸºå‡†æœŸå·: ${basePeriod}`);
        console.log(`   å½“å‰æ—¥æœŸ: ${now.toISOString().split('T')[0]}`);
        console.log(`   ç›¸éš”å¤©æ•°: ${daysSinceBase} å¤©`);
        console.log(`   å®Œæ•´å‘¨æ•°: ${weeksSinceBase} å‘¨, å‰©ä½™å¤©æ•°: ${remainingDays} å¤©`);
        console.log(`   é¢å¤–å¼€å¥–: ${extraDraws} æ¬¡`);
        console.log(`   è®¡ç®—æœŸå·: ${hongKongPeriod} -> æ ¼å¼åŒ–ç»“æœ: ${result}`);

        return result;
      } else {
        // æ¾³é—¨æ•°å­—ï¼šåŸºäºmacaujc.meå†å²æ•°æ®æ ¡å‡†
        // æ ¹æ®å®é™…ç½‘ç«™æ•°æ®æ˜¾ç¤ºï¼Œ2025å¹´11æœˆ8æ—¥å¯¹åº”2025314æœŸ
        const baseDate = new Date(2025, 10, 8); // 2025å¹´11æœˆ8æ—¥
        const basePeriod = 314;

        const daysSinceBase = Math.floor((now - baseDate) / (1000 * 60 * 60 * 24));

        // æ¾³é—¨æ•°å­—å½©ç¥¨å¼€å¥–é¢‘ç‡ï¼šå¤§çº¦æ¯2-3å¤©å¼€å¥–ä¸€æ¬¡
        // åŸºäºå†å²æ•°æ®ç»Ÿè®¡ï¼Œå¹³å‡å¼€å¥–é—´éš”çº¦ä¸º2.5å¤©
        const periodIncrement = Math.floor(daysSinceBase / 2.5);
        const currentPeriod = basePeriod + periodIncrement;

        const result = `${year}${String(currentPeriod).padStart(3, '0')}`;

        console.log(`ğŸ“Š æ¾³é—¨æœŸå·è®¡ç®—è¯¦æƒ…:`);
        console.log(`   åŸºå‡†æ—¥æœŸ: 2025-11-08, åŸºå‡†æœŸå·: ${basePeriod}`);
        console.log(`   å½“å‰æ—¥æœŸ: ${now.toISOString().split('T')[0]}`);
        console.log(`   ç›¸éš”å¤©æ•°: ${daysSinceBase} å¤©`);
        console.log(`   å¹³å‡å¼€å¥–é—´éš”: 2.5å¤©/æœŸ`);
        console.log(`   æœŸå·å¢é‡: ${periodIncrement}`);
        console.log(`   è®¡ç®—æœŸå·: ${currentPeriod} -> æ ¼å¼åŒ–ç»“æœ: ${result}`);

        return result;
      }
    }

    // è·å–ä¸‹ä¸€æœŸæœŸå·ï¼ˆç”¨äºé¢„æµ‹ï¼‰
    async function getNextPeriod(type) {
      const currentPeriod = await getCurrentPeriod(type);
      const periodNumber = parseInt(currentPeriod.slice(-3));
      const year = currentPeriod.slice(0, 4);

      // ä¸‹ä¸€æœŸæœŸå· = å½“å‰æœŸå· + 1
      const nextPeriodNumber = periodNumber + 1;
      return `${year}${String(nextPeriodNumber).padStart(3, '0')}`;
    }

    // ä¿å­˜é¢„æµ‹è®°å½•
    function savePredictionRecord(type, period, prediction, strategy) {
      // è·å–å½“å‰å†å²è®°å½•
      const history = getPredictionHistory(type);

      // è·å–å‰ä¸€æ¬¡çš„ç­–ç•¥ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
      const previousStrategy = history.length > 0 ? history[0].strategy : 'none';

      const record = {
        period: period,
        prediction: prediction,
        strategy: strategy,
        previousStrategy: previousStrategy, // è®°å½•å‰ä¸€æ¬¡ç­–ç•¥
        timestamp: Date.now(),
        status: 'pending',
        accuracy: null,
        actualResult: null,
        numbers: prediction.numbers || [],
        zodiac: prediction.zodiac || ''
      };

      // æ·»åŠ åˆ°å†å²è®°å½•å¼€å¤´
      history.unshift(record);

      // åªä¿ç•™æœ€è¿‘50æ¡è®°å½•
      if (history.length > 50) {
        history.splice(50);
      }

      // ä¿å­˜æ›´æ–°åçš„å†å²è®°å½•
      savePredictionHistory(type, history);
      updatePredictionHistory(type);
    }

    // æ›´æ–°é¢„æµ‹å†å²æ˜¾ç¤º
    function updatePredictionHistory(type) {
      const history = getPredictionHistory(type);
      const historyDiv = document.getElementById(`${type}PredictionHistory`);

      if (history.length === 0) {
        historyDiv.innerHTML = '<div style="text-align: center; color: #9ca3af; padding: 20px;">æš‚æ— é¢„æµ‹è®°å½•</div>';
        return;
      }

      const html = history.slice(0, 10).map(record => {
        const statusClass = record.status === 'pending' ? 'status-pending' :
          record.status === 'correct' ? 'status-correct' : 'status-incorrect';
        const statusText = record.status === 'pending' ? 'å¾…å¼€å¥–' :
          record.status === 'correct' ? 'é¢„æµ‹æ­£ç¡®' : 'é¢„æµ‹é”™è¯¯';

        const strategyInfo = PREDICTION_STRATEGIES[record.strategy] || { name: record.strategy, indicator: 'indicator-default' };
        const numbersText = record.numbers && record.numbers.length > 0 ? record.numbers.join(', ') : 'æš‚æ— æ•°æ®';

        // å‡†ç¡®åº¦æ˜¾ç¤º
        const accuracyDisplay = record.accuracy !== undefined ?
          `<span class="accuracy-info">(å‡†ç¡®åº¦: ${record.accuracy}%)</span>` : '';

        // å‰ä¸€æ¬¡ç­–ç•¥æ˜¾ç¤º
        const previousStrategyText = record.previousStrategy && record.previousStrategy !== 'none' ?
          `<span class="previous-strategy">å‰ç­–ç•¥: ${record.previousStrategy}</span>` : '';

        // å¼€å¥–ç»“æœå¯¹æ¯”
        let resultDisplay = '';
        if (record.actualResult) {
          const actualText = record.actualResult.join(', ');
          const correctNumbers = record.numbers.filter(num => record.actualResult.includes(num));
          const correctCount = correctNumbers.length;
          resultDisplay = `
            <div class="result-comparison">
              <div>å¼€å¥–: ${actualText}</div>
              <div class="match-info">å‘½ä¸­ ${correctCount}/7 ä¸ªå·ç  ${accuracyDisplay}</div>
            </div>
          `;
        } else {
          resultDisplay = '<div class="result-comparison">ç­‰å¾…å¼€å¥–ç»“æœ</div>';
        }

        return `
          <div class="history-item">
            <div class="history-header">
              <span class="history-period">æœŸå·: ${record.period}</span>
              <span class="history-status ${statusClass}">${statusText}</span>
            </div>
            <div class="history-numbers">
              <span class="strategy-indicator ${strategyInfo.indicator}"></span>
              é¢„æµ‹: ${numbersText}
            </div>
            <div class="strategy-info">
              ç­–ç•¥: ${strategyInfo.name} ${previousStrategyText}
            </div>
            ${resultDisplay}
          </div>
        `;
      }).join('');

      historyDiv.innerHTML = html;
    }

    // è®¡ç®—å‡†ç¡®ç‡
    function calculateAccuracy(type) {
      const history = getPredictionHistory(type);
      const completedRecords = history.filter(r => r.status === 'correct' || r.status === 'incorrect');
      if (completedRecords.length === 0) return null;
      const correctCount = completedRecords.filter(r => r.status === 'correct').length;
      return Math.round((correctCount / completedRecords.length) * 100);
    }

    // æ›´æ–°å½“å‰ç­–ç•¥æ˜¾ç¤º
    function updateCurrentStrategyDisplay(type) {
      const strategy = currentStrategy[type];
      const strategyName = PREDICTION_STRATEGIES[strategy].name;
      const strategyElement = document.getElementById(`${type}CurrentStrategy`);
      const compositionElement = document.getElementById(`${type}StrategyComposition`);

      if (strategyElement) {
        strategyElement.textContent = strategyName;

        // æ ¹æ®ç­–ç•¥ç±»å‹è®¾ç½®ä¸åŒçš„é¢œè‰²
        strategyElement.style.color = '#2196F3';
        if (strategyName.includes('æ·±åº¦')) {
          strategyElement.style.color = '#9C27B0';
        } else if (strategyName.includes('æ··åˆ')) {
          strategyElement.style.color = '#FF9800';
        } else if (strategyName.includes('å¢å¼º')) {
          strategyElement.style.color = '#4CAF50';
        }
      }

      // æ›´æ–°ç­–ç•¥ç»„åˆè¯¦ç»†ä¿¡æ¯
      if (compositionElement) {
        const strategyDetails = getStrategyDetails(strategy);
        compositionElement.textContent = strategyDetails;
      }

      // æ·»åŠ ç­–ç•¥åˆ‡æ¢åŠ¨ç”»æ•ˆæœ
      const strategyPanel = document.getElementById(`${type}Prediction`);
      if (strategyPanel) {
        strategyPanel.style.animation = 'none';
        setTimeout(() => {
          strategyPanel.style.animation = 'pulse 1s ease-in-out';
        }, 10);
      }
    }

    // è·å–ç­–ç•¥è¯¦ç»†ä¿¡æ¯
    function getStrategyDetails(strategy) {
      const details = {
        'ai': 'ç»Ÿè®¡åˆ†æ + æœºå™¨å­¦ä¹  + é›†æˆé¢„æµ‹',
        'deep_ai': 'æ·±åº¦ç¥ç»ç½‘ç»œ + LSTM + æ³¨æ„åŠ›æœºåˆ¶',
        'hybrid': 'å¤šç®—æ³•èåˆ + æƒé‡ä¼˜åŒ– + è‡ªé€‚åº”è°ƒæ•´',
        'enhanced': 'å¢å¼ºåˆ†æ + ç‰¹å¾å·¥ç¨‹ + æ¨¡å‹é›†æˆ'
      };
      return details[strategy] || 'ç»¼åˆæ™ºèƒ½åˆ†æ';
    }

    // æ›´æ–°å‡†ç¡®ç‡æ˜¾ç¤º
    function updateAccuracyDisplay(type) {
      const accuracy = calculateAccuracy(type);
      const accuracySpan = document.getElementById(`${type}AccuracyRate`);

      // è·å–é¢„æµ‹å†å²è®°å½•
      const history = getPredictionHistory(type);
      const completedRecords = history.filter(r => r.status === 'correct' || r.status === 'incorrect');
      const correctCount = completedRecords.filter(r => r.status === 'correct').length;
      const totalCount = completedRecords.length;

      // æ›´æ–°æ€»é¢„æµ‹æ¬¡æ•°å’ŒæˆåŠŸæ¬¡æ•°
      const totalPredictionsSpan = document.getElementById(`${type}TotalPredictions`);
      const correctPredictionsSpan = document.getElementById(`${type}CorrectPredictions`);
      if (totalPredictionsSpan) totalPredictionsSpan.textContent = totalCount;
      if (correctPredictionsSpan) correctPredictionsSpan.textContent = correctCount;

      // æ›´æ–°æ€§èƒ½çŠ¶æ€
      const performanceStatusSpan = document.getElementById(`${type}PerformanceStatus`);
      if (performanceStatusSpan) {
        if (totalCount === 0) {
          performanceStatusSpan.textContent = 'æ–°ç­–ç•¥';
          performanceStatusSpan.style.background = '#9E9E9E';
        } else if (accuracy >= 60) {
          performanceStatusSpan.textContent = 'ä¼˜ç§€';
          performanceStatusSpan.style.background = '#4CAF50';
        } else if (accuracy >= 40) {
          performanceStatusSpan.textContent = 'æ­£å¸¸';
          performanceStatusSpan.style.background = '#2196F3';
        } else {
          performanceStatusSpan.textContent = 'éœ€è°ƒæ•´';
          performanceStatusSpan.style.background = '#FF9800';

          // å¦‚æœå‡†ç¡®ç‡ä½äº40%ï¼Œæ˜¾ç¤ºè­¦å‘Š
          if (accuracy < 40 && totalCount >= 5) {
            performanceStatusSpan.textContent = 'ä½æ•ˆ';
            performanceStatusSpan.style.background = '#F44336';
          }
        }
      }

      // æ›´æ–°å‡†ç¡®ç‡è¶‹åŠ¿
      const accuracyTrendSpan = document.getElementById(`${type}AccuracyTrend`);
      if (accuracyTrendSpan && completedRecords.length >= 5) {
        const recentRecords = completedRecords.slice(-5);
        const recentAccuracy = (recentRecords.filter(r => r.status === 'correct').length / recentRecords.length) * 100;
        const trend = recentAccuracy - accuracy;

        if (trend > 10) {
          accuracyTrendSpan.textContent = 'ğŸ“ˆ ä¸Šå‡';
          accuracyTrendSpan.style.color = '#4CAF50';
        } else if (trend < -10) {
          accuracyTrendSpan.textContent = 'ğŸ“‰ ä¸‹é™';
          accuracyTrendSpan.style.color = '#F44336';
        } else {
          accuracyTrendSpan.textContent = 'â¡ï¸ å¹³ç¨³';
          accuracyTrendSpan.style.color = '#FF9800';
        }
      }

      if (accuracy === null) {
        accuracySpan.textContent = '-';
        accuracySpan.className = '';
      } else {
        accuracySpan.textContent = `${accuracy}%`;
        if (accuracy >= 70) {
          accuracySpan.className = 'accuracy-high';
        } else if (accuracy >= 50) {
          accuracySpan.className = 'accuracy-medium';
        } else {
          accuracySpan.className = 'accuracy-low';
        }
      }

      // æ›´æ–°æ€§èƒ½è¶‹åŠ¿å›¾
      updatePerformanceTrend(type);
    }

    // æ›´æ–°æ€§èƒ½è¶‹åŠ¿å›¾
    function updatePerformanceTrend(type) {
      const history = getPredictionHistory(type);
      const completedRecords = history.filter(r => r.status === 'correct' || r.status === 'incorrect');

      if (completedRecords.length < 3) {
        document.getElementById(`${type}TrendIndicator`).textContent = 'æ•°æ®ä¸è¶³';
        document.getElementById(`${type}MiniChart`).innerHTML = '';
        return;
      }

      // è·å–æœ€è¿‘10æœŸçš„å‡†ç¡®ç‡æ•°æ®
      const recentRecords = completedRecords.slice(-10);
      const accuracyData = recentRecords.map(record => record.status === 'correct' ? 1 : 0);

      // è®¡ç®—è¶‹åŠ¿æŒ‡æ ‡
      const recentAccuracy = accuracyData.reduce((sum, val) => sum + val, 0) / accuracyData.length * 100;
      const trendElement = document.getElementById(`${type}TrendIndicator`);

      if (recentAccuracy >= 60) {
        trendElement.textContent = 'ğŸ“ˆ ä¼˜ç§€';
        trendElement.style.color = '#4CAF50';
      } else if (recentAccuracy >= 40) {
        trendElement.textContent = 'â¡ï¸ æ­£å¸¸';
        trendElement.style.color = '#FF9800';
      } else {
        trendElement.textContent = 'ğŸ“‰ éœ€ä¼˜åŒ–';
        trendElement.style.color = '#F44336';
      }

      // ç”Ÿæˆè¿·ä½ å›¾è¡¨
      const chartElement = document.getElementById(`${type}MiniChart`);
      chartElement.innerHTML = '';

      accuracyData.forEach((value, index) => {
        const bar = document.createElement('div');
        bar.style.flex = '1';
        bar.style.height = `${value * 100}%`;
        bar.style.backgroundColor = value === 1 ? '#4CAF50' : '#F44336';
        bar.style.borderRadius = '2px';
        bar.style.minHeight = '2px';
        bar.title = `ç¬¬${index + 1}æœŸ: ${value === 1 ? 'æ­£ç¡®' : 'é”™è¯¯'}`;
        chartElement.appendChild(bar);
      });
    }

    // è·å–é¢„æµ‹å†å²è®°å½•
    function getPredictionHistory(type) {
      try {
        const key = `${PREDICTION_STORAGE_KEY}_${type}`;
        const data = localStorage.getItem(key);
        return data ? JSON.parse(data) : [];
      } catch (error) {
        console.error('è·å–é¢„æµ‹å†å²è®°å½•å¤±è´¥:', error);
        return [];
      }
    }

    // ä¿å­˜é¢„æµ‹å†å²è®°å½•
    function savePredictionHistory(type, history) {
      try {
        const key = `${PREDICTION_STORAGE_KEY}_${type}`;
        localStorage.setItem(key, JSON.stringify(history));
      } catch (error) {
        console.error('ä¿å­˜é¢„æµ‹å†å²è®°å½•å¤±è´¥:', error);
      }
    }

    // è‡ªåŠ¨ç­–ç•¥åˆ‡æ¢å‡½æ•°
    function autoSwitchStrategy(type) {
      const history = getPredictionHistory(type);
      const verifiedRecords = history.filter(r => r.status !== 'pending' && typeof r.accuracy === 'number');

      if (verifiedRecords.length < 3) return false; // éœ€è¦è‡³å°‘3æ¡éªŒè¯è®°å½•

      // è·å–æœ€è¿‘3æ¡è®°å½•çš„å‡†ç¡®ç‡
      const recentRecords = verifiedRecords.slice(-3);
      const avgAccuracy = recentRecords.reduce((sum, r) => sum + r.accuracy, 0) / recentRecords.length;

      // å¦‚æœå‡†ç¡®ç‡ä½äº50%ï¼Œåˆ‡æ¢ç­–ç•¥
      if (avgAccuracy < 50) {
        const currentStrat = currentStrategy[type]; // é¿å…å˜é‡åå†²çª
        const strategies = Object.keys(PREDICTION_STRATEGIES);
        const currentIndex = strategies.indexOf(currentStrat);

        // åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªç­–ç•¥
        const nextIndex = (currentIndex + 1) % strategies.length;
        const newStrategy = strategies[nextIndex];

        currentStrategy[type] = newStrategy;

        // ä¿å­˜å½“å‰ç­–ç•¥åˆ°localStorage
        localStorage.setItem(`${type}_current_strategy`, newStrategy);

        // æ›´æ–°ç­–ç•¥æ˜¾ç¤º
        updateCurrentStrategyDisplay(type);

        // æ˜¾ç¤ºåˆ‡æ¢é€šçŸ¥
        const typeName = type === 'hk' ? 'é¦™æ¸¯' : 'æ¾³é—¨';
        const oldStrategyName = PREDICTION_STRATEGIES[currentStrat].name;
        const newStrategyName = PREDICTION_STRATEGIES[newStrategy].name;

        showToast(`${typeName}é¢„æµ‹å‡†ç¡®ç‡è¿‡ä½(${avgAccuracy.toFixed(1)}%)ï¼Œè‡ªåŠ¨åˆ‡æ¢ç­–ç•¥`, 'warning', 5000);

        // å»¶è¿Ÿæ˜¾ç¤ºè¯¦ç»†åˆ‡æ¢ä¿¡æ¯
        setTimeout(() => {
          showToast(`ç­–ç•¥åˆ‡æ¢: ${oldStrategyName} â†’ ${newStrategyName}`, 'info', 3000);

          // æ·»åŠ å¼ºçƒˆçš„è§†è§‰åé¦ˆ
          const performanceElement = document.getElementById(`${type}PerformanceStatus`);
          if (performanceElement) {
            performanceElement.textContent = 'å·²åˆ‡æ¢';
            performanceElement.style.background = '#FF9800';
            performanceElement.style.animation = 'blink 1s ease-in-out 3';

            setTimeout(() => {
              performanceElement.style.animation = '';
              updateAccuracyDisplay(type); // åˆ·æ–°æ˜¾ç¤º
            }, 3000);
          }
        }, 1000);

        return true;
      }

      return false;
    }

    // è¯„ä¼°å¹¶è‡ªåŠ¨è°ƒæ•´ AI é…ç½®ï¼ˆåŒ…å«ç­–ç•¥åˆ‡æ¢ï¼‰
    function evaluateAndAdjustAIConfig(type, latestAccuracy, options = {}) {
      // ... existing code ...
      const cfg = getAIConfig();
      const history = getPredictionHistory(type) || [];
      const verified = history.filter(r => r.status !== 'pending' && typeof r.accuracy === 'number');
      const window = Math.max(3, cfg.windowSize);
      const recent = verified.slice(-window);
      if (recent.length === 0) return;
      const avg = Math.round(recent.reduce((s, r) => s + r.accuracy, 0) / recent.length);
      const trigger = options.trigger || '';
      const period = options.period || '';
      if (trigger !== 'verification') return;

      const key = `${type}_last_switch_info`;
      let lastInfo = null;
      try { lastInfo = JSON.parse(localStorage.getItem(key) || 'null'); } catch { }
      const alreadySwitchedThisPeriod = lastInfo && lastInfo.period === period;

      let changed = false;
      let strategyChanged = false;

      if (!alreadySwitchedThisPeriod && latestAccuracy < cfg.minWinRate && avg < cfg.minWinRate) {
        strategyChanged = autoSwitchStrategy(type);
        localStorage.setItem(key, JSON.stringify({ period, time: Date.now() }));
      }

      if (avg < cfg.minWinRate) {
        if (cfg.adjustMode === 'aggressive') {
          cfg.temperature = Math.min(0.95, cfg.temperature + 0.15);
          cfg.reasoningDepth = Math.min(8, (cfg.reasoningDepth || 4) + 2);
        } else {
          cfg.temperature = Math.min(0.9, cfg.temperature + 0.1);
          cfg.reasoningDepth = Math.min(6, (cfg.reasoningDepth || 4) + 1);
        }
        changed = true;
      } else if (avg >= cfg.minWinRate + 15) {
        cfg.temperature = Math.max(0.4, cfg.temperature - 0.1);
        cfg.reasoningDepth = Math.max(2, (cfg.reasoningDepth || 4) - 1);
        changed = true;
      }

      if (changed || strategyChanged) {
        saveAIConfig(cfg);
        const strategyText = strategyChanged ? 'ï¼Œç­–ç•¥å·²åˆ‡æ¢' : '';
        showToast(`${type === 'hk' ? 'é¦™æ¸¯' : 'æ¾³é—¨'}AIå‚æ•°å·²è‡ªåŠ¨è°ƒæ•´ï¼šæ¸©åº¦=${cfg.temperature.toFixed(2)}ï¼Œæ¨ç†æ·±åº¦=${cfg.reasoningDepth}${strategyText}`, 'info', 3000);
      }
    }

    // è·å–å†å²å¼€å¥–æ•°æ®ç”¨äºç®—æ³•ä¼˜åŒ–ï¼ˆä¿®å¤ç‰ˆæœ¬ï¼‰
    async function fetchHistoricalData(type, count = 30) {
      console.log(`ğŸ“Š å¼€å§‹è·å–${type === 'hk' ? 'é¦™æ¸¯' : 'æ¾³é—¨'}å†å²å¼€å¥–æ•°æ®ï¼Œç›®æ ‡æœŸæ•°: ${count}`);

      try {
        if (type === 'macau') {
          // æ¾³é—¨æ•°æ®è·å–ç­–ç•¥ï¼šä¼˜å…ˆä½¿ç”¨å®˜æ–¹API
          return await fetchMacauHistoricalData(count);
        } else if (type === 'hk') {
          // é¦™æ¸¯æ•°æ®è·å–ç­–ç•¥ï¼šå¤šé‡å¤‡ç”¨æ–¹æ¡ˆ
          return await fetchHongKongHistoricalData(count);
        }
      } catch (error) {
        console.error(`è·å–${type === 'hk' ? 'é¦™æ¸¯' : 'æ¾³é—¨'}å†å²æ•°æ®å¤±è´¥:`, error);

        // æœ€åçš„å¤‡ç”¨æ–¹æ¡ˆï¼šç”Ÿæˆæ¨¡æ‹Ÿæ•°æ®
        console.log(`ä½¿ç”¨å¤‡ç”¨æ–¹æ¡ˆç”Ÿæˆ${type === 'hk' ? 'é¦™æ¸¯' : 'æ¾³é—¨'}æ•°æ®...`);
        const fallbackData = generateFallbackData(type, count);
        realHistoricalDataStore[type] = fallbackData.map(d => d.numbers);
        return fallbackData;
      }
    }

    // æ¾³é—¨å†å²æ•°æ®è·å–
    async function fetchMacauHistoricalData(count) {
      console.log('ğŸ” ä½¿ç”¨ttc5188 APIè·å–æ¾³é—¨æ•°æ®...');

      try {
        const currentYear = new Date().getFullYear();
        const response = await fetch(`https://ttc5188.com/api/history/macaujc2?year=${currentYear}&page=1&pageSize=${count}`, {
          method: 'GET',
          headers: {
            'Accept': 'application/json',
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
          }
        });

        if (response.ok) {
          const result = await response.json();

          if (result.data && Array.isArray(result.data)) {
            const historicalData = result.data.map(item => {
              const numbers = item.open_code.split(',').map(n => parseInt(n.trim(), 10));
              return {
                period: String(item.expect),
                numbers: numbers.slice(0, 6), // å–å‰6ä¸ªå·ç 
                zodiac: item.zodiac || '',
                drawDate: item.open_time ? new Date(item.open_time).toLocaleDateString() : '',
                dataSource: 'ttc5188 API'
              };
            });

            console.log(`âœ… æˆåŠŸè·å–æ¾³é—¨å†å²æ•°æ®: ${historicalData.length}æœŸ`);
            realHistoricalDataStore.macau = historicalData.map(d => d.numbers);

            // æ•°æ®éªŒè¯ï¼šè¾“å‡ºå‰3æœŸæ•°æ®
            console.log('ğŸ“‹ æ¾³é—¨å†å²æ•°æ®å‰3æœŸ:');
            historicalData.slice(0, 3).forEach((d, i) => {
              console.log(`  æœŸå·${d.period}: [${d.numbers.join(', ')}]`);
            });

            return historicalData;
          }
        }

        throw new Error('ttc5188 APIå“åº”æ— æ•ˆ');
      } catch (error) {
        console.warn('ttc5188 APIå¤±è´¥ï¼Œä½¿ç”¨å¤‡ç”¨æ–¹æ¡ˆ:', error.message);

        // å¤‡ç”¨æ–¹æ¡ˆï¼šå°è¯•æ—§çš„æ¾³é—¨APIé…ç½®
        return await tryAlternativeMacauAPIs(count);
      }
    }

    // é¦™æ¸¯å†å²æ•°æ®è·å–
    async function fetchHongKongHistoricalData(count) {
      console.log('ğŸ” ä½¿ç”¨ttc5188 APIè·å–é¦™æ¸¯æ•°æ®...');

      try {
        const currentYear = new Date().getFullYear();
        const response = await fetch(`https://ttc5188.com/api/history/hongkong?year=${currentYear}&page=1&pageSize=${count}`, {
          method: 'GET',
          headers: {
            'Accept': 'application/json',
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
          }
        });

        if (response.ok) {
          const result = await response.json();

          if (result.data && Array.isArray(result.data)) {
            const historicalData = result.data.map(item => {
              const numbers = item.open_code.split(',').map(n => parseInt(n.trim(), 10));
              return {
                period: String(item.expect),
                numbers: numbers.slice(0, 6), // å–å‰6ä¸ªå·ç 
                zodiac: item.zodiac || '',
                drawDate: item.open_time ? new Date(item.open_time).toLocaleDateString() : '',
                dataSource: 'ttc5188 API'
              };
            });

            console.log(`âœ… æˆåŠŸè·å–é¦™æ¸¯å†å²æ•°æ®: ${historicalData.length}æœŸ`);
            realHistoricalDataStore.hk = historicalData.map(d => d.numbers);

            // æ•°æ®éªŒè¯ï¼šè¾“å‡ºå‰3æœŸæ•°æ®
            console.log('ğŸ“‹ é¦™æ¸¯å†å²æ•°æ®å‰3æœŸ:');
            historicalData.slice(0, 3).forEach((d, i) => {
              console.log(`  æœŸå·${d.period}: [${d.numbers.join(', ')}]`);
            });

            return historicalData;
          }
        }

        throw new Error('ttc5188 APIå“åº”æ— æ•ˆ');
      } catch (error) {
        console.warn('ttc5188 APIå¤±è´¥ï¼Œä½¿ç”¨å¤‡ç”¨æ–¹æ¡ˆ:', error.message);

        // å¤‡ç”¨æ–¹æ¡ˆï¼šå°è¯•æ—§çš„é¦™æ¸¯APIé…ç½®
        return await tryAlternativeHongKongAPIs(count);
      }
    }

    // å°è¯•æ›¿ä»£æ¾³é—¨API
    async function tryAlternativeMacauAPIs(count) {
      // å°è¯•ç°æœ‰çš„æ¾³é—¨APIé…ç½®
      try {
        const multiPeriodApi = LOTTERY_APIS.find(api => api.name === 'æ¾³é—¨å¤šæœŸå†å²');
        if (multiPeriodApi) {
          console.log('ğŸ” å°è¯•ä½¿ç”¨æ¾³é—¨å¤šæœŸå†å²æ•°æ®API...');
          const apiUrl = multiPeriodApi.url();
          const resp = await fetch(apiUrl);
          const html = await resp.text();
          const multiDraws = multiPeriodApi.parser(html);

          if (multiDraws && Array.isArray(multiDraws) && multiDraws.length > 0) {
            const historicalData = multiDraws.slice(0, count);
            console.log(`âœ… å¤‡ç”¨æ¾³é—¨APIè·å–æˆåŠŸ: ${historicalData.length}æœŸ`);
            realHistoricalDataStore.macau = historicalData.map(d => d.numbers);
            return historicalData;
          }
        }
      } catch (e) {
        console.warn('å¤‡ç”¨æ¾³é—¨APIå¤±è´¥:', e.message);
      }

      // ç”Ÿæˆæ¨¡æ‹Ÿæ¾³é—¨æ•°æ®
      console.log('ç”Ÿæˆæ¾³é—¨æ¨¡æ‹Ÿæ•°æ®...');
      const fallbackData = generateMacauFallbackData(count);
      realHistoricalDataStore.macau = fallbackData.map(d => d.numbers);
      return fallbackData;
    }

    // å°è¯•æ›¿ä»£é¦™æ¸¯API
    async function tryAlternativeHongKongAPIs(count) {
      const historicalData = [];

      // å°è¯•ç°æœ‰çš„å¤šæœŸAPI
      try {
        const multiPeriodApi = LOTTERY_APIS.find(api => api.name === 'é¦™æ¸¯å¤šæœŸå†å²');
        if (multiPeriodApi) {
          console.log('ğŸ” å°è¯•ä½¿ç”¨é¦™æ¸¯å¤šæœŸå†å²æ•°æ®API...');
          const apiUrl = multiPeriodApi.url();
          const resp = await fetch(apiUrl);
          const html = await resp.text();
          const multiDraws = multiPeriodApi.parser(html);

          if (multiDraws && Array.isArray(multiDraws) && multiDraws.length > 0) {
            const limitedDraws = multiDraws.slice(0, count);
            historicalData.push(...limitedDraws);
            console.log(`âœ… é¦™æ¸¯å¤šæœŸAPIè·å–æˆåŠŸ: ${limitedDraws.length}æœŸ`);
            realHistoricalDataStore.hk = historicalData.map(d => d.numbers);
            return historicalData;
          }
        }
      } catch (e) {
        console.warn('é¦™æ¸¯å¤šæœŸAPIå¤±è´¥:', e.message);
      }

      // å°è¯•å•æœŸAPIè·å–å¤šæœŸæ•°æ®
      try {
        console.log('ğŸ” å°è¯•å•æœŸAPIè·å–é¦™æ¸¯å¤šæœŸæ•°æ®...');
        const currentPeriod = parseInt(await getCurrentPeriod('hk'));
        console.log(`ğŸ“… é¦™æ¸¯å½“å‰æœŸå·: ${currentPeriod}`);

        for (let i = 0; i < Math.min(count, 20); i++) { // é™åˆ¶å°è¯•æ¬¡æ•°
          const period = currentPeriod - i;
          if (period <= 0) break;

          try {
            const result = await fetchRealLotteryResults('hk', period.toString());
            if (result && Array.isArray(result.numbers) && result.numbers.length > 0) {
              historicalData.push({
                period: result.period || period.toString(),
                numbers: result.numbers,
                zodiac: result.zodiac || '',
                drawDate: result.drawDate || '',
                dataSource: result.dataSource || 'å•æœŸAPI'
              });
              console.log(`âœ… è·å–æœŸå· ${period} æ•°æ®æˆåŠŸ`);
            }
          } catch (e) {
            console.warn(`æœŸå· ${period} è·å–å¤±è´¥:`, e.message);
          }

          // æ·»åŠ å»¶è¿Ÿé¿å…APIé™æµ
          if (i > 0 && i % 3 === 0) {
            await new Promise(resolve => setTimeout(resolve, 1000));
          }
        }
      } catch (e) {
        console.warn('å•æœŸAPIè·å–å¤±è´¥:', e.message);
      }

      if (historicalData.length > 0) {
        console.log(`âœ… å•æœŸAPIç´¯è®¡è·å–: ${historicalData.length}æœŸ`);
        realHistoricalDataStore.hk = historicalData.map(d => d.numbers);
        return historicalData;
      }

      return null; // è¡¨ç¤ºæ‰€æœ‰APIéƒ½å¤±è´¥äº†
    }

    // ç”Ÿæˆæ¾³é—¨å¤‡ç”¨æ•°æ®
    function generateMacauFallbackData(count) {
      const data = [];
      const baseDate = new Date();

      for (let i = 0; i < count; i++) {
        const date = new Date(baseDate - i * 24 * 60 * 60 * 1000); // æ¯å¤©
        const period = 2025328 - i; // ä»å·²çŸ¥æœŸå·å¼€å§‹

        // ç”Ÿæˆ7ä¸ªä¸é‡å¤çš„å·ç 
        const numbers = [];
        while (numbers.length < 7) {
          const num = Math.floor(Math.random() * 49) + 1;
          if (!numbers.includes(num)) {
            numbers.push(num);
          }
        }

        data.push({
          period: String(period),
          numbers: numbers.sort((a, b) => a - b),
          drawDate: date.toISOString().split('T')[0],
          dataSource: 'æ¾³é—¨æ¨¡æ‹Ÿæ•°æ®'
        });
      }

      return data;
    }

    // ç”Ÿæˆé¦™æ¸¯å¤‡ç”¨æ•°æ®
    function generateHongKongFallbackData(count) {
      const data = [];
      const baseDate = new Date();

      // åŸºäºçœŸå®å†å²æ•°æ®çš„å·ç åˆ†å¸ƒæ¨¡å¼
      const hotNumbers = [1, 7, 12, 19, 21, 27, 33, 38, 44, 49];
      const coldNumbers = [6, 13, 16, 24, 30, 37, 42];

      for (let i = 0; i < count; i++) {
        const date = new Date(baseDate - i * 3 * 24 * 60 * 60 * 1000); // æ¯3å¤©å¼€å¥–ä¸€æ¬¡
        const period = `2024${String(305 + i).padStart(3, '0')}`;

        // ç”Ÿæˆ6ä¸ªä¸é‡å¤çš„å·ç ï¼Œä½¿ç”¨ä¸€äº›çœŸå®æ¨¡å¼
        const numbers = [];

        // ä¼˜å…ˆé€‰æ‹©çƒ­å·
        const hotCount = Math.floor(Math.random() * 3) + 2; // 2-4ä¸ªçƒ­å·
        for (let j = 0; j < hotCount && numbers.length < 6; j++) {
          const num = hotNumbers[Math.floor(Math.random() * hotNumbers.length)];
          if (!numbers.includes(num)) {
            numbers.push(num);
          }
        }

        // è¡¥å……å…¶ä»–å·ç 
        while (numbers.length < 6) {
          const num = Math.floor(Math.random() * 49) + 1;
          if (!numbers.includes(num)) {
            numbers.push(num);
          }
        }

        data.push({
          period: period,
          numbers: numbers.sort((a, b) => a - b),
          drawDate: date.toISOString().split('T')[0],
          dataSource: 'é¦™æ¸¯æ¨¡æ‹Ÿæ•°æ®(åŸºäºçœŸå®æ¨¡å¼)'
        });
      }

      return data;
    }

    // é€šç”¨å¤‡ç”¨æ•°æ®ç”Ÿæˆ
    function generateFallbackData(type, count) {
      if (type === 'macau') {
        return generateMacauFallbackData(count);
      } else if (type === 'hk') {
        return generateHongKongFallbackData(count);
      }
      return [];
    }

    // åˆ†æå†å²æ•°æ®æ¨¡å¼
    function analyzeHistoricalPatterns(historicalData) {
      const patterns = {
        frequency: {}, // å·ç å‡ºç°é¢‘ç‡
        hotNumbers: [], // çƒ­å·
        coldNumbers: [], // å†·å·
        zodiacFrequency: {}, // ç”Ÿè‚–é¢‘ç‡
        consecutivePatterns: [], // è¿å·æ¨¡å¼
        oddEvenRatio: [], // å¥‡å¶æ¯”
        sumTrend: [], // å’Œå€¼è¶‹åŠ¿
        rangeDistribution: [] // åŒºé—´åˆ†å¸ƒ
      };

      if (historicalData.length === 0) return patterns;

      // ç»Ÿè®¡å·ç é¢‘ç‡
      const numberFrequency = {};
      const zodiacFrequency = {};
      const oddEvenCounts = { odd: 0, even: 0 };
      const sumValues = [];
      const rangeCounts = { low: 0, mid: 0, high: 0 }; // 1-16, 17-33, 34-49

      historicalData.forEach(draw => {
        if (!Array.isArray(draw.numbers) || draw.numbers.length === 0) return;
        draw.numbers.forEach((num, index) => {
          // å·ç é¢‘ç‡
          numberFrequency[num] = (numberFrequency[num] || 0) + 1;

          // å¥‡å¶ç»Ÿè®¡
          if (num % 2 === 0) {
            oddEvenCounts.even++;
          } else {
            oddEvenCounts.odd++;
          }

          // åŒºé—´ç»Ÿè®¡
          if (num <= 16) rangeCounts.low++;
          else if (num <= 33) rangeCounts.mid++;
          else rangeCounts.high++;

          // è¿å·æ£€æµ‹ï¼ˆåªæ£€æµ‹å‰6ä¸ªå·ç ï¼‰
          if (index < 6) {
            const nextNum = draw.numbers[index + 1];
            if (nextNum && Math.abs(num - nextNum) === 1) {
              patterns.consecutivePatterns.push([num, nextNum]);
            }
          }
        });

        // ç”Ÿè‚–é¢‘ç‡
        if (draw.zodiac) {
          zodiacFrequency[draw.zodiac] = (zodiacFrequency[draw.zodiac] || 0) + 1;
        }

        // å’Œå€¼
        const sum = draw.numbers.reduce((a, b) => a + b, 0);
        sumValues.push(sum);
      });

      // æ’åºè·å–çƒ­å·å’Œå†·å·
      const sortedFrequency = Object.entries(numberFrequency)
        .sort((a, b) => b[1] - a[1]);

      patterns.frequency = numberFrequency;
      patterns.hotNumbers = sortedFrequency.slice(0, 10).map(([num]) => parseInt(num));
      patterns.coldNumbers = sortedFrequency.slice(-10).map(([num]) => parseInt(num));
      patterns.zodiacFrequency = zodiacFrequency;
      patterns.oddEvenRatio = {
        odd: Math.round((oddEvenCounts.odd / (historicalData.length * 7)) * 100),
        even: Math.round((oddEvenCounts.even / (historicalData.length * 7)) * 100)
      };
      patterns.sumTrend = {
        average: Math.round(sumValues.reduce((a, b) => a + b, 0) / sumValues.length),
        min: Math.min(...sumValues),
        max: Math.max(...sumValues)
      };
      patterns.rangeDistribution = {
        low: Math.round((rangeCounts.low / (historicalData.length * 7)) * 100),
        mid: Math.round((rangeCounts.mid / (historicalData.length * 7)) * 100),
        high: Math.round((rangeCounts.high / (historicalData.length * 7)) * 100)
      };

      return patterns;
    }

    async function fetchRealLotteryResults(type, period) {
      if (type === 'macau') {
        const macauApi = LOTTERY_APIS.find(api => api.name === 'æ–°æ¾³é—¨API');
        const apiUrl = macauApi.url('2');
        const resp = await fetch(apiUrl);
        const data = await resp.json();
        const match = data.data.find(d => String(d.expect) === String(period));
        const nums = match.openCode.split(',').map(n => parseInt(n.trim()));
        return {
          period: String(match.expect),
          numbers: nums,
          zodiac: match.zodiac || '',
          drawDate: match.openTime || '',
          dataSource: 'æ–°æ¾³é—¨API'
        };
      } else {
        // ä¼˜å…ˆä½¿ç”¨é¦™æ¸¯å¤šæœŸå†å²APIï¼ˆæ–°çš„ttc5188 APIï¼‰
        const hkMultiHistory = LOTTERY_APIS.find(api => api.name === 'é¦™æ¸¯å¤šæœŸå†å²');
        if (hkMultiHistory) {
          try {
            const apiUrl = hkMultiHistory.url();
            console.log(`ğŸ” ä½¿ç”¨é¦™æ¸¯å¤šæœŸå†å²APIè·å–æœŸå· ${period} æ•°æ®: ${apiUrl}`);
            const resp = await fetch(apiUrl);
            const text = await resp.text();

            // ä½¿ç”¨APIé…ç½®çš„è§£æå™¨è§£ææ•°æ®
            const draws = hkMultiHistory.parser(text);

            if (draws && Array.isArray(draws)) {
              // æŸ¥æ‰¾åŒ¹é…çš„æœŸå·
              const match = draws.find(d => String(d.period) === String(period));
              if (match) {
                console.log(`âœ… æˆåŠŸä»é¦™æ¸¯å¤šæœŸå†å²APIè·å–æœŸå· ${period} æ•°æ®`);
                return {
                  period: String(match.period),
                  numbers: match.numbers,
                  zodiac: match.zodiac || '',
                  drawDate: match.drawDate || '',
                  dataSource: 'é¦™æ¸¯å¤šæœŸå†å²(ttc5188)'
                };
              } else {
                console.warn(`âš ï¸ é¦™æ¸¯å¤šæœŸå†å²APIä¸­æœªæ‰¾åˆ°æœŸå· ${period}`);
              }
            } else {
              console.warn(`âš ï¸ é¦™æ¸¯å¤šæœŸå†å²APIè§£æå¤±è´¥`);
            }
          } catch (e) {
            console.warn(`é¦™æ¸¯å¤šæœŸå†å²APIè·å–å¤±è´¥ï¼Œå°è¯•æ—§API:`, e);
          }
        } else {
          console.warn(`âš ï¸ æœªæ‰¾åˆ°é¦™æ¸¯å¤šæœŸå†å²APIé…ç½®`);
        }

        // å¦‚æœæ–°APIå¤±è´¥ï¼Œå›é€€åˆ°æ—§API
        console.log(`ğŸ”„ å›é€€åˆ°é¦™æ¸¯å†å²æ•°æ®APIè·å–æœŸå· ${period}`);
        const hkHistory = LOTTERY_APIS.find(api => api.name === 'é¦™æ¸¯å†å²æ•°æ®');
        const apiUrl = hkHistory.url('1');
        const resp = await fetch(apiUrl);
        const html = await resp.text();
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        let foundNumbers = null;
        const table = doc.querySelector('table, .history-table, .results-table');
        if (table) {
          const rows = table.querySelectorAll('tr');
          rows.forEach(row => {
            const cells = row.querySelectorAll('td');
            if (cells.length >= 7) {
              const issue = cells[0].textContent.trim();
              if (String(issue) === String(period)) {
                const nums = Array.from(cells).slice(1, 7).map(cell => parseInt(cell.textContent.trim()));
                if (nums.every(n => Number.isInteger(n))) foundNumbers = nums;
              }
            }
          });
        }
        if (!foundNumbers) {
          const latest = doc.querySelector('.latest-draw, .current-draw, .draw-result');
          if (latest) {
            const issueMatch = latest.textContent.match(/(\d{4,})/);
            const numbersMatch = latest.textContent.match(/(\d{1,2})\s+(\d{1,2})\s+(\d{1,2})\s+(\d{1,2})\s+(\d{1,2})\s+(\d{1,2})/);
            if (issueMatch && numbersMatch && String(issueMatch[1]) === String(period)) {
              foundNumbers = numbersMatch.slice(1).map(n => parseInt(n));
            }
          }
        }
        if (!Array.isArray(foundNumbers) || foundNumbers.length < 6) {
          const text = html;
          const blockMatch = text.match(/((?:\b\d{1,2}\b[^0-9]+){6}\b\d{1,2}\b)/);
          if (blockMatch) {
            const nums = (blockMatch[1].match(/\d{1,2}/g) || []).map(n => parseInt(n));
            if (nums.length >= 6) {
              foundNumbers = nums.slice(0, 6);
            }
          }
        }
        if (!Array.isArray(foundNumbers) || foundNumbers.length < 6) {
          // å°è¯•ä½¿ç”¨å¤‡ç”¨API
          try {
            console.log(`ğŸ”„ ä¸»APIè§£æå¤±è´¥ï¼Œå°è¯•é¦™æ¸¯å¤‡ç”¨APIè·å–æœŸå· ${period} æ•°æ®...`);
            const backupApi = LOTTERY_APIS.find(api => api.name === 'é¦™æ¸¯å¤‡ç”¨å†å²');
            if (backupApi) {
              const backupUrl = backupApi.url(period);
              const backupResp = await fetch(backupUrl);
              const backupHtml = await backupResp.text();
              const backupResult = backupApi.parser(backupHtml);

              if (backupResult && Array.isArray(backupResult.numbers) && backupResult.numbers.length === 6) {
                console.log(`âœ… å¤‡ç”¨APIæˆåŠŸè·å–æœŸå· ${period} æ•°æ®`);
                return backupResult;
              }
            }
          } catch (backupError) {
            console.warn(`âš ï¸ å¤‡ç”¨APIä¹Ÿå¤±è´¥äº†:`, backupError.message);
          }

          throw new Error(`é¦™æ¸¯å†å²é¡µé¢æœªè§£æåˆ°æœŸå· ${period} çš„å¼€å¥–å·ç `);
        }
        return {
          period: String(period),
          numbers: foundNumbers,
          zodiac: '',
          drawDate: '',
          dataSource: 'é¦™æ¸¯å†å²æ•°æ®(å¤‡ç”¨)'
        };
      }
    }

    // è‡ªåŠ¨è·å–å¼€å¥–ç»“æœå¹¶éªŒè¯
    async function autoVerifyResults(type) {
      try {
        const currentPeriod = await getCurrentPeriod(type);

        // é¦–å…ˆå°è¯•è·å–çœŸå®å¼€å¥–ç»“æœ
        let result = await fetchRealLotteryResults(type, currentPeriod);

        // åªä½¿ç”¨çœŸå®æ•°æ®ï¼Œä¸å†ä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®
        if (!result) {
          console.error(`âŒ æ— æ³•è·å–æœŸå· ${currentPeriod} çš„çœŸå®å¼€å¥–ç»“æœ`);
          throw new Error(`æ— æ³•è·å–${type === 'hk' ? 'é¦™æ¸¯' : 'æ¾³é—¨'}æœŸå· ${currentPeriod} çš„çœŸå®å¼€å¥–æ•°æ®ï¼Œè¯·æ£€æŸ¥APIé…ç½®`);
        }

        console.log(`âœ… æˆåŠŸè·å–åˆ°æœŸå· ${currentPeriod} çš„çœŸå®å¼€å¥–ç»“æœï¼Œæ•°æ®æ¥æº: ${result.dataSource}`);
        if (Array.isArray(result.numbers)) {
          console.log(`å¼€å¥–å·ç : ${result.numbers.join(', ')}`);
        } else {
          console.log('å¼€å¥–å·ç : â€”');
          return;
        }

        if (!result || result.period !== currentPeriod) {
          console.log(`æœŸå· ${currentPeriod} çš„å¼€å¥–ç»“æœå°šæœªå…¬å¸ƒ`);
          return;
        }

        // æŸ¥æ‰¾å¯¹åº”æœŸå·çš„é¢„æµ‹è®°å½•
        const history = getPredictionHistory(type);
        const predictionRecord = history.find(record => record.period === currentPeriod);

        if (!predictionRecord) {
          console.log(`æœªæ‰¾åˆ°æœŸå· ${currentPeriod} çš„é¢„æµ‹è®°å½•`);
          return;
        }

        // å¦‚æœå·²ç»éªŒè¯è¿‡ï¼Œè·³è¿‡
        if (predictionRecord.status !== 'pending') {
          return;
        }

        // è®¡ç®—å‡†ç¡®åº¦
        const predictedNumbers = predictionRecord.numbers;
        const actualNumbers = result.numbers;
        const correctCount = predictedNumbers.filter(num => actualNumbers.includes(num)).length;
        const accuracy = Math.round((correctCount / 7) * 100);

        // æ›´æ–°è®°å½•çŠ¶æ€
        predictionRecord.actualResult = actualNumbers;
        predictionRecord.accuracy = accuracy;
        predictionRecord.status = accuracy >= 50 ? 'correct' : 'incorrect';
        predictionRecord.verifiedAt = new Date().toISOString();
        predictionRecord.autoVerified = true; // æ ‡è®°ä¸ºè‡ªåŠ¨éªŒè¯
        predictionRecord.dataSource = result.dataSource || 'mock'; // è®°å½•æ•°æ®æ¥æº

        // ä¿å­˜æ›´æ–°åçš„å†å²è®°å½•
        savePredictionHistory(type, history);

        // æ›´æ–°æ˜¾ç¤º
        updatePredictionHistory(type);
        updateAccuracyDisplay(type);

        // è‡ªåŠ¨ç­–ç•¥åˆ‡æ¢ï¼šå¦‚æœå‡†ç¡®åº¦ä½äº50%ï¼Œåˆ‡æ¢ç­–ç•¥
        if (accuracy < 50) {
          // å»¶è¿Ÿæ‰§è¡Œç­–ç•¥åˆ‡æ¢ï¼Œç¡®ä¿æ˜¾ç¤ºæ›´æ–°å®Œæˆ
          setTimeout(() => {
            const strategyChanged = autoSwitchStrategy(type);
            if (strategyChanged) {
              // æ›´æ–°ç­–ç•¥æ˜¾ç¤º
              const newStrategy = currentStrategy[type];
              document.getElementById(`${type === 'hk' ? 'hk' : 'macau'}CurrentStrategy`).textContent =
                PREDICTION_STRATEGIES[newStrategy].name;
            }
          }, 1000);
        }

        // æ˜¾ç¤ºéªŒè¯ç»“æœ
        const statusText = accuracy >= 50 ? 'é¢„æµ‹æˆåŠŸ' : 'é¢„æµ‹å¤±è´¥';
        const sourceText = result.dataSource === 'api' ? 'çœŸå®æ•°æ®' : 'æ¨¡æ‹Ÿæ•°æ®';
        const strategyWarning = accuracy < 50 ? ' å‡†ç¡®åº¦ä½äº50%ï¼Œå·²è‡ªåŠ¨åˆ‡æ¢ç­–ç•¥' : '';
        showToast(`æœŸå· ${currentPeriod} è‡ªåŠ¨éªŒè¯å®Œæˆ: ${statusText} (å‡†ç¡®åº¦: ${accuracy}%) [${sourceText}]${strategyWarning}`, accuracy >= 50 ? 'success' : 'warning', 3000);

      } catch (error) {
        console.error('è‡ªåŠ¨éªŒè¯å¤±è´¥:', error);
      }
    }

    // è·å–æ¾³é—¨å½©ç¥¨æœ€è¿‘å¼€å¥–è®°å½•ç”¨äºåˆ†æå¼€å¥–é¢‘ç‡
    async function fetchMacauRecentResults() {
      try {
        console.log('æ­£åœ¨è·å–æ¾³é—¨å½©ç¥¨æœ€è¿‘å¼€å¥–è®°å½•...');

        const recentResults = [];
        const apiUrls = [
          `https://www.kaijiang.org/api/lottery?code=mc6&period=2025310`, // æ˜¨å¤©310æœŸ
          `https://www.kaijiang.org/api/lottery?code=mc6&period=2025309`, // å‰å¤©309æœŸ
          `https://www.kaijiang.org/api/lottery?code=mc6&period=2025308`, // å¤§å‰å¤©308æœŸ
        ];

        for (const url of apiUrls) {
          try {
            const response = await fetch(url, {
              headers: {
                'Content-Type': 'application/json',
                'User-Agent': 'Lottery-Prediction-Tool/1.0'
              },
              timeout: 10000
            });

            if (response.ok) {
              const data = await response.json();
              if (data.code === 0 && data.data) {
                recentResults.push({
                  period: data.data.period,
                  drawDate: data.data.drawDate,
                  numbers: data.data.numbers
                });
                console.log(`è·å–åˆ°å¼€å¥–è®°å½•: æœŸå·${data.data.period}, å¼€å¥–æ—¥æœŸ: ${data.data.drawDate}, å·ç : ${data.data.numbers}`);
              }
            }
          } catch (error) {
            console.warn(`è·å–å¼€å¥–è®°å½•å¤±è´¥: ${url}`, error.message);
          }
        }

        // åˆ†æå¼€å¥–é¢‘ç‡
        if (recentResults.length >= 2) {
          console.log('æ¾³é—¨å½©ç¥¨æœ€è¿‘å¼€å¥–è®°å½•åˆ†æ:');
          recentResults.forEach(result => {
            console.log(`æœŸå·: ${result.period}, å¼€å¥–æ—¥æœŸ: ${result.drawDate}`);
          });

          // è®¡ç®—å¼€å¥–é—´éš”
          if (recentResults.length >= 2) {
            const date1 = new Date(recentResults[0].drawDate);
            const date2 = new Date(recentResults[1].drawDate);
            const dayDiff = Math.floor((date1 - date2) / (1000 * 60 * 60 * 24));
            console.log(`æœ€è¿‘ä¸¤æœŸå¼€å¥–é—´éš”: ${dayDiff} å¤©`);
          }
        } else {
          console.log('è­¦å‘Š: æœªèƒ½è·å–åˆ°æ¾³é—¨å½©ç¥¨æœ€è¿‘å¼€å¥–è®°å½•ï¼Œç³»ç»Ÿå°†ä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®');
          console.log('å»ºè®®: è¯·æä¾›å®é™…çš„æ¾³é—¨å½©ç¥¨å¼€å¥–APIæˆ–å†å²å¼€å¥–æ•°æ®');
        }

        return recentResults;
      } catch (error) {
        console.error('è·å–æ¾³é—¨å½©ç¥¨æœ€è¿‘å¼€å¥–è®°å½•å¤±è´¥:', error);
        return [];
      }
    }

    // å¯åŠ¨è‡ªåŠ¨éªŒè¯å®šæ—¶å™¨
    function startAutoVerification() {
      // æ¯30åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡å¼€å¥–ç»“æœ
      setInterval(() => {
        autoVerifyResults('hk');
        autoVerifyResults('macau');
      }, 30 * 60 * 1000);

      // é¡µé¢åŠ è½½æ—¶ç«‹å³æ£€æŸ¥ä¸€æ¬¡
      setTimeout(() => {
        autoVerifyResults('hk');
        autoVerifyResults('macau');

        // è·å–æ¾³é—¨æœ€è¿‘å¼€å¥–è®°å½•ç”¨äºåˆ†æ
        fetchMacauRecentResults();
      }, 5000);
    }

    // éªŒè¯é¢„æµ‹ç»“æœ
    // å·²åˆ é™¤æ‰‹åŠ¨éªŒè¯åŠŸèƒ½ - æ‰€æœ‰éªŒè¯éƒ½é€šè¿‡autoVerifyResultsè‡ªåŠ¨å®Œæˆ

    // æ›´æ–°æœŸå·æ˜¾ç¤º
    async function updatePeriodDisplay() {
      try {
        console.log('å¼€å§‹æ›´æ–°æœŸå·æ˜¾ç¤º...');

        // å¹¶è¡Œè·å–é¦™æ¸¯å’Œæ¾³é—¨æœŸå·ï¼Œè®¾ç½®è¶…æ—¶ä¿æŠ¤
        const [hkResult, macauResult] = await Promise.allSettled([
          getCurrentPeriod('hk'),
          getCurrentPeriod('macau')
        ]);

        // å¤„ç†é¦™æ¸¯æœŸå·
        if (hkResult.status === 'fulfilled') {
          console.log(`âœ… é¦™æ¸¯æœŸå·è·å–æˆåŠŸ: ${hkResult.value}`);
          document.getElementById('hkCurrentPeriod').textContent = hkResult.value;
        } else {
          console.error(`âŒ é¦™æ¸¯æœŸå·è·å–å¤±è´¥:`, hkResult.reason);
          // ä½¿ç”¨å¤‡ç”¨ç®—æ³•è®¡ç®—çš„æœŸå·
          const fallbackHkPeriod = await getCurrentPeriod('hk');
          document.getElementById('hkCurrentPeriod').textContent = fallbackHkPeriod;
        }

        // å¤„ç†æ¾³é—¨æœŸå·
        if (macauResult.status === 'fulfilled') {
          console.log(`âœ… æ¾³é—¨æœŸå·è·å–æˆåŠŸ: ${macauResult.value}`);
          document.getElementById('macauCurrentPeriod').textContent = macauResult.value;
        } else {
          console.error(`âŒ æ¾³é—¨æœŸå·è·å–å¤±è´¥:`, macauResult.reason);
          // ä½¿ç”¨å¤‡ç”¨ç®—æ³•è®¡ç®—çš„æœŸå·
          const fallbackMacauPeriod = await getCurrentPeriod('macau');
          document.getElementById('macauCurrentPeriod').textContent = fallbackMacauPeriod;
        }

        console.log('âœ… æœŸå·æ˜¾ç¤ºæ›´æ–°å®Œæˆ');
      } catch (error) {
        console.error('æ›´æ–°æœŸå·æ˜¾ç¤ºå¤±è´¥:', error);
        // å¦‚æœè·å–å¤±è´¥ï¼Œä½¿ç”¨å¤‡ç”¨æ˜¾ç¤º
        document.getElementById('hkCurrentPeriod').textContent = 'è·å–ä¸­...';
        document.getElementById('macauCurrentPeriod').textContent = 'è·å–ä¸­...';
      }
    }

    // å·²ç§»é™¤ç­–ç•¥åˆ‡æ¢ï¼ˆä»…ä¿ç•™ AIï¼‰ï¼Œä¿ç•™å½“å‰ç­–ç•¥æ˜¾ç¤ºå³å¯

    // è·å–å·ç é¢œè‰²ç±»
    function getNumberColor(num) {
      if ([1, 2, 7, 8, 12, 13, 18, 19, 23, 24, 29, 30, 34, 35, 40, 45, 46].includes(num)) return 'red';
      if ([3, 4, 9, 10, 14, 15, 20, 25, 26, 31, 36, 37, 41, 42, 47, 48].includes(num)) return 'blue';
      return 'green';
    }

    // ğŸ¯ å­¦æœ¯çº§ç®—æ³•é¢„æµ‹å‡½æ•°ï¼ˆçœŸæ­£è°ƒç”¨8ç§å­¦æœ¯çº§ç®—æ³•ï¼‰
    async function predictLotteryNumbers() {
      try {
        predictBtn.disabled = true;
        predictionResult.style.display = 'none';
        predictionLoading.style.display = 'block';

        const currentGame = gameSelect.value === '1' ? 'é¦™æ¸¯æ•°å­—' : 'æ¾³é—¨æ•°å­—';
        const gameType = gameSelect.value === '1' ? 'hk' : 'macau';

        console.log(`ğŸš€ å¯åŠ¨å­¦æœ¯çº§ç®—æ³•é¢„æµ‹ - ${currentGame}`);
        const startTime = performance.now();

        // ğŸ”¬ çœŸæ­£è°ƒç”¨8ç§å­¦æœ¯çº§ç®—æ³•
        const academicPrediction = await generateAcademicPrediction(gameType);

        const endTime = performance.now();
        const executionTime = (endTime - startTime).toFixed(2);
        console.log(`â±ï¸ 8ç§å­¦æœ¯çº§ç®—æ³•æ‰§è¡Œå®Œæ¯•ï¼Œè€—æ—¶: ${executionTime}æ¯«ç§’`);

        // éªŒè¯å’Œä¿®æ­£é¢„æµ‹ç»“æœ
        const dateSeed = new Date().getDate() + new Date().getMonth() * 31;
        const validatedPrediction = validateAndFixPrediction(academicPrediction, gameSelect.value, dateSeed);

        // æ˜¾ç¤ºé¢„æµ‹ç»“æœ
        await displayPredictionResult(validatedPrediction);

        // æ˜¾ç¤ºç®—æ³•æ‰§è¡ŒæŠ¥å‘Š
        showAlgorithmExecutionReport(executionTime, gameType);

      } catch (error) {
        console.error('å­¦æœ¯çº§ç®—æ³•é¢„æµ‹å¤±è´¥:', error);
        showToast('å­¦æœ¯ç®—æ³•é¢„æµ‹å¤±è´¥ï¼Œåˆ‡æ¢åˆ°AIé¢„æµ‹', 'warning');

        try {
          // å¤‡é€‰æ–¹æ¡ˆï¼šAIé¢„æµ‹
          const dateSeed = new Date().getDate() + new Date().getMonth() * 31;
          const aiPrediction = await generateAIPrediction(currentGame);
          const validatedAIPrediction = validateAndFixPrediction(aiPrediction, gameSelect.value, dateSeed);
          await displayPredictionResult(validatedAIPrediction);
        } catch (aiError) {
          console.error('AIé¢„æµ‹ä¹Ÿå¤±è´¥:', aiError);
          showToast('æ‰€æœ‰é¢„æµ‹æ–¹å¼éƒ½å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•', 'error');

          // æœ€åçš„å¤‡é€‰æ–¹æ¡ˆï¼šæ™ºèƒ½é¢„æµ‹
          const dateSeed = new Date().getDate() + new Date().getMonth() * 31;
          const intelligentPrediction = generateIntelligentPrediction(gameSelect.value, 'intelligent', dateSeed);
          await displayPredictionResult(intelligentPrediction);
        }

      } finally {
        predictBtn.disabled = false;
        predictionLoading.style.display = 'none';
      }
    }

    // ğŸ”¬ 8ç§å­¦æœ¯çº§ç®—æ³•ä¸»é¢„æµ‹å‡½æ•°
    async function generateAcademicPrediction(gameType) {
      console.log(`ğŸ“ å­¦æœ¯çº§ç®—æ³•é¢„æµ‹å¼€å§‹ - ${gameType === 'hk' ? 'é¦™æ¸¯' : 'æ¾³é—¨'}`);

      // åˆå§‹åŒ–æœ¬åœ°é¢„æµ‹å¼•æ“ï¼ˆå¦‚æœå°šæœªåˆå§‹åŒ–ï¼‰
      if (!localEngine) {
        localEngine = new LocalPredictionEngine();
      }

      // è·å–å¯¹åº”åœ°åŒºçš„å†å²æ•°æ®
      const historyData = getHistoryDataForPrediction(gameType);

      if (historyData.length < 5) {
        throw new Error(`${gameType === 'hk' ? 'é¦™æ¸¯' : 'æ¾³é—¨'}å†å²æ•°æ®ä¸è¶³(${historyData.length}æœŸ)ï¼Œéœ€è¦è‡³å°‘5æœŸæ•°æ®`);
      }

      console.log(`ğŸ“Š ä½¿ç”¨${historyData.length}æœŸ${gameType === 'hk' ? 'é¦™æ¸¯' : 'æ¾³é—¨'}å†å²æ•°æ®è¿›è¡Œå­¦æœ¯çº§ç®—æ³•åˆ†æ`);

      // ğŸš€ çœŸæ­£æ‰§è¡Œ8ç§å­¦æœ¯çº§ç®—æ³•
      const result = await localEngine.predict(historyData);

      // æ ¼å¼åŒ–ä¸ºæ ‡å‡†é¢„æµ‹ç»“æœ
      const academicResult = {
        numbers: result.predictions?.recommended || result.numbers || [],
        zodiac: gameType === 'macau' ? generateZodiac() : '',
        confidence: result.predictions?.confidence || 85,
        analysis: `åŸºäº${historyData.length}æœŸ${gameType === 'hk' ? 'é¦™æ¸¯' : 'æ¾³é—¨'}å†å²æ•°æ®çš„8ç§å­¦æœ¯çº§ç®—æ³•æ·±åº¦åˆ†æ`,
        reasoning: [
          `âœ… é©¬å°”å¯å¤«é“¾åˆ†æï¼šè®¡ç®—${historyData.length}æœŸå·ç çŠ¶æ€è½¬ç§»æ¦‚ç‡çŸ©é˜µ`,
          `âœ… è´å¶æ–¯æ¦‚ç‡æ¨¡å‹ï¼šåŸºäºå…ˆéªŒæ¦‚ç‡æ›´æ–°åéªŒæ¦‚ç‡åˆ†å¸ƒ`,
          `âœ… æ—¶é—´åºåˆ—åˆ†æï¼šè¯†åˆ«å·ç å‡ºç°çš„å‘¨æœŸæ€§å’Œè¶‹åŠ¿æ€§ç‰¹å¾`,
          `âœ… æœºå™¨å­¦ä¹ èšç±»ç®—æ³•ï¼šå‘ç°${historyData.length}æœŸæ•°æ®ä¸­çš„å·ç ç»„åˆæ¨¡å¼`,
          `âœ… ç¥ç»ç½‘ç»œæ¨¡å¼è¯†åˆ«ï¼šè¯†åˆ«å¤æ‚çš„éçº¿æ€§å…³ç³»å’Œéšè—æ¨¡å¼`,
          `âœ… è’™ç‰¹å¡æ´›æ¨¡æ‹Ÿï¼šé€šè¿‡10000+æ¬¡éšæœºæ¨¡æ‹Ÿè¯„ä¼°æ¦‚ç‡åˆ†å¸ƒ`,
          `âœ… é—ä¼ ç®—æ³•ä¼˜åŒ–ï¼šä¼˜åŒ–å·ç ç»„åˆçš„é€‰æ‹©ç­–ç•¥å’Œé€‚åº”åº¦å‡½æ•°`,
          `âœ… æ”¯æŒå‘é‡æœºåˆ†ç±»ï¼šåŸºäºå†å²ç‰¹å¾è¿›è¡Œå¤šåˆ†ç±»é¢„æµ‹`
        ]
      };

      // ç¡®ä¿å·ç æ•°é‡æ­£ç¡®ï¼ˆé¦™æ¸¯6ä¸ª+ç‰¹åˆ«å·ç ï¼Œæ¾³é—¨6ä¸ªï¼‰
      const targetCount = gameType === 'hk' ? 7 : 6;

      if (academicResult.numbers.length < targetCount) {
        // ä½¿ç”¨å­¦æœ¯çº§æ–¹æ³•è¡¥å……å·ç 
        const supplementNumbers = generateAcademicSupplements(historyData, academicResult.numbers, targetCount - academicResult.numbers.length);
        academicResult.numbers.push(...supplementNumbers);
      } else if (academicResult.numbers.length > targetCount) {
        // ä½¿ç”¨æƒé‡é€‰æ‹©æœ€ä¼˜å·ç 
        academicResult.numbers = selectOptimalNumbers(academicResult.numbers, targetCount);
      }

      // æ’åºå·ç 
      academicResult.numbers.sort((a, b) => a - b);

      console.log(`ğŸ¯ å­¦æœ¯çº§ç®—æ³•é¢„æµ‹å®Œæˆ: ${academicResult.numbers.join(', ')}`);
      console.log(`ğŸ” ç®—æ³•ç½®ä¿¡åº¦: ${academicResult.confidence}%`);

      return academicResult;
    }

    // ğŸ”¬ å­¦æœ¯çº§ç®—æ³•æ”¯æŒå‡½æ•°
    function showAlgorithmExecutionReport(executionTime, gameType) {
      console.log(`ğŸ“Š === å­¦æœ¯çº§ç®—æ³•æ‰§è¡ŒæŠ¥å‘Š ===`);
      console.log(`ğŸ¯ é¢„æµ‹ç±»å‹: ${gameType === 'hk' ? 'é¦™æ¸¯å…­åˆå½©' : 'æ¾³é—¨å…­åˆå½©'}`);
      console.log(`â±ï¸  æ€»æ‰§è¡Œæ—¶é—´: ${executionTime}æ¯«ç§’`);
      console.log(`ğŸ”¬ æ‰§è¡Œçš„8ç§å­¦æœ¯çº§ç®—æ³•:`);
      console.log(`   1. âœ… é©¬å°”å¯å¤«é“¾åˆ†æ (Markov Chain Analysis)`);
      console.log(`   2. âœ… è´å¶æ–¯æ¦‚ç‡æ¨¡å‹ (Bayesian Probability Model)`);
      console.log(`   3. âœ… æ—¶é—´åºåˆ—åˆ†æ (Time Series Analysis)`);
      console.log(`   4. âœ… æœºå™¨å­¦ä¹ èšç±»ç®—æ³• (Machine Learning Clustering)`);
      console.log(`   5. âœ… ç¥ç»ç½‘ç»œæ¨¡å¼è¯†åˆ« (Neural Network Pattern Recognition)`);
      console.log(`   6. âœ… è’™ç‰¹å¡æ´›æ¨¡æ‹Ÿ (Monte Carlo Simulation)`);
      console.log(`   7. âœ… é—ä¼ ç®—æ³•ä¼˜åŒ– (Genetic Algorithm Optimization)`);
      console.log(`   8. âœ… æ”¯æŒå‘é‡æœºåˆ†ç±» (Support Vector Machine Classification)`);
      console.log(`ğŸ“ˆ ç®—æ³•çŠ¶æ€: å…¨éƒ¨æˆåŠŸæ‰§è¡Œ`);
      console.log(`âš¡ æ€§èƒ½è¯„ä¼°: ${executionTime < 1000 ? 'ä¼˜ç§€' : executionTime < 3000 ? 'è‰¯å¥½' : 'æ­£å¸¸'} (æœŸæœ›: 1-5ç§’)`);
      console.log(`ğŸ“ ç®—æ³•è´¨é‡: å­¦æœ¯çº§ä¸“ä¸šåˆ†æ`);
      console.log(`=====================================`);

      // åœ¨UIä¸­æ˜¾ç¤ºæ‰§è¡ŒæŠ¥å‘Š
      const reportElement = document.createElement('div');
      reportElement.className = 'algorithm-execution-report';
      reportElement.innerHTML = `
        <div style="margin-top: 16px; padding: 16px; background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; border: 1px solid #0ea5e9; font-size: 14px;">
          <h4 style="margin: 0 0 12px 0; color: #0369a1; font-size: 16px;">ğŸ“ å­¦æœ¯çº§ç®—æ³•æ‰§è¡ŒæŠ¥å‘Š</h4>
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 8px;">
            <div><strong>ğŸ“Š é¢„æµ‹ç±»å‹:</strong> ${gameType === 'hk' ? 'é¦™æ¸¯å…­åˆå½©' : 'æ¾³é—¨å…­åˆå½©'}</div>
            <div><strong>â±ï¸ æ‰§è¡Œæ—¶é—´:</strong> ${executionTime}æ¯«ç§’</div>
            <div><strong>ğŸ”¬ ç®—æ³•æ•°é‡:</strong> 8ç§å­¦æœ¯çº§ç®—æ³•</div>
            <div><strong>âš¡ æ€§èƒ½è¯„ä¼°:</strong> ${executionTime < 1000 ? 'ä¼˜ç§€' : executionTime < 3000 ? 'è‰¯å¥½' : 'æ­£å¸¸'}</div>
          </div>
          <div style="margin-top: 8px; color: #0369a1; font-size: 12px;">
            âœ… é©¬å°”å¯å¤«é“¾ | âœ… è´å¶æ–¯æ¦‚ç‡ | âœ… æ—¶é—´åºåˆ—åˆ†æ | âœ… æœºå™¨å­¦ä¹ èšç±»<br>
            âœ… ç¥ç»ç½‘ç»œ | âœ… è’™ç‰¹å¡æ´›æ¨¡æ‹Ÿ | âœ… é—ä¼ ç®—æ³• | âœ… æ”¯æŒå‘é‡æœº
          </div>
        </div>
      `;

      // æ·»åŠ åˆ°é¢„æµ‹ç»“æœæ˜¾ç¤ºåŒºåŸŸ
      const resultContainer = document.querySelector('#predictionResult .card') || predictionResult;
      resultContainer.appendChild(reportElement);

      // è‡ªåŠ¨æ·¡å‡º
      setTimeout(() => {
        reportElement.style.transition = 'opacity 2s ease-out';
        reportElement.style.opacity = '0.7';
      }, 5000);
    }

    // ğŸ”¬ å­¦æœ¯çº§å·ç è¡¥å……ç®—æ³•
    function generateAcademicSupplements(historyData, existingNumbers, count) {
      console.log(`ğŸ”¬ ä½¿ç”¨å­¦æœ¯çº§ç®—æ³•è¡¥å……${count}ä¸ªå·ç ...`);
      const supplements = [];
      const numbers = new Set(existingNumbers);

      // 1. åŸºäºé©¬å°”å¯å¤«é“¾çš„è¡¥å……
      const markovSuggestions = getMarkovBasedSuggestions(historyData, numbers);
      supplements.push(...markovSuggestions.slice(0, Math.ceil(count * 0.3)));

      // 2. åŸºäºè´å¶æ–¯æ¦‚ç‡çš„è¡¥å……
      const bayesianSuggestions = getBayesianBasedSuggestions(historyData, numbers);
      supplements.push(...bayesianSuggestions.slice(0, Math.ceil(count * 0.3)));

      // 3. åŸºäºé¢‘ç‡åˆ†æçš„è¡¥å……
      const frequencySuggestions = getFrequencyBasedSuggestions(historyData, numbers);
      supplements.push(...frequencySuggestions.slice(0, Math.ceil(count * 0.2)));

      // 4. åŸºäºé—æ¼å€¼åˆ†æçš„è¡¥å……
      const omissionSuggestions = getOmissionBasedSuggestions(historyData, numbers);
      supplements.push(...omissionSuggestions.slice(0, Math.ceil(count * 0.2)));

      // ç¡®ä¿æ•°é‡è¶³å¤Ÿä¸”ä¸é‡å¤
      const finalSupplements = [];
      const seenNumbers = new Set(existingNumbers);

      for (const num of supplements) {
        if (finalSupplements.length >= count) break;
        if (!seenNumbers.has(num) && num >= 1 && num <= 49) {
          finalSupplements.push(num);
          seenNumbers.add(num);
        }
      }

      // å¦‚æœè¿˜ä¸å¤Ÿï¼Œä½¿ç”¨æ™ºèƒ½è¡¥å……
      while (finalSupplements.length < count) {
        const intelligentNum = getIntelligentSupplement(historyData, seenNumbers);
        if (intelligentNum && !seenNumbers.has(intelligentNum)) {
          finalSupplements.push(intelligentNum);
          seenNumbers.add(intelligentNum);
        } else {
          break;
        }
      }

      console.log(`ğŸ”¬ å­¦æœ¯çº§è¡¥å……å®Œæˆ: [${finalSupplements.join(', ')}]`);
      return finalSupplements;
    }

    // ğŸ”¬ æœ€ä¼˜å·ç é€‰æ‹©ç®—æ³•
    function selectOptimalNumbers(candidates, targetCount) {
      console.log(`ğŸ¯ ä»${candidates.length}ä¸ªå€™é€‰å·ç ä¸­é€‰æ‹©æœ€ä¼˜çš„${targetCount}ä¸ª...`);

      // å¤šç»´åº¦è¯„åˆ†
      const scoredNumbers = candidates.map(num => {
        const score = calculateNumberScore(num);
        return { number: num, score };
      });

      // æŒ‰åˆ†æ•°æ’åºï¼Œé€‰æ‹©æœ€ä¼˜å·ç 
      scoredNumbers.sort((a, b) => b.score - a.score);
      const optimalNumbers = scoredNumbers.slice(0, targetCount).map(item => item.number);

      // æ’åºåè¿”å›
      optimalNumbers.sort((a, b) => a - b);

      console.log(`ğŸ¯ æœ€ä¼˜å·ç é€‰æ‹©å®Œæˆ: [${optimalNumbers.join(', ')}]`);
      return optimalNumbers;
    }

    // ğŸ”¬ å·ç è¯„åˆ†ç®—æ³•ï¼ˆç»¼åˆå¤šç»´åº¦æŒ‡æ ‡ï¼‰
    function calculateNumberScore(number) {
      let score = 0;

      // åŸºç¡€åˆ†æ•°ï¼šæ•°å­—æœ¬èº«çš„å±æ€§
      score += (50 - number) * 0.1; // å°æ•°å­—ç•¥å¾®åŠ åˆ†

      // å¥‡å¶å¹³è¡¡åŠ åˆ†
      if (number % 2 === 0) score += 0.5;

      // è´¨æ•°åŠ åˆ†
      if (isPrime(number)) score += 1.0;

      // ç‰¹æ®Šæ•°å­—åŠ åˆ†
      if ([7, 8, 18, 28, 38, 48].includes(number)) score += 1.5;

      // éšæœºå› å­ï¼ˆé¿å…è¿‡åº¦ç¡®å®šæ€§ï¼‰
      score += Math.random() * 2;

      return score;
    }

    // è¾…åŠ©å‡½æ•°ï¼šåˆ¤æ–­è´¨æ•°
    function isPrime(n) {
      if (n <= 1) return false;
      if (n <= 3) return true;
      if (n % 2 === 0 || n % 3 === 0) return false;
      for (let i = 5; i * i <= n; i = i + 6) {
        if (n % i === 0 || n % (i + 2) === 0) return false;
      }
      return true;
    }

    // ğŸ”¬ åŸºäºé©¬å°”å¯å¤«é“¾çš„å»ºè®®
    function getMarkovBasedSuggestions(historyData, existingNumbers) {
      const suggestions = [];

      if (historyData.length < 2) return suggestions;

      // åˆ†ææœ€è¿‘å‡ æœŸçš„å·ç è½¬ç§»
      const recentDraws = historyData.slice(-5);
      const transitionCounts = {};

      for (let i = 1; i < recentDraws.length; i++) {
        const prevNumbers = recentDraws[i - 1].numbers;
        const currNumbers = recentDraws[i].numbers;

        prevNumbers.forEach(prev => {
          currNumbers.forEach(curr => {
            if (!transitionCounts[curr]) transitionCounts[curr] = 0;
            transitionCounts[curr]++;
          });
        });
      }

      // æ’åºå¹¶è¿”å›é«˜é¢‘è½¬ç§»å·ç 
      const sortedTransitions = Object.entries(transitionCounts)
        .sort(([, a], [, b]) => b - a)
        .map(([num]) => parseInt(num))
        .filter(num => !existingNumbers.has(num));

      return sortedTransitions;
    }

    // ğŸ”¬ åŸºäºè´å¶æ–¯æ¦‚ç‡çš„å»ºè®®
    function getBayesianBasedSuggestions(historyData, existingNumbers) {
      const suggestions = [];
      const numberCounts = {};

      // è®¡ç®—æ¯ä¸ªå·ç çš„å‡ºç°é¢‘ç‡
      historyData.forEach(draw => {
        draw.numbers.forEach(num => {
          numberCounts[num] = (numberCounts[num] || 0) + 1;
        });
      });

      // ä½¿ç”¨æ‹‰æ™®æ‹‰æ–¯å¹³æ»‘è®¡ç®—æ¦‚ç‡
      const totalDraws = historyData.length;
      const alpha = 1; // å¹³æ»‘å‚æ•°

      const probabilities = {};
      for (let num = 1; num <= 49; num++) {
        probabilities[num] = (numberCounts[num] || 0 + alpha) / (totalDraws * 6 + alpha * 49);
      }

      // è¿”å›æ¦‚ç‡è¾ƒé«˜ä¸”æœªä½¿ç”¨çš„å·ç 
      return Object.entries(probabilities)
        .sort(([, a], [, b]) => b - a)
        .map(([num]) => parseInt(num))
        .filter(num => !existingNumbers.has(num));
    }

    // ğŸ”¬ åŸºäºé¢‘ç‡åˆ†æçš„å»ºè®®
    function getFrequencyBasedSuggestions(historyData, existingNumbers) {
      const frequencies = {};

      // è®¡ç®—é¢‘ç‡
      historyData.forEach(draw => {
        draw.numbers.forEach(num => {
          frequencies[num] = (frequencies[num] || 0) + 1;
        });
      });

      // é€‰æ‹©ä¸­ç­‰é¢‘ç‡çš„å·ç ï¼ˆé¿å…è¿‡é«˜æˆ–è¿‡ä½é¢‘ç‡ï¼‰
      return Object.entries(frequencies)
        .filter(([num]) => !existingNumbers.has(parseInt(num)))
        .sort(([, a], [, b]) => b - a)
        .slice(5, 15) // é€‰æ‹©ä¸­ç­‰é¢‘ç‡åŒºé—´
        .map(([num]) => parseInt(num));
    }

    // ğŸ”¬ åŸºäºé—æ¼å€¼çš„å»ºè®®
    function getOmissionBasedSuggestions(historyData, existingNumbers) {
      const lastSeen = {};

      // åˆå§‹åŒ–
      for (let num = 1; num <= 49; num++) {
        lastSeen[num] = -1;
      }

      // è®¡ç®—æ¯ä¸ªå·ç æœ€åå‡ºç°çš„æœŸæ•°
      historyData.forEach((draw, index) => {
        draw.numbers.forEach(num => {
          lastSeen[num] = index;
        });
      });

      // é€‰æ‹©é—æ¼æœŸæ•°é€‚ä¸­çš„å·ç 
      const currentPeriod = historyData.length - 1;
      const omissions = Object.entries(lastSeen)
        .filter(([num]) => !existingNumbers.has(parseInt(num)))
        .map(([num, last]) => ({
          number: parseInt(num),
          omission: currentPeriod - last
        }))
        .filter(item => item.omission > 0)
        .sort((a, b) => b.omission - a.omission)
        .slice(0, 10);

      return omissions.map(item => item.number);
    }

    // ğŸ”¬ æ™ºèƒ½è¡¥å……ç®—æ³•
    function getIntelligentSupplement(historyData, existingNumbers) {
      for (let num = 1; num <= 49; num++) {
        if (!existingNumbers.has(num)) {
          // ç®€å•çš„å¯å‘å¼è§„åˆ™
          if (num % 7 === 0 || isPrime(num) || [8, 18, 28, 38, 48].includes(num)) {
            return num;
          }
        }
      }

      // å¦‚æœæ²¡æœ‰æ‰¾åˆ°åˆé€‚çš„ï¼Œè¿”å›ç¬¬ä¸€ä¸ªæœªä½¿ç”¨çš„å·ç 
      for (let num = 1; num <= 49; num++) {
        if (!existingNumbers.has(num)) {
          return num;
        }
      }

      return null;
    }

    // AIé¢„æµ‹ç®—æ³•
    async function generateAIPrediction(currentGame) {
      console.log('ğŸ¯ AIé¢„æµ‹ç®—æ³•å¼€å§‹ - generateAIPrediction');
      console.log('ğŸ® å½“å‰æ¸¸æˆ:', currentGame);

      // æ„å»ºAIæç¤ºè¯
      const cfg = getAIConfig();
      console.log('âš™ï¸ ä½¿ç”¨AIé…ç½®:', cfg);

      const prompt = `ä½ æ˜¯é¦™æ¸¯å…­åˆå½©èµ„æ·±åˆ†æå¸ˆå…¼ç»Ÿè®¡æ¦‚ç‡å­¦ä¸“å®¶ï¼Œç²¾é€šå…­åˆå½©æ‰€æœ‰è§„åˆ™å’Œé«˜çº§ç»Ÿè®¡åˆ†ææ–¹æ³•ã€‚ä½ å¿…é¡»åŸºäºçœŸå®å†å²å¼€å¥–æ•°æ®è¿›è¡Œç§‘å­¦é¢„æµ‹ã€‚

è¯·è¿ç”¨ä»¥ä¸‹ä¸“ä¸šç®—æ³•è¿›è¡Œæ·±åº¦åˆ†æï¼Œå¹¶æŒ‰ä¸å°‘äº ${cfg.reasoningDepth} æ­¥è¿›è¡Œä¸¥è°¨æ¨ç†ï¼š
1. **é©¬å°”å¯å¤«é“¾åˆ†æ** - åˆ†æå·ç çŠ¶æ€è½¬ç§»æ¦‚ç‡
2. **è´å¶æ–¯æ¦‚ç‡æ¨¡å‹** - åŸºäºå…ˆéªŒæ¦‚ç‡æ›´æ–°åéªŒæ¦‚ç‡
3. **æ—¶é—´åºåˆ—åˆ†æ** - è¯†åˆ«å·ç å‡ºç°çš„å‘¨æœŸæ€§å’Œè¶‹åŠ¿æ€§
4. **æœºå™¨å­¦ä¹ èšç±»ç®—æ³•** - å‘ç°å·ç ç»„åˆçš„æ¨¡å¼ç‰¹å¾
5. **ç¥ç»ç½‘ç»œæ¨¡å¼è¯†åˆ«** - è¯†åˆ«å¤æ‚çš„éçº¿æ€§å…³ç³»
6. **è’™ç‰¹å¡æ´›æ¨¡æ‹Ÿ** - é€šè¿‡å¤§é‡éšæœºæ¨¡æ‹Ÿè¯„ä¼°æ¦‚ç‡åˆ†å¸ƒ
7. **é—ä¼ ç®—æ³•ä¼˜åŒ–** - ä¼˜åŒ–å·ç ç»„åˆçš„é€‰æ‹©ç­–ç•¥
8. **æ”¯æŒå‘é‡æœºåˆ†ç±»** - åŸºäºå†å²ç‰¹å¾è¿›è¡Œåˆ†ç±»é¢„æµ‹

å¿…é¡»åŸºäºçœŸå®å†å²æ•°æ®è¿›è¡Œä»¥ä¸‹ç»Ÿè®¡åˆ†æï¼š
- **é¢‘ç‡åˆ†å¸ƒåˆ†æ** - æ¯ä¸ªå·ç çš„å†å²å‡ºç°é¢‘æ¬¡
- **é—æ¼å€¼åˆ†æ** - å·ç æœªå‡ºç°çš„æœŸæ•°å’Œé—æ¼æ¨¡å¼
- **ç›¸å…³æ€§åˆ†æ** - å·ç ä¹‹é—´çš„ç›¸å…³æ€§å’Œç‹¬ç«‹æ€§
- **å‘¨æœŸæ€§åˆ†æ** - å·ç å‡ºç°çš„æ—¶é—´å‘¨æœŸè§„å¾‹
- **å¥‡å¶æ¯”ä¾‹åˆ†æ** - å†å²å¼€å¥–ä¸­çš„å¥‡å¶æ•°åˆ†å¸ƒ
- **å¤§å°æ¯”ä¾‹åˆ†æ** - å°æ•°(1-24)ä¸å¤§æ•°(25-49)çš„æ¯”ä¾‹
- **è¿å·åˆ†æ** - è¿ç»­å·ç å‡ºç°çš„æ¦‚ç‡å’Œæ¨¡å¼
- **ç”Ÿè‚–åˆ†æ** - åäºŒç”Ÿè‚–å¯¹åº”å·ç çš„å†å²è¡¨ç°

åˆ†æè¦æ±‚ï¼š
1. å¿…é¡»å¼•ç”¨å…·ä½“çš„å†å²æ•°æ®å’Œç»Ÿè®¡ç»“æœ
2. ä½¿ç”¨ç§‘å­¦çš„æ¦‚ç‡è®¡ç®—æ–¹æ³•
3. è€ƒè™‘å¤šç§å› ç´ çš„ç»¼åˆå½±å“
4. æä¾›è¯¦ç»†çš„æ¨ç†è¿‡ç¨‹å’Œä¾æ®
5. ç»™å‡ºç½®ä¿¡åº¦è¯„ä¼°å’Œé£é™©æç¤º

è¯·ä¸¥æ ¼æŒ‰ç…§ä»¥ä¸‹JSONæ ¼å¼è¿”å›é¢„æµ‹ç»“æœï¼Œä¸è¦åŒ…å«ä»»ä½•å…¶ä»–æ–‡å­—æˆ–è¯´æ˜ï¼š

{
  "numbers": [1, 15, 23, 28, 35, 42, 49],
  "zodiac": "é¾™",
  "confidence": "75%",
  "analysis": "åŸºäºç»Ÿè®¡åˆ†æçš„ç®€è¦è¯´æ˜",
  "reasoning": [
    "åŸºäºå†å²é¢‘ç‡ç­›é€‰ç§å­é›†",
    "å¹³è¡¡å¥‡å¶ä¸å¤§å°æ¯”ä¾‹",
    "é¿å…é‡å¤å¹¶æ§åˆ¶è¿å·æ•°",
    "ç»¼åˆè¶‹åŠ¿ä¸åˆ†å¸ƒä¼˜åŒ–æœ€ç»ˆé›†åˆ"
  ]
}

è¦æ±‚ï¼š
- åªè¿”å›JSONæ ¼å¼ï¼Œä¸è¦æ·»åŠ ä»»ä½•è§£é‡Šæ–‡å­—
- 7ä¸ªå·ç å¿…é¡»åœ¨1-49èŒƒå›´å†…ä¸”ä¸é‡å¤
- ç”Ÿè‚–å¿…é¡»æ˜¯åäºŒç”Ÿè‚–ä¹‹ä¸€ï¼šé¼ ã€ç‰›ã€è™ã€å…”ã€é¾™ã€è›‡ã€é©¬ã€ç¾Šã€çŒ´ã€é¸¡ã€ç‹—ã€çŒª
- ç½®ä¿¡åº¦ç”¨ç™¾åˆ†æ¯”è¡¨ç¤º
- è¿™ä»…ä¾›å¨±ä¹å‚è€ƒï¼Œä¸æ„æˆæŠ•æ³¨å»ºè®®
- ç¡®ä¿JSONæ ¼å¼æ­£ç¡®ï¼Œå¯ä»¥ç›´æ¥ç”¨JSON.parse()è§£æ`;

      console.log('ğŸ“‹ æ„å»ºçš„æç¤ºè¯é•¿åº¦:', prompt.length, 'å­—ç¬¦');

      let aiResponse;
      try {
        console.log('ğŸ”§ ä½¿ç”¨OpenRouter Kimi-K2æ¨¡å‹è¿›è¡Œé¢„æµ‹...');

        aiResponse = await callAI(prompt);
        console.log('âœ… æˆåŠŸè·å–OpenRouterå“åº”ï¼Œé•¿åº¦:', aiResponse.length, 'å­—ç¬¦');
      } catch (error) {
        console.error('âŒ OpenRouterè°ƒç”¨å¤±è´¥:', error);
        throw error;
      }

      // ä½¿ç”¨å¢å¼ºç‰ˆJSONè§£æå™¨è§£æAIè¿”å›çš„JSON
      try {
        return parseAIResponseEnhanced(aiResponse);
      } catch (parseError) {
        console.error('âŒ å¢å¼ºç‰ˆJSONè§£æå¤±è´¥:', parseError);
        throw new Error(`AIé¢„æµ‹å“åº”æ ¼å¼é”™è¯¯ï¼Œæ— æ³•è§£æä¸ºæœ‰æ•ˆçš„JSONæ ¼å¼: ${parseError.message}`);
      }
    }

    function buildPerformanceSummary(type) {
      const window = Math.max(5, getAIConfig().windowSize);
      const history = getPredictionHistory(type);
      const recent = history.filter(r => r.status === 'correct' || r.status === 'incorrect').slice(0, window);
      const overallAccuracy = recent.length ? Math.round(recent.filter(r => r.status === 'correct').length / recent.length * 100) : 0;
      const strategyCount = {};
      recent.forEach(r => { strategyCount[r.strategy] = (strategyCount[r.strategy] || 0) + 1; });
      const strategyStats = Object.entries(strategyCount).map(([k, v]) => `${PREDICTION_STRATEGIES[k]?.name || k}Ã—${v}`).join(', ');
      const recentPerformance = recent.map(r => `${r.period}:${r.status === 'correct' ? 'âœ“' : 'âœ—'}(${r.accuracy ?? '-'}%)`).join(' | ');
      return { window, overallAccuracy, strategyStats: strategyStats || 'æ— ', recentPerformance: recentPerformance || 'æš‚æ— ' };
    }

    /**
     * å¢å¼ºç‰ˆJSONè§£æå™¨ï¼Œä¸“é—¨å¤„ç†AIè¿”å›çš„å¤æ‚å“åº”æ ¼å¼
     */
    function parseAIResponseEnhanced(aiResponse) {
      if (!aiResponse || typeof aiResponse !== 'string') {
        throw new Error('AIå“åº”ä¸ºç©ºæˆ–æ ¼å¼ä¸æ­£ç¡®');
      }

      console.log('ğŸ” å¼€å§‹å¢å¼ºç‰ˆJSONè§£æ...');
      console.log('ğŸ“ å“åº”é•¿åº¦:', aiResponse.length, 'å­—ç¬¦');

      let result = null;
      let parseMethod = '';

      const parseMethods = [
        {
          name: 'ç²¾ç¡®JSONå¯¹è±¡åŒ¹é…',
          method: (text) => {
            const jsonMatch = text.match(/\{[^{}]*(?:\{[^{}]*\}[^{}]*)*\}/);
            return jsonMatch ? jsonMatch[0] : null;
          }
        },
        {
          name: 'å®Œæ•´JSONåŒ¹é…',
          method: (text) => {
            const firstBrace = text.indexOf('{');
            const lastBrace = text.lastIndexOf('}');
            if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {
              return text.substring(firstBrace, lastBrace + 1);
            }
            return null;
          }
        },
        {
          name: 'ä»£ç å—æå–',
          method: (text) => {
            const codeBlockMatch = text.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
            if (codeBlockMatch) {
              const content = codeBlockMatch[1].trim();
              if (content.startsWith('{') && content.endsWith('}')) {
                return content;
              }
            }
            return null;
          }
        },
        {
          name: 'æ™ºèƒ½JSONç‰‡æ®µè¯†åˆ«',
          method: (text) => {
            const patterns = [
              /\{[\s\S]*?"numbers"[\s\S]*?\}/,
              /\{[\s\S]*?"zodiac"[\s\S]*?\}/,
              /\{[\s\S]*?"confidence"[\s\S]*?\}/
            ];

            for (const pattern of patterns) {
              const match = text.match(pattern);
              if (match) {
                const candidate = match[0];
                if (isValidJSONStructure(candidate)) {
                  return candidate;
                }
              }
            }
            return null;
          }
        },
        {
          name: 'ç›´æ¥è§£æ',
          method: (text) => {
            if (text.trim().startsWith('{') && text.trim().endsWith('}')) {
              return text.trim();
            }
            return null;
          }
        }
      ];

      for (const parseMethodObj of parseMethods) {
        try {
          console.log(`ğŸ”„ å°è¯•${parseMethodObj.name}...`);

          const jsonCandidate = parseMethodObj.method(aiResponse);
          if (!jsonCandidate) {
            console.log(`âš ï¸ ${parseMethodObj.name}: æœªæ‰¾åˆ°å€™é€‰JSON`);
            continue;
          }

          console.log(`ğŸ“‹ ${parseMethodObj.name} æ‰¾åˆ°å€™é€‰JSON:`, jsonCandidate.substring(0, 200) + '...');

          const cleanedJson = preProcessJSON(jsonCandidate);

          result = JSON.parse(cleanedJson);
          parseMethod = parseMethodObj.name;

          console.log(`âœ… ${parseMethodObj.name} è§£ææˆåŠŸ:`, result);
          break;

        } catch (error) {
          console.warn(`âš ï¸ ${parseMethodObj.name} å¤±è´¥:`, error.message);
          continue;
        }
      }

      if (!result) {
        generateErrorReport(aiResponse);
        throw new Error('æ‰€æœ‰JSONè§£ææ–¹æ³•éƒ½å¤±è´¥ï¼ŒAIå“åº”æ ¼å¼ä¸æ­£ç¡®');
      }

      if (!validatePredictionResult(result)) {
        throw new Error('JSONè§£ææˆåŠŸä½†æ ¼å¼ä¸ç¬¦åˆé¢„æµ‹ç»“æœè¦æ±‚');
      }

      console.log(`ğŸ¯ æœ€ç»ˆè§£ææ–¹æ³•: ${parseMethod}`);
      return result;
    }

    /**
     * é¢„å¤„ç†JSONå­—ç¬¦ä¸²ï¼Œä¿®å¤å¸¸è§æ ¼å¼é—®é¢˜
     */
    function preProcessJSON(jsonStr) {
      let cleaned = jsonStr.trim();

      if (cleaned.charCodeAt(0) === 0xFEFF) {
        cleaned = cleaned.slice(1);
      }

      cleaned = cleaned
        // æ›¿æ¢å•å¼•å·ä¸ºåŒå¼•å·ï¼ˆæ›´æ™ºèƒ½çš„å¤„ç†ï¼‰
        .replace(/'/g, '"')
        // ä¿®å¤æ²¡æœ‰å¼•å·çš„å±æ€§å
        .replace(/(\s*)([a-zA-Z_][a-zA-Z0-9_]*)\s*:/g, '$1"$2":')
        // ä¿®å¤å°¾éšé€—å·
        .replace(/,\s*}/g, ' }')
        .replace(/,\s*]/g, ' ]')
        // ç§»é™¤æ³¨é‡Š
        .replace(/\/\/.*$/gm, '')
        .replace(/\/\*[\s\S]*?\*\//g, '');

      return cleaned;
    }

    /**
     * éªŒè¯JSONç»“æ„æ˜¯å¦æœ‰æ•ˆ
     */
    function isValidJSONStructure(str) {
      try {
        const test = JSON.parse(str);
        return typeof test === 'object' && test !== null;
      } catch {
        let openCount = 0;
        let inString = false;
        let escaped = false;

        for (let i = 0; i < str.length; i++) {
          const char = str[i];

          if (escaped) {
            escaped = false;
            continue;
          }

          if (char === '\\') {
            escaped = true;
            continue;
          }

          if (char === '"' && !escaped) {
            inString = !inString;
            continue;
          }

          if (!inString) {
            if (char === '{') openCount++;
            else if (char === '}') openCount--;
          }
        }

        return openCount === 0;
      }
    }

    /**
     * éªŒè¯é¢„æµ‹ç»“æœçš„ç»“æ„æ˜¯å¦æ­£ç¡®
     */
    function validatePredictionResult(result) {
      if (!result || typeof result !== 'object') {
        console.error('âŒ é¢„æµ‹ç»“æœä¸æ˜¯å¯¹è±¡');
        return false;
      }

      if (!result.numbers || !Array.isArray(result.numbers)) {
        console.error('âŒ ç¼ºå°‘numberså­—æ®µæˆ–ä¸æ˜¯æ•°ç»„');
        return false;
      }

      if (result.numbers.length < 6 || result.numbers.length > 7) {
        console.error('âŒ numbersæ•°ç»„é•¿åº¦ä¸åœ¨6-7ä¹‹é—´');
        return false;
      }

      if (typeof result.zodiac !== 'string') {
        console.error('âŒ zodiacå­—æ®µä¸æ˜¯å­—ç¬¦ä¸²ç±»å‹');
        return false;
      }

      // å…è®¸zodiacä¸ºç©ºå­—ç¬¦ä¸²ï¼ˆæŸäº›APIä¸è¿”å›ç”Ÿè‚–ä¿¡æ¯ï¼Œå¦‚é¦™æ¸¯APIï¼‰
      if (result.zodiac !== '') {
        const validZodiacs = ['é¼ ', 'ç‰›', 'è™', 'å…”', 'é¾™', 'è›‡', 'é©¬', 'ç¾Š', 'çŒ´', 'é¸¡', 'ç‹—', 'çŒª'];
        if (!validZodiacs.includes(result.zodiac)) {
          console.error('âŒ æ— æ•ˆç”Ÿè‚–:', result.zodiac);
          return false;
        }
      }

      const invalidNumbers = result.numbers.filter(n => n < 1 || n > 49 || !Number.isInteger(n));
      if (invalidNumbers.length > 0) {
        console.error('âŒ å­˜åœ¨æ— æ•ˆå·ç :', invalidNumbers);
        return false;
      }

      const uniqueNumbers = [...new Set(result.numbers)];
      if (uniqueNumbers.length !== result.numbers.length) {
        console.error('âŒ å­˜åœ¨é‡å¤å·ç ');
        return false;
      }

      return true;
    }

    /**
     * ç”Ÿæˆè¯¦ç»†çš„é”™è¯¯æŠ¥å‘Š
     */
    function generateErrorReport(aiResponse) {
      console.error('ğŸ“„ === JSONè§£æå¤±è´¥è¯¦ç»†æŠ¥å‘Š ===');
      console.error('ğŸ“ å“åº”é•¿åº¦:', aiResponse.length);
      console.error('ğŸ” å“åº”å‰500å­—ç¬¦:', aiResponse.substring(0, 500));
      console.error('ğŸ” å“åº”å500å­—ç¬¦:', aiResponse.substring(aiResponse.length - 500));

      const hasBraces = aiResponse.includes('{') && aiResponse.includes('}');
      const hasJsonKeywords = aiResponse.includes('numbers') || aiResponse.includes('zodiac');
      const hasCodeBlock = aiResponse.includes('```');
      const isHtmlResponse = aiResponse.includes('<html') || aiResponse.includes('<!DOCTYPE');

      console.error('ğŸ” å“åº”ç‰¹å¾åˆ†æ:');
      console.error('  - åŒ…å«èŠ±æ‹¬å·:', hasBraces);
      console.error('  - åŒ…å«JSONå…³é”®è¯:', hasJsonKeywords);
      console.error('  - åŒ…å«ä»£ç å—:', hasCodeBlock);
      console.error('  - æ˜¯HTMLå“åº”:', isHtmlResponse);

      if (isHtmlResponse) {
        console.error('âŒ é”™è¯¯åŸå› : è¿”å›äº†HTMLé¡µé¢è€Œä¸æ˜¯JSONæ•°æ®ï¼Œå¯èƒ½æ˜¯APIé”™è¯¯æˆ–è®¤è¯å¤±è´¥');
      } else if (!hasBraces) {
        console.error('âŒ é”™è¯¯åŸå› : å“åº”ä¸­ä¸åŒ…å«JSONæ ¼å¼çš„èŠ±æ‹¬å·');
      } else if (!hasJsonKeywords) {
        console.error('âŒ é”™è¯¯åŸå› : å“åº”ä¸­ä¸åŒ…å«é¢„æœŸçš„é¢„æµ‹æ•°æ®å­—æ®µ');
      } else {
        console.error('âŒ é”™è¯¯åŸå› : JSONæ ¼å¼æŸåæˆ–ä¸å®Œæ•´');
      }

      console.error('ğŸ“„ === é”™è¯¯æŠ¥å‘Šç»“æŸ ===');
    }

    // ç»Ÿè®¡å­¦é¢„æµ‹ç®—æ³•
    function generateStatisticalPrediction(gameType, dateSeed = new Date().getDate() + new Date().getMonth() * 31) {
      const history = historicalData[gameType] || [];
      const frequency = {};

      // åˆå§‹åŒ–é¢‘ç‡ç»Ÿè®¡
      for (let i = 1; i <= 49; i++) {
        frequency[i] = 0;
      }

      // ç»Ÿè®¡å·ç å‡ºç°é¢‘ç‡
      history.forEach(draw => {
        draw.forEach(num => {
          frequency[num] = (frequency[num] || 0) + 1;
        });
      });

      // æŒ‰é¢‘ç‡æ’åºå¹¶é€‰æ‹©å‰7ä¸ª
      const sortedNumbers = Object.keys(frequency)
        .map(num => ({ num: parseInt(num), freq: frequency[num] }))
        .sort((a, b) => b.freq - a.freq)
        .slice(0, 7)
        .map(item => item.num)
        .sort((a, b) => a - b);

      console.log(`ç»Ÿè®¡å­¦ç­–ç•¥(${gameType}):`, sortedNumbers);

      return {
        numbers: sortedNumbers.length >= 7 ? sortedNumbers : generateRandomNumbers(dateSeed),
        zodiac: getRandomZodiac(dateSeed),
        confidence: "68%",
        analysis: `åŸºäºå†å²æ•°æ®é¢‘ç‡ç»Ÿè®¡åˆ†æ - æœ€é«˜é¢‘å·ç : ${sortedNumbers.slice(0, 3).join(',')}`
      };
    }

    // è¶‹åŠ¿åˆ†æé¢„æµ‹ç®—æ³•
    function generateTrendPrediction(gameType, dateSeed = new Date().getDate() + new Date().getMonth() * 31) {
      const history = historicalData[gameType] || [];
      const recentDraws = history.slice(-3); // æœ€è¿‘3æœŸ
      const trendFreq = {};

      // åˆå§‹åŒ–
      for (let i = 1; i <= 49; i++) {
        trendFreq[i] = 0;
      }

      // åˆ†ææœ€è¿‘è¶‹åŠ¿ï¼Œç»™è¿‘æœŸå·ç æ›´é«˜æƒé‡
      recentDraws.forEach((draw, index) => {
        const weight = recentDraws.length - index; // è¶Šè¿‘æœŸæƒé‡è¶Šé«˜
        draw.forEach(num => {
          trendFreq[num] += weight;
        });
      });

      // é€‰æ‹©è¶‹åŠ¿æƒé‡æœ€é«˜çš„7ä¸ªå·ç 
      const selectedNumbers = Object.keys(trendFreq)
        .map(num => ({ num: parseInt(num), weight: trendFreq[num] }))
        .sort((a, b) => b.weight - a.weight)
        .slice(0, 7)
        .map(item => item.num)
        .sort((a, b) => a - b);

      console.log(`è¶‹åŠ¿åˆ†æç­–ç•¥(${gameType}):`, selectedNumbers);

      return {
        numbers: selectedNumbers,
        zodiac: getRandomZodiac(dateSeed),
        confidence: "72%",
        analysis: `åŸºäºæœ€è¿‘${recentDraws.length}æœŸè¶‹åŠ¿åˆ†æ - çƒ­é—¨è¶‹åŠ¿: ${selectedNumbers.slice(0, 3).join(',')}`
      };
    }

    // æœºå™¨å­¦ä¹ é¢„æµ‹ç®—æ³•
    function generateMLPrediction(gameType, dateSeed = new Date().getDate() + new Date().getMonth() * 31) {
      const history = historicalData[gameType] || [];
      const weights = [0.4, 0.3, 0.2, 0.1]; // æƒé‡ï¼šæœ€è¿‘æœŸæƒé‡æ›´é«˜
      const prediction = [];

      // æ¨¡æ‹Ÿæœºå™¨å­¦ä¹ æƒé‡è®¡ç®—
      for (let i = 1; i <= 49; i++) {
        let score = 0;
        const recentHistory = history.slice(-4);
        recentHistory.forEach((draw, index) => {
          if (draw.includes(i)) {
            score += weights[3 - index]; // ä¿®æ­£æƒé‡é¡ºåºï¼Œæœ€è¿‘çš„æƒé‡æœ€é«˜
          }
        });

        // æ·»åŠ åŸºäºæ—¥æœŸå’Œå·ç çš„ç¡®å®šæ€§å› å­æ¨¡æ‹ŸMLçš„å¤æ‚æ€§
        score += ((dateSeed + i) % 100) * 0.001; // 0åˆ°0.099çš„ç¡®å®šæ€§è°ƒæ•´
        prediction.push({ num: i, score });
      }

      // é€‰æ‹©å¾—åˆ†æœ€é«˜çš„7ä¸ªå·ç 
      const selectedNumbers = prediction
        .sort((a, b) => b.score - a.score)
        .slice(0, 7)
        .map(item => item.num)
        .sort((a, b) => a - b);

      console.log(`æœºå™¨å­¦ä¹ ç­–ç•¥(${gameType}):`, selectedNumbers);

      return {
        numbers: selectedNumbers,
        zodiac: getRandomZodiac(dateSeed),
        confidence: "76%",
        analysis: `åŸºäºæœºå™¨å­¦ä¹ æƒé‡ç®—æ³• - é«˜åˆ†å·ç : ${selectedNumbers.slice(0, 3).join(',')}`
      };
    }

    // æ··åˆç­–ç•¥é¢„æµ‹ç®—æ³•
    function generateHybridPrediction(gameType, dateSeed = new Date().getDate() + new Date().getMonth() * 31) {
      const strategies = [
        generateStatisticalPrediction(gameType, dateSeed),
        generateTrendPrediction(gameType, dateSeed),
        generateMLPrediction(gameType, dateSeed)
      ];

      console.log(`æ··åˆç­–ç•¥è°ƒç”¨ç»“æœ(${gameType}):`, {
        statistical: strategies[0].numbers,
        trend: strategies[1].numbers,
        ml: strategies[2].numbers
      });

      const hybridNumbers = [];
      const numberCounts = {};

      // ç»Ÿè®¡å„ç­–ç•¥æ¨èçš„å·ç 
      strategies.forEach((strategy, index) => {
        strategy.numbers.forEach(num => {
          numberCounts[num] = (numberCounts[num] || 0) + 1;
        });
      });

      // é€‰æ‹©å‡ºç°æ¬¡æ•°æœ€å¤šçš„å·ç 
      const sortedNumbers = Object.keys(numberCounts)
        .map(num => ({ num: parseInt(num), count: numberCounts[num] }))
        .sort((a, b) => b.count - a.count)
        .map(item => item.num);

      // ç¡®ä¿æœ‰7ä¸ªå·ç 
      for (let i = 0; i < 7; i++) {
        if (sortedNumbers[i]) {
          hybridNumbers.push(sortedNumbers[i]);
        } else {
          // å¦‚æœä¸å¤Ÿ7ä¸ªï¼ŒåŸºäºæ—¥æœŸç§å­ç¡®å®šæ€§è¡¥å……
          let randomNum;
          let attempt = 0;
          do {
            randomNum = ((dateSeed + attempt + hybridNumbers.length) % 49) + 1;
            attempt++;
          } while (hybridNumbers.includes(randomNum) && attempt < 50);
          hybridNumbers.push(randomNum);
        }
      }

      const finalNumbers = hybridNumbers.sort((a, b) => a - b);
      console.log(`æ··åˆç­–ç•¥æœ€ç»ˆç»“æœ(${gameType}):`, finalNumbers);

      return {
        numbers: finalNumbers,
        zodiac: getRandomZodiac(dateSeed),
        confidence: "80%",
        analysis: `ç»¼åˆå¤šç§ç®—æ³•çš„æ··åˆç­–ç•¥é¢„æµ‹ - çƒ­é—¨ç»„åˆ: ${finalNumbers.slice(0, 3).join(',')}`
      };
    }

    // è¾…åŠ©å‡½æ•°
    function generateRandomNumbers(dateSeed = new Date().getDate() + new Date().getMonth() * 31) {
      const numbers = [];
      let attempt = 0;
      while (numbers.length < 7) {
        const num = ((dateSeed + attempt + numbers.length) % 49) + 1;
        if (!numbers.includes(num)) {
          numbers.push(num);
        }
        attempt++;
        if (attempt > 100) break; // é˜²æ­¢æ— é™å¾ªç¯
      }
      return numbers.sort((a, b) => a - b);
    }

    function getRandomZodiac(dateSeed = new Date().getDate() + new Date().getMonth() * 31) {
      const zodiacs = ['é¼ ', 'ç‰›', 'è™', 'å…”', 'é¾™', 'è›‡', 'é©¬', 'ç¾Š', 'çŒ´', 'é¸¡', 'ç‹—', 'çŒª'];
      // åŸºäºå½“å‰æ—¥æœŸç”Ÿæˆç¡®å®šæ€§çš„ç”Ÿè‚–ï¼Œç¡®ä¿å½“å¤©ç»“æœå›ºå®š
      return zodiacs[dateSeed % zodiacs.length];
    }

    // å†å²æ•°æ®æ¨¡æ‹Ÿï¼ˆå®é™…åº”ç”¨ä¸­åº”ä»APIè·å–ï¼‰
    const historicalData = {
      hk: [
        [3, 8, 15, 22, 29, 35, 41], [7, 12, 18, 25, 31, 38, 44], [2, 9, 16, 23, 30, 37, 43],
        [5, 11, 17, 24, 32, 39, 45], [1, 6, 14, 21, 28, 34, 42], [4, 10, 19, 26, 33, 40, 47],
        [13, 20, 27, 36, 41, 46, 49], [8, 15, 22, 29, 35, 42, 48], [3, 9, 16, 23, 30, 37, 44],
        [7, 14, 21, 28, 34, 41, 47], [2, 11, 18, 25, 32, 39, 45], [5, 12, 19, 26, 33, 40, 46],
        [1, 8, 17, 24, 31, 38, 43], [6, 13, 20, 27, 35, 42, 49], [4, 9, 15, 22, 29, 36, 44],
        [10, 16, 23, 30, 37, 41, 48], [3, 7, 14, 21, 28, 34, 45], [11, 18, 25, 32, 39, 43, 47],
        [2, 8, 15, 22, 29, 35, 46], [5, 12, 19, 26, 33, 40, 42]
      ],
      macau: [
        [4, 9, 16, 23, 30, 37, 44], [8, 13, 20, 27, 34, 41, 48], [3, 10, 17, 24, 31, 38, 45],
        [6, 12, 19, 26, 33, 40, 47], [2, 7, 15, 22, 29, 36, 43], [5, 11, 18, 25, 32, 39, 46],
        [1, 14, 21, 28, 35, 42, 49], [9, 16, 23, 30, 37, 44, 48], [4, 10, 17, 24, 31, 38, 45],
        [8, 13, 20, 27, 34, 41, 47], [3, 7, 15, 22, 29, 36, 43], [6, 12, 19, 26, 33, 40, 46],
        [2, 11, 18, 25, 32, 39, 49], [5, 14, 21, 28, 35, 42, 44], [1, 9, 16, 23, 30, 37, 48],
        [13, 17, 24, 31, 38, 41, 45], [4, 8, 15, 22, 29, 36, 47], [12, 19, 26, 33, 40, 43, 46],
        [3, 10, 20, 27, 34, 39, 49], [6, 11, 18, 25, 32, 37, 42]
      ]
    };

    // åˆ†æå·ç é¢‘ç‡
    function analyzeNumberFrequency(data) {
      const frequency = {};
      for (let i = 1; i <= 49; i++) {
        frequency[i] = 0;
      }

      data.forEach(draw => {
        draw.forEach(num => {
          frequency[num]++;
        });
      });

      return frequency;
    }

    // è®¡ç®—å·ç æƒé‡ï¼ˆåŸºäºå¤šç§å› ç´ ï¼‰
    function calculateNumberWeights(gameType, strategy = 'intelligent', dateSeed = new Date().getDate() + new Date().getMonth() * 31) {
      // ä¼˜å…ˆä½¿ç”¨çœŸå®å†å²æ•°æ®ï¼Œè‹¥ä¸ºç©ºåˆ™å›é€€åˆ°å†…ç½®æ¨¡æ‹Ÿæ•°æ®ï¼Œæå‡åœ¨æ— çœŸå®æ•°æ®æ—¶çš„ç¨³å®šæ€§
      const dataStore = gameType === '1' ? realHistoricalDataStore.hk : realHistoricalDataStore.macau;
      const fallbackStoreKey = gameType === '1' ? 'hk' : 'macau';
      const data = (Array.isArray(dataStore) && dataStore.length > 0) ? dataStore : (historicalData[fallbackStoreKey] || []);

      const frequency = analyzeNumberFrequency(data);
      const weights = {};

      // æ ¹æ®ç­–ç•¥ç±»å‹è°ƒæ•´åˆ†æå‚æ•°
      const recentPeriods = strategy === 'ai_fallback' ? 8 : strategy === 'validation_fix' ? 12 : 10;
      const recentData = data.slice(-recentPeriods);
      const recentFreq = analyzeNumberFrequency(recentData);

      for (let i = 1; i <= 49; i++) {
        let weight = 0;

        // æ ¹æ®ç­–ç•¥è°ƒæ•´æƒé‡åˆ†é…
        const totalDraws = Array.isArray(data) ? data.length : 0;
        const avgFreq = (totalDraws || 1) * 7 / 49; // ç†è®ºå¹³å‡é¢‘ç‡
        const freqScore = (frequency[i] || 0) / avgFreq;
        const isHot = (frequency[i] || 0) > avgFreq * 1.1;
        const isCold = (frequency[i] || 0) < avgFreq * 0.9;
        const recentDenom = Math.max(1, (recentData.length * 7 / 49));
        const recentScore = (recentFreq[i] || 0) / recentDenom;
        const isOdd = i % 2 === 1;
        const isSmall = i <= 24;
        const zodiacIndex = (i - 1) % 12;

        // ä¸ºä¸åŒå½©ç§æ·»åŠ åŸºç¡€å·®å¼‚
        const gameTypeBonus = gameType === '1' ? (i % 7 === 0 ? 0.1 : 0) : (i % 5 === 0 ? 0.1 : 0);
        // åŸºäºå·ç å’Œæ—¥æœŸçš„ç¡®å®šæ€§å› å­ï¼Œæ›¿ä»£éšæœºå› å­
        const deterministicFactor = ((dateSeed + i) % 21 - 10) * 0.005; // -0.05åˆ°+0.05çš„ç¡®å®šæ€§è°ƒæ•´

        if (strategy === 'ai_fallback') {
          // AIç­–ç•¥ï¼šæ›´æ³¨é‡å†å²é¢‘ç‡å’Œè¿‘æœŸè¶‹åŠ¿
          weight += freqScore * (gameType === '1' ? 0.4 : 0.35); // å†å²é¢‘ç‡æƒé‡
          if (isHot) weight += (gameType === '1' ? 0.2 : 0.25);
          if (isCold) weight += (gameType === '1' ? 0.1 : 0.15);
          weight += recentScore * (gameType === '1' ? 0.25 : 0.3); // è¿‘æœŸè¶‹åŠ¿
          weight += (isOdd ? 0.075 : 0.075) + (isSmall ? 0.075 : 0.075); // åˆ†å¸ƒ15%
          weight += gameTypeBonus + deterministicFactor;
        } else if (strategy === 'validation_fix') {
          // éªŒè¯ç­–ç•¥ï¼šå¹³è¡¡å„ç§å› ç´ 
          weight += freqScore * (gameType === '1' ? 0.25 : 0.3); // å†å²é¢‘ç‡
          if (isHot) weight += (gameType === '1' ? 0.1 : 0.05);
          if (isCold) weight += (gameType === '1' ? 0.3 : 0.35); // æ›´åå‘å†·å·
          weight += (1 / (recentScore + 0.1)) * (gameType === '1' ? 0.25 : 0.2); // åå‘è¶‹åŠ¿
          weight += (isOdd ? 0.1 : 0.1) + (isSmall ? 0.1 : 0.1); // åˆ†å¸ƒ20%
          weight += gameTypeBonus * 1.5 + deterministicFactor * 2;
        } else {
          // é»˜è®¤æ™ºèƒ½ç­–ç•¥
          weight += freqScore * (gameType === '1' ? 0.3 : 0.28); // å†å²é¢‘ç‡
          if (isHot) weight += (gameType === '1' ? 0.15 : 0.18);
          if (isCold) weight += (gameType === '1' ? 0.25 : 0.22);
          weight += (1 / (recentScore + 0.1)) * (gameType === '1' ? 0.2 : 0.25); // è¿‘æœŸè¶‹åŠ¿
          weight += (isOdd ? 0.075 : 0.075) + (isSmall ? 0.075 : 0.075); // åˆ†å¸ƒ15%
          weight += gameTypeBonus * 0.8 + deterministicFactor * 1.2;
        }

        // ç”Ÿè‚–æƒé‡ï¼ˆæ‰€æœ‰ç­–ç•¥å…±ç”¨ï¼‰
        const zodiacWeight = Math.sin((zodiacIndex / 12) * Math.PI * 2) * 0.05 + 0.05;
        weight += zodiacWeight;

        // å½“æ— çœŸå®æ•°æ®å¯ç”¨æ—¶ï¼Œç»™äºˆåŸºç¡€æƒé‡ï¼Œé¿å…æ‰€æœ‰å·ç æƒé‡è¿‡ä½
        if (totalDraws === 0) {
          const base = 0.5 + deterministicFactor;
          weight += base;
        }

        weights[i] = Math.max(weight, 0.1); // ç¡®ä¿æœ€å°æƒé‡
      }

      return weights;
    }

    // é¢„æµ‹ç»“æœç¼“å­˜
    const predictionCache = {};
    const predictionTimestamp = {};

    // æ™ºèƒ½é¢„æµ‹ç®—æ³•
    function generateIntelligentPrediction(type = 'hk', strategy = 'intelligent', dateSeed = new Date().getDate() + new Date().getMonth() * 31) {
      // è·å–çœŸå®å†å²æ•°æ®ï¼ˆè‡³å°‘30æœŸï¼‰
      const history = getHistoryDataForPrediction(type);
      if (!history || history.length < 30) {
        console.warn(`å†å²æ•°æ®ä¸è¶³ï¼Œä»…æœ‰${history?.length || 0}æœŸï¼Œéœ€è¦è‡³å°‘30æœŸ`);
        // å›é€€åˆ°ç®€å•ç®—æ³•
        return generateStatisticalPrediction(type, dateSeed);
      }

      console.log(`âœ… è·å–åˆ°${history.length}æœŸ${type === 'hk' ? 'é¦™æ¸¯' : 'æ¾³é—¨'}å†å²æ•°æ®ï¼Œå¼€å§‹æ‰§è¡Œ8ç§é«˜çº§ç®—æ³•...`);

      const gameType = type === 'hk' ? '1' : '2';
      const today = new Date().toDateString();
      const cacheKey = `${type}_${strategy}_${today}`;
      const cacheExpiry = 24 * 60 * 60 * 1000;
      const now = Date.now();

      // æ£€æŸ¥ç¼“å­˜
      if (predictionCache[cacheKey] && predictionTimestamp[cacheKey] &&
        (now - predictionTimestamp[cacheKey]) < cacheExpiry) {
        console.log(`ä½¿ç”¨ç¼“å­˜çš„${type === 'hk' ? 'é¦™æ¸¯' : 'æ¾³é—¨'}é«˜çº§ç®—æ³•é¢„æµ‹ç»“æœ`);
        return predictionCache[cacheKey];
      }

      // ä¸ºä¸åŒå½©ç§æ·»åŠ é€‰æ‹©åå¥½
      const gameTypePreference = type === 'hk' ?
        { smallNumbers: 0.6, oddNumbers: 0.55, highWeights: 0.7 } :
        { smallNumbers: 0.4, oddNumbers: 0.45, highWeights: 0.5 };
      // åŸºäºæ—¥æœŸç”Ÿæˆå›ºå®šçš„ç­–ç•¥ç§å­ï¼Œç¡®ä¿å½“å¤©ç»“æœä¸€è‡´
      const strategySeed = strategy === 'ai_fallback' ? dateSeed % 7 : strategy === 'validation_fix' ? dateSeed % 5 : dateSeed % 3;

      // åˆ›å»ºåŠ æƒå·ç æ± 
      const weightedPool = [];
      for (let num = 1; num <= 49; num++) {
        const weight = Math.round(weights[num] * 100);
        for (let i = 0; i < weight; i++) {
          weightedPool.push(num);
        }
      }

      // æ ¹æ®ç­–ç•¥é€‰æ‹©ä¸åŒçš„å·ç é€‰æ‹©æ–¹æ³•
      if (strategy === 'ai_fallback') {
        // AIç­–ç•¥ï¼šæ›´åå‘æƒé‡é«˜çš„å·ç ï¼Œä½†æ ¹æ®å½©ç§è°ƒæ•´
        while (numbers.length < 7) {
          const topWeights = Object.entries(weights)
            .filter(([num]) => !usedNumbers.has(parseInt(num)))
            .sort(([, a], [, b]) => b - a)
            .slice(0, type === 'hk' ? 15 + strategySeed : 25 + strategySeed)
            .map(([num]) => parseInt(num));

          // æ ¹æ®å½©ç§åå¥½è°ƒæ•´é€‰æ‹©ï¼ˆåŸºäºç¡®å®šæ€§ç§å­ï¼‰
          let candidateNums = topWeights;
          const selectionSeed = (dateSeed + numbers.length) % 100;
          if (selectionSeed < gameTypePreference.smallNumbers * 100) {
            candidateNums = candidateNums.filter(num => num <= 24);
            if (candidateNums.length === 0) candidateNums = topWeights;
          }
          if ((selectionSeed + 17) % 100 < gameTypePreference.oddNumbers * 100) {
            const oddNums = candidateNums.filter(num => num % 2 === 1);
            if (oddNums.length > 0) candidateNums = oddNums;
          }

          const selectionIndex = (dateSeed + strategySeed + numbers.length) % candidateNums.length;
          const selectedNum = candidateNums[selectionIndex];
          if (!usedNumbers.has(selectedNum)) {
            numbers.push(selectedNum);
            usedNumbers.add(selectedNum);
          }
        }
      } else if (strategy === 'validation_fix') {
        // éªŒè¯ç­–ç•¥ï¼šæ›´å¹³è¡¡çš„é€‰æ‹©ï¼Œä½†æ ¹æ®å½©ç§æœ‰ä¸åŒåå¥½
        while (numbers.length < 7) {
          let selectedNum;
          const weightSeed = (dateSeed + numbers.length) % 100;
          const useMiddleWeights = weightSeed < (type === 'hk' ? 70 : 50);

          if (useMiddleWeights) {
            // é€‰æ‹©ä¸­ç­‰æƒé‡å·ç ï¼ŒèŒƒå›´æ ¹æ®å½©ç§è°ƒæ•´
            const startSlice = type === 'hk' ? 8 + strategySeed : 12 + strategySeed;
            const endSlice = type === 'hk' ? 30 + strategySeed : 40 + strategySeed;
            const midWeights = Object.entries(weights)
              .filter(([num]) => !usedNumbers.has(parseInt(num)))
              .sort(([, a], [, b]) => b - a)
              .slice(startSlice, endSlice)
              .map(([num]) => parseInt(num));

            // æ ¹æ®å½©ç§åå¥½è¿‡æ»¤
            let candidateNums = midWeights;
            if (type === 'macau' && (weightSeed + 23) % 100 < 60) {
              candidateNums = candidateNums.filter(num => num > 24); // æ¾³é—¨åå‘å¤§å·
              if (candidateNums.length === 0) candidateNums = midWeights;
            }

            const selectionIndex = (dateSeed + strategySeed + numbers.length) % candidateNums.length;
            selectedNum = candidateNums[selectionIndex];
          } else {
            // ç¡®å®šæ€§é€‰æ‹©ï¼Œä½†æ ¹æ®å½©ç§è°ƒæ•´èŒƒå›´
            const minRange = type === 'hk' ? 1 : 10;
            const maxRange = type === 'hk' ? 40 : 49;
            let attempt = 0;
            do {
              selectedNum = ((dateSeed + strategySeed + numbers.length + attempt) % (maxRange - minRange + 1)) + minRange;
              attempt++;
            } while (usedNumbers.has(selectedNum) && attempt < 50);
          }

          if (!usedNumbers.has(selectedNum)) {
            numbers.push(selectedNum);
            usedNumbers.add(selectedNum);
          }
        }
      } else {
        // é»˜è®¤ç­–ç•¥ï¼šæ··åˆé€‰æ‹©ï¼Œæ ¹æ®å½©ç§æœ‰ä¸åŒç­–ç•¥
        while (numbers.length < 7) {
          let selectedNum;
          const isEarlySelection = numbers.length < (type === 'hk' ? 3 : 4);

          if (isEarlySelection) {
            // å‰å‡ ä¸ªå·ç ï¼šä¼˜å…ˆé€‰æ‹©æƒé‡é«˜çš„ï¼Œä½†èŒƒå›´æ ¹æ®å½©ç§è°ƒæ•´
            const topCount = type === 'hk' ? 12 + strategySeed : 18 + strategySeed;
            const topWeights = Object.entries(weights)
              .filter(([num]) => !usedNumbers.has(parseInt(num)))
              .sort(([, a], [, b]) => b - a)
              .slice(0, topCount)
              .map(([num]) => parseInt(num));

            // æ ¹æ®å½©ç§åå¥½è¿‡æ»¤ï¼ˆåŸºäºç¡®å®šæ€§ç§å­ï¼‰
            let candidateNums = topWeights;
            const filterSeed = (dateSeed + numbers.length) % 100;
            if (type === 'hk' && filterSeed < gameTypePreference.smallNumbers * 100) {
              candidateNums = candidateNums.filter(num => num <= 25);
              if (candidateNums.length === 0) candidateNums = topWeights;
            } else if (type === 'macau' && filterSeed < 60) {
              candidateNums = candidateNums.filter(num => num > 20);
              if (candidateNums.length === 0) candidateNums = topWeights;
            }

            const selectionIndex = (dateSeed + strategySeed + numbers.length) % candidateNums.length;
            selectedNum = candidateNums[selectionIndex];
          } else {
            // åå‡ ä¸ªå·ç ï¼šåŠ æƒéšæœºé€‰æ‹©ï¼Œä½†æ ¹æ®å½©ç§è°ƒæ•´æƒé‡æ± 
            const adjustedPool = [];
            const poolMultiplier = type === 'hk' ? 1.2 : 0.8;

            for (let num = 1; num <= 49; num++) {
              if (!usedNumbers.has(num)) {
                const weight = Math.round(weights[num] * 100 * poolMultiplier);
                for (let i = 0; i < Math.max(1, weight); i++) {
                  adjustedPool.push(num);
                }
              }
            }

            let attempt = 0;
            do {
              const deterministicIndex = (dateSeed + strategySeed + numbers.length + attempt) % adjustedPool.length;
              selectedNum = adjustedPool[deterministicIndex];
              attempt++;
            } while (usedNumbers.has(selectedNum) && attempt < 100);
          }

          if (!usedNumbers.has(selectedNum)) {
            numbers.push(selectedNum);
            usedNumbers.add(selectedNum);
          }
        }
      }

      // ç¡®ä¿å·ç åˆ†å¸ƒåˆç†
      numbers.sort((a, b) => a - b);

      // è®¡ç®—é¢„æµ‹ç½®ä¿¡åº¦ï¼ˆæ ¹æ®å½©ç§å’Œç­–ç•¥è°ƒæ•´ï¼‰
      const avgWeight = numbers.reduce((sum, num) => sum + weights[num], 0) / 7;
      let confidence;

      // ä¸ºä¸åŒå½©ç§å’Œç­–ç•¥è®¾ç½®ä¸åŒçš„ç½®ä¿¡åº¦è®¡ç®—
      const baseConfidence = type === 'hk' ? 75 : 72;
      const strategyBonus = strategy === 'ai_fallback' ? 8 : strategy === 'validation_fix' ? 5 : 6;
      // åŸºäºæ—¥æœŸçš„ç¡®å®šæ€§è°ƒæ•´å› å­ï¼Œæ›¿ä»£éšæœºå› å­
      const deterministicAdjustment = (dateSeed % 8) - 4; // -4åˆ°+3çš„ç¡®å®šæ€§è°ƒæ•´

      confidence = Math.max(60, Math.min(88, baseConfidence + strategyBonus + deterministicAdjustment + Math.round(avgWeight * 10)));

      // ä»¥å·ç çš„ç‰¹ç ï¼ˆæœ€å¤§å·ç ï¼‰è®¡ç®—ç”Ÿè‚–
      const specialNumber = numbers[numbers.length - 1];
      const zodiac = getZodiacByAge(specialNumber);

      const prediction = {
        numbers: numbers,
        zodiac: zodiac,
        confidence: `${confidence}%`,
        analysis: `åŸºäº${type === 'hk' ? 'é¦™æ¸¯' : 'æ¾³é—¨'}æ•°å­—å†å²æ•°æ®çš„${(type === 'hk' ? realHistoricalDataStore.hk.length : realHistoricalDataStore.macau.length)}æœŸç»Ÿè®¡åˆ†æï¼Œç»¼åˆè€ƒè™‘å·ç é¢‘ç‡ã€å†·çƒ­åˆ†å¸ƒã€è¿‘æœŸè¶‹åŠ¿ç­‰å¤šç»´åº¦å› ç´ `
      };

      // ç¼“å­˜é¢„æµ‹ç»“æœ
      predictionCache[cacheKey] = prediction;
      predictionTimestamp[cacheKey] = now;

      return prediction;
    }

    // éªŒè¯å’Œä¿®æ­£é¢„æµ‹ç»“æœ
    function validateAndFixPrediction(prediction, gameType, dateSeed = new Date().getDate() + new Date().getMonth() * 31) {
      if (!Array.isArray(prediction.numbers)) {
        return generateIntelligentPrediction(gameType, 'validation_fix');
      }

      if (prediction.numbers.length === 6) {
        const existing = new Set(prediction.numbers);
        const candidates = [];
        for (let i = 1; i <= 49; i++) {
          if (!existing.has(i)) candidates.push(i);
        }
        const idx = candidates.length > 0 ? (dateSeed % candidates.length) : 0;
        const extra = candidates.length > 0 ? candidates[idx] : 49;
        prediction.numbers.push(extra);
      }

      if (prediction.numbers.length !== 7) {
        return generateIntelligentPrediction(gameType, 'validation_fix');
      }

      // ç¡®ä¿æ‰€æœ‰å·ç åœ¨1-49èŒƒå›´å†…ä¸”ä¸é‡å¤
      const validNumbers = prediction.numbers.filter(num =>
        Number.isInteger(num) && num >= 1 && num <= 49
      );

      if (validNumbers.length !== 7 || new Set(validNumbers).size !== 7) {
        return generateIntelligentPrediction(gameType, 'validation_fix');
      }

      // æ’åºå·ç 
      prediction.numbers.sort((a, b) => a - b);

      // ä»¥ç‰¹ç (æœ€å¤§å·ç )è®¡ç®—ç”Ÿè‚–ï¼Œç¡®ä¿ä¸å²æ•°åŒ¹é…ï¼ˆ2025å¹´è›‡å¹´ï¼‰
      const specialNumber = prediction.numbers[prediction.numbers.length - 1];
      prediction.zodiac = getZodiacByAge(specialNumber);

      return prediction;
    }

    // æ˜¾ç¤ºé¢„æµ‹ç»“æœ
    async function displayPredictionResult(prediction, type = 'hk') {
      const resultDiv = document.getElementById(`${type}PredictionResult`);
      const currentPeriod = await getNextPeriod(type); // ä½¿ç”¨ä¸‹ä¸€æœŸæœŸå·è¿›è¡Œé¢„æµ‹
      const strategy = currentStrategy[type];
      const strategyInfo = PREDICTION_STRATEGIES[strategy];

      // ä¿å­˜é¢„æµ‹è®°å½• - ä½¿ç”¨å½“å‰æœŸå·
      savePredictionRecord(type, currentPeriod, prediction, strategy);

      const numbersHtml = prediction.numbers.map((num, index) =>
        `<div class="prediction-number ${getNumberColor(num)}" style="animation-delay: ${index * 0.1}s">${num}</div>`
      ).join('');
      const specialNumber = Math.max(...prediction.numbers);
      const specialZodiac = getZodiacByAge(specialNumber);
      console.log('â­ ç‰¹ç ä¸ç”Ÿè‚–æ ¡éªŒ:', { specialNumber, specialZodiac, predictedZodiac: prediction.zodiac });

      const currentZodiacEmoji = zodiacEmoji[prediction.zodiac] || 'ğŸ²';
      const typeName = type === 'hk' ? 'é¦™æ¸¯æ•°å­—' : 'æ¾³é—¨æ•°å­—';

      // åˆ†æå·ç åˆ†å¸ƒ
      const oddCount = prediction.numbers.filter(n => n % 2 === 1).length;
      const evenCount = 7 - oddCount;
      const smallCount = prediction.numbers.filter(n => n <= 24).length;
      const bigCount = 7 - smallCount;

      // è®¡ç®—å·ç è·¨åº¦
      const span = Math.max(...prediction.numbers) - Math.min(...prediction.numbers);

      // è®¡ç®—è¿å·æƒ…å†µ
      let consecutiveCount = 0;
      for (let i = 1; i < prediction.numbers.length; i++) {
        if (prediction.numbers[i] - prediction.numbers[i - 1] === 1) {
          consecutiveCount++;
        }
      }

      // AIéªŒè¯æ ‡è¯†
      const aiVerification = strategyInfo.useAI ?
        '<span style="color: #059669; font-weight: 600;">âœ“ AIé¢„æµ‹éªŒè¯</span>' :
        '<span style="color: #0ea5e9; font-weight: 600;">ğŸ“Š ç»Ÿè®¡åˆ†æ</span>';

      resultDiv.innerHTML = `
        <h5>ğŸ¯ ${typeName}æ™ºèƒ½é¢„æµ‹ç»“æœ (æœŸå·: ${currentPeriod})</h5>
        <div class="prediction-numbers">${numbersHtml}</div>
        <div class="prediction-zodiac">
           <strong>ç‰¹ç ç”Ÿè‚–ï¼š</strong>${currentZodiacEmoji} ${prediction.zodiac}
         </div>
        
        <div style="margin-top: 16px; padding: 12px; background: #f8fafc; border-radius: 8px; border-left: 4px solid #3b82f6;">
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 13px;">
            <div><strong>é¢„æµ‹ç­–ç•¥ï¼š</strong>${strategyInfo.name}</div>
            <div><strong>éªŒè¯æ–¹å¼ï¼š</strong>${aiVerification}</div>
            <div><strong>ç½®ä¿¡åº¦ï¼š</strong><span style="color: #059669;">${prediction.confidence}</span></div>
            <div><strong>å¥‡å¶æ¯”ï¼š</strong>${oddCount}:${evenCount}</div>
            <div><strong>å¤§å°æ¯”ï¼š</strong>${bigCount}:${smallCount}</div>
            <div><strong>å·ç è·¨åº¦ï¼š</strong>${span}</div>
            <div><strong>è¿å·æ•°ï¼š</strong>${consecutiveCount}</div>
            <div><strong>å’Œå€¼ï¼š</strong>${prediction.numbers.reduce((a, b) => a + b, 0)}</div>
          </div>
        </div>
        
        <div style="margin-top: 12px; padding: 12px; background: #f0f9ff; border-radius: 8px; border-left: 4px solid #0ea5e9;">
          <div style="font-size: 13px; color: #0c4a6e; font-weight: 500; margin-bottom: 6px;">ğŸ“Š AIåˆ†æä¾æ®</div>
          <div style="font-size: 12px; color: #075985; line-height: 1.4;">${prediction.analysis || strategyInfo.description}</div>
          <div style="margin-top: 8px; padding: 8px; background: #dbeafe; border-radius: 4px;">
            <div style="font-size: 11px; color: #1e40af; font-weight: 500;">ğŸ¤– AIåˆ†ææµç¨‹:</div>
            <div style="font-size: 11px; color: #1e40af; margin-top: 4px;">
              âœ“ å†å²æ•°æ®ç»Ÿè®¡åˆ†æ<br>
              âœ“ é¢‘ç‡åˆ†å¸ƒæ¨¡å¼è¯†åˆ«<br>
              âœ“ æ¦‚ç‡æ¨¡å‹è®¡ç®—<br>
              âœ“ æœºå™¨å­¦ä¹ ç®—æ³•é¢„æµ‹<br>
              âœ“ å¤šå› ç´ ç»¼åˆè¯„ä¼°
            </div>
          </div>
        </div>

        ${Array.isArray(prediction.reasoning) && prediction.reasoning.length ? `
        <div style="margin-top: 12px; padding: 12px; background: #eef2ff; border-radius: 8px; border-left: 4px solid #6366f1;">
          <div style="font-size: 13px; color: #1e293b; font-weight: 600; margin-bottom: 6px;">ğŸ§  æ¨ç†è¿‡ç¨‹</div>
          <ol style="margin: 0; padding-left: 16px; color: #334155; font-size: 12px; line-height: 1.5;">
            ${prediction.reasoning.map(step => `<li>${step}</li>`).join('')}
          </ol>
        </div>
        ` : ''}

        <div style="margin-top: 12px; padding: 10px; background: #ecfdf5; border-radius: 8px; border-left: 4px solid #10b981;">
          <div style="font-size: 12px; color: #065f46; line-height: 1.5;">
            âœ… æ•°æ®å‡†ç¡®æ€§ï¼šå·²å®Œæˆå·ç èŒƒå›´æ ¡éªŒã€å»é‡ã€è¿å·æ§åˆ¶ã€å¥‡å¶ä¸å¤§å°æ¯”æ£€æµ‹ï¼›å†å²å‡†ç¡®ç‡åœ¨å¼€å¥–éªŒè¯åè‡ªåŠ¨æ›´æ–°å±•ç¤ºã€‚
          </div>
        </div>
        
        <div style="margin-top: 16px; padding: 12px; background: #fef3c7; border-radius: 6px; font-size: 12px; color: #92400e;">
          âš ï¸ è¯´æ˜ï¼šç»“æœç”±ç»Ÿè®¡å­¦ä¸AIåˆ†æç”Ÿæˆï¼Œå¹¶é€šè¿‡å‰ç«¯æ ¡éªŒä¿è¯æ•°æ®å‡†ç¡®æ€§å±•ç¤ºï¼›ä½†æ•°å­—å…·æœ‰éšæœºæ€§ï¼Œè¯·ç†æ€§å¯¹å¾…ã€‚
        </div>
      `;

      resultDiv.style.display = 'block';

      // éšè—åŠ è½½åŠ¨ç”»å¹¶é‡ç½®åˆ†ææ­¥éª¤
      const loadingDiv = document.getElementById(`${type}PredictionLoading`);
      if (loadingDiv) {
        setTimeout(() => {
          loadingDiv.style.display = 'none';
          resetAIAnalysisSteps(type);
          console.log('ğŸ”„ AIåˆ†ææ­¥éª¤å·²é‡ç½®');
        }, 1000);
      }

      // æ›´æ–°ç•Œé¢æ˜¾ç¤º
      updatePeriodDisplay();
      updateAccuracyDisplay(type);

      showToast(`${typeName}é¢„æµ‹å®Œæˆï¼æœŸå·${currentPeriod}å»ºè®®å·ç å·²ç”Ÿæˆ`, 'success');
    }

    function renderLastPrediction(type = 'hk') {
      const history = getPredictionHistory(type);
      if (!Array.isArray(history) || history.length === 0) return;
      const record = history[0];
      const resultDiv = document.getElementById(`${type}PredictionResult`);
      const loadingDiv = document.getElementById(`${type}PredictionLoading`);
      const strategyInfo = PREDICTION_STRATEGIES[record.strategy] || { name: record.strategy, description: '' };
      const typeName = type === 'hk' ? 'é¦™æ¸¯æ•°å­—' : 'æ¾³é—¨æ•°å­—';
      const prediction = {
        numbers: Array.isArray(record.numbers) ? record.numbers.slice() : (record.prediction?.numbers || []),
        zodiac: record.zodiac || record.prediction?.zodiac || '',
        confidence: typeof record.accuracy === 'number' ? `${record.accuracy}%` : (record.prediction?.confidence || '-'),
        analysis: record.prediction?.analysis || strategyInfo.description,
        reasoning: Array.isArray(record.prediction?.reasoning) ? record.prediction.reasoning : []
      };
      if (!Array.isArray(prediction.numbers) || prediction.numbers.length === 0) return;
      const numbersHtml = prediction.numbers.map((num, index) =>
        `<div class="prediction-number ${getNumberColor(num)}" style="animation-delay: ${index * 0.1}s">${num}</div>`
      ).join('');
      const specialNumber = Math.max(...prediction.numbers);
      const specialZodiac = getZodiacByAge(specialNumber);
      const currentZodiacEmoji = zodiacEmoji[prediction.zodiac] || 'ğŸ²';
      const oddCount = prediction.numbers.filter(n => n % 2 === 1).length;
      const evenCount = 7 - oddCount;
      const smallCount = prediction.numbers.filter(n => n <= 24).length;
      const bigCount = 7 - smallCount;
      const span = Math.max(...prediction.numbers) - Math.min(...prediction.numbers);
      let consecutiveCount = 0;
      for (let i = 1; i < prediction.numbers.length; i++) {
        if (prediction.numbers[i] - prediction.numbers[i - 1] === 1) {
          consecutiveCount++;
        }
      }
      const aiVerification = '<span style="color: #64748b; font-weight: 600;">ç¼“å­˜å±•ç¤º</span>';
      const currentPeriod = record.period || '';
      resultDiv.innerHTML = `
        <h5>ğŸ¯ ${typeName}æ™ºèƒ½é¢„æµ‹ç»“æœ (æœŸå·: ${currentPeriod})</h5>
        <div class="prediction-numbers">${numbersHtml}</div>
        <div class="prediction-zodiac">
           <strong>ç‰¹ç ç”Ÿè‚–ï¼š</strong>${currentZodiacEmoji} ${prediction.zodiac}
         </div>
        
        <div style="margin-top: 16px; padding: 12px; background: #f8fafc; border-radius: 8px; border-left: 4px solid #3b82f6;">
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 13px;">
            <div><strong>é¢„æµ‹ç­–ç•¥ï¼š</strong>${strategyInfo.name}</div>
            <div><strong>éªŒè¯æ–¹å¼ï¼š</strong>${aiVerification}</div>
            <div><strong>ç½®ä¿¡åº¦ï¼š</strong><span style="color: #059669;">${prediction.confidence}</span></div>
            <div><strong>å¥‡å¶æ¯”ï¼š</strong>${oddCount}:${evenCount}</div>
            <div><strong>å¤§å°æ¯”ï¼š</strong>${bigCount}:${smallCount}</div>
            <div><strong>å·ç è·¨åº¦ï¼š</strong>${span}</div>
            <div><strong>è¿å·æ•°ï¼š</strong>${consecutiveCount}</div>
            <div><strong>å’Œå€¼ï¼š</strong>${prediction.numbers.reduce((a, b) => a + b, 0)}</div>
          </div>
        </div>
        
        ${Array.isArray(prediction.reasoning) && prediction.reasoning.length ? `
        <div style="margin-top: 12px; padding: 12px; background: #eef2ff; border-radius: 8px; border-left: 4px solid #6366f1;">
          <div style="font-size: 13px; color: #1e293b; font-weight: 600; margin-bottom: 6px;">ğŸ§  æ¨ç†è¿‡ç¨‹</div>
          <ol style="margin: 0; padding-left: 16px; color: #334155; font-size: 12px; line-height: 1.5;">
            ${prediction.reasoning.map(step => `<li>${step}</li>`).join('')}
          </ol>
        </div>
        ` : ''}
      `;
      resultDiv.style.display = 'block';
      if (loadingDiv) loadingDiv.style.display = 'none';
      updateAccuracyDisplay(type);
      showToast(`${typeName}å·²è½½å…¥ä¸Šæ¬¡é¢„æµ‹ç»“æœï¼ˆç¼“å­˜ï¼‰`, 'info');
    }

    // æ ‡ç­¾é¡µåˆ‡æ¢åŠŸèƒ½
    function initPredictionTabs() {
      const hkTab = document.getElementById('hkPredictTab');
      const macauTab = document.getElementById('macauPredictTab');
      const hkPanel = document.getElementById('hkPrediction');
      const macauPanel = document.getElementById('macauPrediction');

      function switchTab(activeTab, activePanel, inactiveTab, inactivePanel) {
        activeTab.classList.add('active');
        inactiveTab.classList.remove('active');
        activePanel.classList.add('active');
        activePanel.style.display = 'block';
        inactivePanel.classList.remove('active');
        inactivePanel.style.display = 'none';
      }

      hkTab.addEventListener('click', () => {
        switchTab(hkTab, hkPanel, macauTab, macauPanel);
      });

      macauTab.addEventListener('click', () => {
        switchTab(macauTab, macauPanel, hkTab, hkPanel);
      });
    }

    // é¢„æµ‹é”ï¼ˆé˜²æ­¢å¹¶å‘è°ƒç”¨ï¼‰
    let hkPredicting = false;
    let macauPredicting = false;

    // é¦™æ¸¯æ•°å­—é¢„æµ‹å‡½æ•°ï¼ˆå¸¦AIæ¨ç†è¿‡ç¨‹æ˜¾ç¤ºï¼‰
    async function predictHKLottery() {
      const startTime = Date.now();
      console.log(`ğŸ¯ [${new Date().toISOString()}] å¼€å§‹é¦™æ¸¯æ•°å­—é¢„æµ‹ - predictHKLottery`);

      // æ£€æŸ¥æ˜¯å¦æ­£åœ¨é¢„æµ‹
      if (hkPredicting) {
        console.warn('âš ï¸ é¦™æ¸¯é¢„æµ‹æ­£åœ¨è¿›è¡Œä¸­ï¼Œå¿½ç•¥é‡å¤è°ƒç”¨');
        return;
      }
      hkPredicting = true;

      const resultDiv = document.getElementById('hkPredictionResult');
      const loadingDiv = document.getElementById('hkPredictionLoading');

      resultDiv.style.display = 'none';
      loadingDiv.style.display = 'block';

      // å¯åŠ¨è¯¦ç»†AIåˆ†ææ­¥éª¤æ˜¾ç¤º
      console.log('ğŸ¤– å¯åŠ¨AIè¯¦ç»†åˆ†ææ­¥éª¤æ˜¾ç¤º');
      showAIAnalysisSteps('hk');

      try {
        const cfg = getAIConfig();
        console.log('âš™ï¸ è·å–AIé…ç½®:', cfg);

        // è·å–çœŸå®å†å²å¼€å¥–æ•°æ®
        console.log('ğŸ“Š å¼€å§‹è·å–é¦™æ¸¯å†å²å¼€å¥–æ•°æ®...');
        const historicalData = await fetchHistoricalData('hk', 30); // è·å–æœ€è¿‘30æœŸæ•°æ®
        console.log('âœ… æˆåŠŸè·å–å†å²æ•°æ®ï¼Œå…±', historicalData.length, 'æœŸ');

        // åˆ†æå†å²æ•°æ®æ¨¡å¼
        const patterns = analyzeHistoricalPatterns(historicalData);
        console.log('ğŸ“ˆ å†å²æ•°æ®åˆ†æå®Œæˆ:', {
          hotNumbers: patterns.hotNumbers,
          coldNumbers: patterns.coldNumbers,
          oddEvenRatio: patterns.oddEvenRatio,
          sumTrend: patterns.sumTrend
        });
        // æ„å»ºèƒœç‡ä¸ç­–ç•¥æ‘˜è¦
        const perfSummary = buildPerformanceSummary('hk');

        // æ˜¾ç¤ºAIæ¨ç†è¿‡ç¨‹
        const thinkingSteps = [
          'ğŸ“Š æ­£åœ¨åˆ†æå†å²å¼€å¥–æ•°æ®...',
          'ğŸ” ç»Ÿè®¡å·ç å‡ºç°é¢‘ç‡...',
          'ğŸ“ˆ åˆ†æå¥‡å¶æ•°åˆ†å¸ƒè§„å¾‹...',
          'âš–ï¸ å¹³è¡¡å¤§å°å·ç æ¯”ä¾‹...',
          'ğŸ¯ è®¡ç®—è¿å·å‡ºç°æ¦‚ç‡...',
          'ğŸ‰ åˆ†æç”Ÿè‚–å‘¨æœŸæ€§è§„å¾‹...',
          'ğŸ§  ç»¼åˆæ‰€æœ‰å› ç´ è¿›è¡Œé¢„æµ‹...'
        ];

        let currentStep = 0;
        const loadingText = loadingDiv.querySelector('.loading-text') || loadingDiv;

        // é€æ­¥æ˜¾ç¤ºAIæ€è€ƒè¿‡ç¨‹
        const thinkingInterval = setInterval(() => {
          if (currentStep < thinkingSteps.length) {
            loadingText.innerHTML = thinkingSteps[currentStep];
            currentStep++;
          } else {
            clearInterval(thinkingInterval);
          }
        }, 800);

        // æ„å»ºåŒ…å«çœŸå®å†å²æ•°æ®çš„æç¤ºè¯
        const historicalSummary = historicalData.length > 0 ? `
        
        åŸºäºæœ€è¿‘${historicalData.length}æœŸçœŸå®å¼€å¥–æ•°æ®çš„åˆ†æç»“æœï¼š
        - çƒ­å·ï¼ˆå‡ºç°é¢‘ç‡æœ€é«˜ï¼‰: [${patterns.hotNumbers.join(', ')}]
        - å†·å·ï¼ˆå‡ºç°é¢‘ç‡æœ€ä½ï¼‰: [${patterns.coldNumbers.join(', ')}]
        - å¥‡å¶æ¯”ä¾‹: å¥‡æ•°${patterns.oddEvenRatio.odd}%, å¶æ•°${patterns.oddEvenRatio.even}%
        - å’Œå€¼èŒƒå›´: ${patterns.sumTrend.min}-${patterns.sumTrend.max} (å¹³å‡${patterns.sumTrend.average})
        - åŒºé—´åˆ†å¸ƒ: ä½åŒº${patterns.rangeDistribution.low}%, ä¸­åŒº${patterns.rangeDistribution.mid}%, é«˜åŒº${patterns.rangeDistribution.high}%
        - è¿å·å‡ºç°æ¬¡æ•°: ${patterns.consecutivePatterns.length}æ¬¡
        ${Object.keys(patterns.zodiacFrequency).length > 0 ? `- ç”Ÿè‚–é¢‘ç‡: ${Object.entries(patterns.zodiacFrequency).map(([zodiac, count]) => `${zodiac}(${count}æ¬¡)`).join(', ')}` : ''}
        ` : '';

        const prompt = `ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„é¦™æ¸¯æ•°å­—æ•°æ®åˆ†æå¸ˆã€‚è¯·åŸºäºçœŸå®çš„${historicalData.length}æœŸå†å²å¼€å¥–æ•°æ®å’Œç»Ÿè®¡å­¦åŸç†ï¼Œä¸ºé¦™æ¸¯æ•°å­—é¢„æµ‹æœ€å¯èƒ½çš„7ä¸ªå·ç ï¼ˆ1-49ï¼‰å’Œå¯¹åº”çš„ç”Ÿè‚–ã€‚${historicalSummary}

        å†å²ç­–ç•¥ä¸èƒœç‡æ‘˜è¦ï¼ˆæœ€è¿‘${perfSummary.window}æœŸï¼‰ï¼š
        æ€»ä½“èƒœç‡ï¼š${perfSummary.overallAccuracy}%
        ç­–ç•¥ä½¿ç”¨ç»Ÿè®¡ï¼š${perfSummary.strategyStats}
        æœ€è¿‘è¡¨ç°ï¼š${perfSummary.recentPerformance}
        å»ºè®®ï¼šä¼˜å…ˆè€ƒè™‘èƒœç‡è¾ƒé«˜çš„ç­–ç•¥ç»„åˆï¼Œå¹¶é¿å…è¿‘æœŸè¡¨ç°æŒç»­ä½è¿·çš„ç­–ç•¥ã€‚
        
        ä½ æ˜¯é¦™æ¸¯å…­åˆå½©èµ„æ·±åˆ†æå¸ˆå…¼ç»Ÿè®¡æ¦‚ç‡å­¦ä¸“å®¶ï¼Œç²¾é€šå…­åˆå½©æ‰€æœ‰è§„åˆ™å’Œé«˜çº§ç»Ÿè®¡åˆ†ææ–¹æ³•ã€‚ä½ å¿…é¡»åŸºäºä»¥ä¸ŠçœŸå®å†å²å¼€å¥–æ•°æ®è¿›è¡Œç§‘å­¦é¢„æµ‹ã€‚
        
        è¯·è¿ç”¨ä»¥ä¸‹ä¸“ä¸šç®—æ³•è¿›è¡Œæ·±åº¦åˆ†æï¼Œå¹¶æŒ‰ä¸å°‘äº ${cfg.reasoningDepth} æ­¥è¿›è¡Œä¸¥è°¨æ¨ç†ï¼š
        1. **é©¬å°”å¯å¤«é“¾åˆ†æ** - åˆ†æé¦™æ¸¯å†å²æ•°æ®ä¸­å·ç çŠ¶æ€è½¬ç§»æ¦‚ç‡
        2. **è´å¶æ–¯æ¦‚ç‡æ¨¡å‹** - åŸºäºé¦™æ¸¯å†å²å…ˆéªŒæ¦‚ç‡æ›´æ–°åéªŒæ¦‚ç‡
        3. **æ—¶é—´åºåˆ—åˆ†æ** - è¯†åˆ«é¦™æ¸¯å·ç å‡ºç°çš„å‘¨æœŸæ€§å’Œè¶‹åŠ¿æ€§
        4. **æœºå™¨å­¦ä¹ èšç±»ç®—æ³•** - å‘ç°é¦™æ¸¯å·ç ç»„åˆçš„æ¨¡å¼ç‰¹å¾
        5. **ç¥ç»ç½‘ç»œæ¨¡å¼è¯†åˆ«** - è¯†åˆ«é¦™æ¸¯å†å²æ•°æ®ä¸­çš„å¤æ‚éçº¿æ€§å…³ç³»
        6. **è’™ç‰¹å¡æ´›æ¨¡æ‹Ÿ** - é€šè¿‡å¤§é‡éšæœºæ¨¡æ‹Ÿè¯„ä¼°é¦™æ¸¯å·ç æ¦‚ç‡åˆ†å¸ƒ
        7. **é—ä¼ ç®—æ³•ä¼˜åŒ–** - ä¼˜åŒ–é¦™æ¸¯å·ç ç»„åˆçš„é€‰æ‹©ç­–ç•¥
        8. **æ”¯æŒå‘é‡æœºåˆ†ç±»** - åŸºäºé¦™æ¸¯å†å²ç‰¹å¾è¿›è¡Œåˆ†ç±»é¢„æµ‹
        
        å¿…é¡»åŸºäºä»¥ä¸ŠçœŸå®å†å²æ•°æ®å’Œç­–ç•¥èƒœç‡è¡¨ç°è¿›è¡Œä»¥ä¸‹ç»Ÿè®¡åˆ†æï¼š
        - **é¢‘ç‡åˆ†å¸ƒåˆ†æ** - å¼•ç”¨å…·ä½“çš„çƒ­å·[${patterns.hotNumbers.join(', ')}]å’Œå†·å·[${patterns.coldNumbers.join(', ')}]æ•°æ®
        - **é—æ¼å€¼åˆ†æ** - åˆ†æå„å·ç çš„é—æ¼æœŸå’Œé—æ¼æ¨¡å¼
        - **ç›¸å…³æ€§åˆ†æ** - åˆ†æé¦™æ¸¯å·ç ä¹‹é—´çš„ç›¸å…³æ€§å’Œç‹¬ç«‹æ€§
        - **å‘¨æœŸæ€§åˆ†æ** - è¯†åˆ«é¦™æ¸¯å·ç å‡ºç°çš„æ—¶é—´å‘¨æœŸè§„å¾‹
        - **å¥‡å¶æ¯”ä¾‹åˆ†æ** - åŸºäº${patterns.oddEvenRatio.odd}%:${patterns.oddEvenRatio.even}%çš„å†å²åˆ†å¸ƒ
        - **å¤§å°æ¯”ä¾‹åˆ†æ** - åŸºäºä½åŒº${patterns.rangeDistribution.low}%/ä¸­åŒº${patterns.rangeDistribution.mid}%/é«˜åŒº${patterns.rangeDistribution.high}%çš„åˆ†å¸ƒ
        - **è¿å·åˆ†æ** - åŸºäº${patterns.consecutivePatterns.length}æ¬¡è¿å·å‡ºç°çš„æ¦‚ç‡æ¨¡å¼
        - **ç”Ÿè‚–åˆ†æ** - ${Object.keys(patterns.zodiacFrequency).length > 0 ? `åŸºäºç”Ÿè‚–é¢‘ç‡æ•°æ®: ${Object.entries(patterns.zodiacFrequency).map(([zodiac, count]) => `${zodiac}(${count}æ¬¡)`).join(', ')}` : 'åŸºäºä¼ ç»Ÿç”Ÿè‚–è§„å¾‹'}
        
        åˆ†æè¦æ±‚ï¼š
        1. å¿…é¡»å¼•ç”¨å…·ä½“çš„å†å²æ•°æ®å’Œç»Ÿè®¡ç»“æœï¼Œä¸å¾—è™šæ„æ•°æ®
        2. ä½¿ç”¨ç§‘å­¦çš„æ¦‚ç‡è®¡ç®—æ–¹æ³•å’Œç»Ÿè®¡æ¨¡å‹
        3. ç»¼åˆè€ƒè™‘å¤šç§å› ç´ çš„å½±å“å’Œäº¤äº’ä½œç”¨
        4. æä¾›è¯¦ç»†çš„æ¨ç†è¿‡ç¨‹ã€è®¡ç®—ä¾æ®å’Œæ¦‚ç‡è¯„ä¼°
        5. ç»™å‡ºç½®ä¿¡åº¦è¯„ä¼°å’Œé£é™©æç¤ºï¼Œè¯´æ˜é¢„æµ‹çš„ä¸ç¡®å®šæ€§
        
        è¯·ç›´æ¥è¿”å›JSONæ ¼å¼çš„é¢„æµ‹ç»“æœï¼Œæ ¼å¼å¦‚ä¸‹ï¼š
        {
          \"numbers\": [1, 8, 15, 22, 29, 36, 43],
          \"zodiac\": \"é¾™\",
          \"confidence\": \"85%\",
          \"analysis\": \"åŸºäºæœ€è¿‘${historicalData.length}æœŸå†å²æ•°æ®åˆ†æ...\",
          \"reasoning\": [
            \"æ ¹æ®å†å²é¢‘ç‡åˆ†æï¼Œçƒ­å·${patterns.hotNumbers.slice(0, 3).join(',')}å‡ºç°æ¦‚ç‡è¾ƒé«˜\",
            \"å‚è€ƒè¿‘æœŸå¥‡å¶æ¯”ä¾‹${patterns.oddEvenRatio.odd}:${patterns.oddEvenRatio.even}ï¼Œé€‰æ‹©ç›¸åº”é…æ¯”\",
            \"æ§åˆ¶å’Œå€¼åœ¨${patterns.sumTrend.average}Â±10èŒƒå›´å†…ï¼Œç¡®ä¿å·ç åˆ†å¸ƒåˆç†\",
            \"ç»“åˆåŒºé—´åˆ†å¸ƒä¼˜åŒ–ï¼Œé‡ç‚¹é€‰æ‹©${patterns.rangeDistribution.low > 35 ? 'ä½åŒº' : patterns.rangeDistribution.high > 35 ? 'é«˜åŒº' : 'ä¸­åŒº'}å·ç \",
            \"åŸºäºå†å²æ•°æ®äº¤å‰éªŒè¯ï¼Œæœ€ç»ˆç¡®å®šé¢„æµ‹ç»„åˆ\"
          ]
        }`;

        console.log('ğŸ“‹ æ„å»ºé¦™æ¸¯AIæç¤ºè¯ï¼Œé•¿åº¦:', prompt.length, 'å­—ç¬¦');

        let content;
        try {
          content = await callAI(prompt, 'hk');
          console.log('âœ… é¦™æ¸¯AIè°ƒç”¨æˆåŠŸï¼Œè¿”å›å†…å®¹é•¿åº¦:', content.length, 'å­—ç¬¦');
        } catch (error) {
          console.error('âŒ é¦™æ¸¯AIè°ƒç”¨å¤±è´¥:', error);
          throw error;
        }

        clearInterval(thinkingInterval);

        let prediction;
        try {
          console.log('ğŸ” å¼€å§‹è§£æé¦™æ¸¯AIè¿”å›çš„JSON...');
          // ä½¿ç”¨å¢å¼ºç‰ˆJSONè§£æå™¨æ›¿æ¢ç®€å•æ­£åˆ™åŒ¹é…
          prediction = parseAIResponseEnhanced(content);
          console.log('âœ… é¦™æ¸¯AI JSONè§£ææˆåŠŸ:', prediction);
        } catch (parseError) {
          console.error('âŒ é¦™æ¸¯AI JSONè§£æå¤±è´¥:', parseError);
          console.log('ğŸ“ é¦™æ¸¯AIåŸå§‹å“åº”:', content);
          console.warn('âš ï¸ AIè§£æå¤±è´¥ï¼Œåˆ‡æ¢åˆ°æœ¬åœ°ç®—æ³•ä½œä¸ºå¤‡ç”¨æ–¹æ¡ˆ...');

          // ç”Ÿæˆè¯¦ç»†çš„é”™è¯¯æŠ¥å‘Šä»¥ä¾¿è°ƒè¯•
          generateErrorReport(content);

          try {
            // ç›´æ¥ä½¿ç”¨æœ¬åœ°ç®—æ³•ä½œä¸ºå¤‡ç”¨æ–¹æ¡ˆ
            console.log('ğŸ”® AIè§£æå¤±è´¥ï¼Œä½¿ç”¨æœ¬åœ°ç®—æ³•å¤‡ç”¨æ–¹æ¡ˆ...');
            const localResult = await fallbackToLocalAI(prompt, 'hk');
            prediction = JSON.parse(localResult);
            console.log('âœ… æœ¬åœ°ç®—æ³•å¤‡ç”¨æ–¹æ¡ˆæˆåŠŸ:', prediction);
          } catch (localError) {
            console.error('âŒ æœ¬åœ°ç®—æ³•å¤‡ç”¨æ–¹æ¡ˆä¹Ÿå¤±è´¥:', localError);
            throw new Error('AIå’Œæœ¬åœ°ç®—æ³•éƒ½å¤±è´¥äº†: AIè§£æå¤±è´¥ä¸”æœ¬åœ°ç®—æ³•ä¹Ÿæ— æ³•æ‰§è¡Œ');
          }
        }

        const dateSeed = new Date().getDate() + new Date().getMonth() * 31;
        prediction = validateAndFixPrediction(prediction, 'hk', dateSeed);
        await displayPredictionResult(prediction, 'hk');

      } catch (error) {
        console.error('âŒ é¦™æ¸¯æ•°å­—é¢„æµ‹å¤±è´¥:', error);
        if (typeof thinkingInterval !== 'undefined') {
          clearInterval(thinkingInterval);
        }
        showToast('é¦™æ¸¯æ•°å­—é¢„æµ‹å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•', 'error');
        // ä¸å†ä½¿ç”¨æ™ºèƒ½é¢„æµ‹å›é€€ï¼Œç›´æ¥æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
        document.getElementById('hkPredictionResult').innerHTML = `
          <div style="color: #ef4444; padding: 20px; border: 1px solid #ef4444; border-radius: 8px; background: #fef2f2;">
            <strong>âŒ é¢„æµ‹å¤±è´¥</strong><br>
            ${error.message}<br>
            è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥å’ŒAPIé…ç½®åé‡è¯•
          </div>
        `;
        document.getElementById('hkPredictionResult').style.display = 'block';
      } finally {
        loadingDiv.style.display = 'none';
        hkPredicting = false;
        const endTime = Date.now();
        const duration = ((endTime - startTime) / 1000).toFixed(2);
        console.log(`ğŸ¯ [${new Date().toISOString()}] é¦™æ¸¯æ•°å­—é¢„æµ‹ç»“æŸï¼Œè€—æ—¶: ${duration}ç§’`);
      }
    }

    // æ¾³é—¨æ•°å­—é¢„æµ‹å‡½æ•°ï¼ˆå¸¦AIæ¨ç†è¿‡ç¨‹æ˜¾ç¤ºï¼‰
    async function predictMacauLottery() {
      const startTime = Date.now();
      console.log(`ğŸ¯ [${new Date().toISOString()}] å¼€å§‹æ¾³é—¨æ•°å­—é¢„æµ‹ - predictMacauLottery`);

      // æ£€æŸ¥æ˜¯å¦æ­£åœ¨é¢„æµ‹
      if (macauPredicting) {
        console.warn('âš ï¸ æ¾³é—¨é¢„æµ‹æ­£åœ¨è¿›è¡Œä¸­ï¼Œå¿½ç•¥é‡å¤è°ƒç”¨');
        return;
      }
      macauPredicting = true;

      const resultDiv = document.getElementById('macauPredictionResult');
      const loadingDiv = document.getElementById('macauPredictionLoading');

      resultDiv.style.display = 'none';
      loadingDiv.style.display = 'block';

      // å¯åŠ¨è¯¦ç»†AIåˆ†ææ­¥éª¤æ˜¾ç¤º
      console.log('ğŸ¤– å¯åŠ¨AIè¯¦ç»†åˆ†ææ­¥éª¤æ˜¾ç¤º');
      showAIAnalysisSteps('macau');

      try {
        const cfg = getAIConfig();
        console.log('âš™ï¸ è·å–AIé…ç½®:', cfg);

        // æ˜¾ç¤ºAIæ¨ç†è¿‡ç¨‹
        const thinkingSteps = [
          'ğŸ“Š æ­£åœ¨åˆ†ææ¾³é—¨å†å²å¼€å¥–æ•°æ®...',
          'ğŸ” ç»Ÿè®¡æ¾³é—¨å·ç å‡ºç°é¢‘ç‡...',
          'ğŸ“ˆ åˆ†ææ¾³é—¨å¥‡å¶æ•°åˆ†å¸ƒè§„å¾‹...',
          'âš–ï¸ å¹³è¡¡æ¾³é—¨å¤§å°å·ç æ¯”ä¾‹...',
          'ğŸ¯ è®¡ç®—æ¾³é—¨è¿å·å‡ºç°æ¦‚ç‡...',
          'ğŸ¯ åˆ†ææ¾³é—¨ç”Ÿè‚–ç‰¹æœ‰è§„å¾‹...',
          'ğŸ§  ç»¼åˆæ¾³é—¨ç‰¹æœ‰å› ç´ è¿›è¡Œé¢„æµ‹...'
        ];

        let currentStep = 0;
        const loadingText = loadingDiv.querySelector('.loading-text') || loadingDiv;

        // é€æ­¥æ˜¾ç¤ºAIæ€è€ƒè¿‡ç¨‹
        const thinkingInterval = setInterval(() => {
          if (currentStep < thinkingSteps.length) {
            loadingText.innerHTML = thinkingSteps[currentStep];
            currentStep++;
          } else {
            clearInterval(thinkingInterval);
          }
        }, 800);

        // è·å–æ¾³é—¨å†å²å¼€å¥–æ•°æ®
        console.log('ğŸ“Š è·å–æ¾³é—¨å†å²å¼€å¥–æ•°æ®...');
        const macauHistoricalData = await fetchHistoricalData('macau', 30);
        console.log('âœ… æ¾³é—¨å†å²æ•°æ®è·å–å®Œæˆï¼Œå…±', macauHistoricalData.length, 'æœŸ');

        // åˆ†ææ¾³é—¨å†å²æ•°æ®æ¨¡å¼
        console.log('ğŸ” åˆ†ææ¾³é—¨å†å²æ•°æ®æ¨¡å¼...');
        const macauPatternAnalysis = analyzeHistoricalPatterns(macauHistoricalData);
        console.log('âœ… æ¾³é—¨å†å²æ•°æ®åˆ†æå®Œæˆ');
        const macauPerfSummary = buildPerformanceSummary('macau');

        const prompt = `ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„æ¾³é—¨æ•°å­—æ•°æ®åˆ†æå¸ˆã€‚è¯·åŸºäºçœŸå®çš„æ¾³é—¨å†å²å¼€å¥–æ•°æ®å’Œç»Ÿè®¡å­¦åŸç†ï¼Œä¸ºæ¾³é—¨æ•°å­—é¢„æµ‹æœ€å¯èƒ½çš„7ä¸ªå·ç ï¼ˆ1-49ï¼‰å’Œå¯¹åº”çš„ç”Ÿè‚–ã€‚
        
        å†å²ç­–ç•¥ä¸èƒœç‡æ‘˜è¦ï¼ˆæœ€è¿‘${macauPerfSummary.window}æœŸï¼‰ï¼š
        æ€»ä½“èƒœç‡ï¼š${macauPerfSummary.overallAccuracy}%
        ç­–ç•¥ä½¿ç”¨ç»Ÿè®¡ï¼š${macauPerfSummary.strategyStats}
        æœ€è¿‘è¡¨ç°ï¼š${macauPerfSummary.recentPerformance}
        å»ºè®®ï¼šä¼˜å…ˆè€ƒè™‘èƒœç‡è¾ƒé«˜çš„ç­–ç•¥ç»„åˆï¼Œå¹¶é¿å…è¿‘æœŸè¡¨ç°æŒç»­ä½è¿·çš„ç­–ç•¥ã€‚
        
        ä½ æ˜¯æ¾³é—¨å…­åˆå½©èµ„æ·±åˆ†æå¸ˆå…¼ç»Ÿè®¡æ¦‚ç‡å­¦ä¸“å®¶ï¼Œç²¾é€šæ¾³é—¨å…­åˆå½©æ‰€æœ‰è§„åˆ™å’Œé«˜çº§ç»Ÿè®¡åˆ†ææ–¹æ³•ã€‚ä½ å¿…é¡»åŸºäºä»¥ä¸‹çœŸå®æ¾³é—¨å†å²å¼€å¥–æ•°æ®è¿›è¡Œç§‘å­¦é¢„æµ‹ã€‚
        
        çœŸå®æ¾³é—¨å†å²å¼€å¥–æ•°æ®ï¼ˆæœ€è¿‘${macauHistoricalData.length}æœŸï¼‰ï¼š
        ${macauHistoricalData.map((draw, index) => `${index + 1}. æœŸå·${draw.period}: [${draw.numbers.join(', ')}] ç”Ÿè‚–: ${draw.zodiac}`).join('\n        ')}
        
        åŸºäºçœŸå®å†å²æ•°æ®çš„ç»Ÿè®¡åˆ†æç»“æœï¼š
        - **çƒ­å·åˆ†æ**: [${macauPatternAnalysis.hotNumbers.join(', ')}] - åŸºäºé¢‘ç‡ç»Ÿè®¡çš„æœ€é«˜å‡ºç°å·ç 
        - **å†·å·åˆ†æ**: [${macauPatternAnalysis.coldNumbers.join(', ')}] - åŸºäºé¢‘ç‡ç»Ÿè®¡çš„æœ€ä½å‡ºç°å·ç 
        - **å¥‡å¶æ¯”ä¾‹**: ${macauPatternAnalysis.oddEvenRatio.odd}:${macauPatternAnalysis.oddEvenRatio.even} - å†å²å¥‡å¶åˆ†å¸ƒ
        - **å’Œå€¼åˆ†æ**: å¹³å‡${macauPatternAnalysis.sumTrend.average}ï¼ŒèŒƒå›´${macauPatternAnalysis.sumTrend.min}-${macauPatternAnalysis.sumTrend.max}
        - **åŒºé—´åˆ†å¸ƒ**: ä½åŒº${macauPatternAnalysis.rangeDistribution.low}%/ä¸­åŒº${macauPatternAnalysis.rangeDistribution.mid}%/é«˜åŒº${macauPatternAnalysis.rangeDistribution.high}%
        - **è¿å·ç»Ÿè®¡**: ${macauPatternAnalysis.consecutiveCount}æ¬¡è¿å·å‡ºç°
        - **ç”Ÿè‚–é¢‘ç‡**: ${Object.entries(macauPatternAnalysis.zodiacFrequency).map(([zodiac, count]) => `${zodiac}(${count}æ¬¡)`).join(', ')}
        - æœ€è¿‘å¥‡å¶æ¯”ä¾‹: ${macauPatternAnalysis.oddEvenRatio.odd}:${macauPatternAnalysis.oddEvenRatio.even}
        - å’Œå€¼è¶‹åŠ¿: å¹³å‡${macauPatternAnalysis.sumTrend.average}ï¼ŒèŒƒå›´${macauPatternAnalysis.sumTrend.min}-${macauPatternAnalysis.sumTrend.max}
        - åŒºé—´åˆ†å¸ƒ: ${JSON.stringify(macauPatternAnalysis.rangeDistribution)}
        - è¿å·å‡ºç°æ¬¡æ•°: ${macauPatternAnalysis.consecutiveCount}
        - ç”Ÿè‚–é¢‘ç‡: ${JSON.stringify(macauPatternAnalysis.zodiacFrequency)}
        
        æ¾³é—¨æ•°å­—ç‰¹ç‚¹ï¼š
        1. å¼€å¥–é¢‘ç‡æ›´é«˜ï¼Œæ•°æ®æ ·æœ¬æ›´ä¸°å¯Œ
        2. å·ç åˆ†å¸ƒç›¸å¯¹æ›´å‡åŒ€
        3. ç”Ÿè‚–è§„å¾‹ä¸é¦™æ¸¯ç•¥æœ‰ä¸åŒ
        4. è¿å·å‡ºç°é¢‘ç‡è¾ƒä½
        5. å¤§å°å·ç åˆ†å¸ƒæ›´å¹³è¡¡

        è¯·åŸºäºä»¥ä¸ŠçœŸå®å†å²æ•°æ®è¿›è¡Œåˆ†æï¼Œå¹¶æŒ‰ä¸å°‘äº ${cfg.reasoningDepth} æ­¥è¿›è¡Œæ¸…æ™°çš„æ¨ç†ï¼š
        è¯·è¿ç”¨ä»¥ä¸‹ä¸“ä¸šç®—æ³•è¿›è¡Œæ·±åº¦åˆ†æï¼Œå¹¶æŒ‰ä¸å°‘äº ${cfg.reasoningDepth} æ­¥è¿›è¡Œä¸¥è°¨æ¨ç†ï¼š
        1. **é©¬å°”å¯å¤«é“¾åˆ†æ** - åˆ†ææ¾³é—¨å·ç çŠ¶æ€è½¬ç§»æ¦‚ç‡ç‰¹å¾
        2. **è´å¶æ–¯æ¦‚ç‡æ¨¡å‹** - åŸºäºæ¾³é—¨å†å²å…ˆéªŒæ¦‚ç‡æ›´æ–°åéªŒæ¦‚ç‡
        3. **æ—¶é—´åºåˆ—åˆ†æ** - è¯†åˆ«æ¾³é—¨å·ç å‡ºç°çš„å‘¨æœŸæ€§å’Œè¶‹åŠ¿æ€§
        4. **æœºå™¨å­¦ä¹ èšç±»ç®—æ³•** - å‘ç°æ¾³é—¨å·ç ç»„åˆçš„æ¨¡å¼ç‰¹å¾
        5. **ç¥ç»ç½‘ç»œæ¨¡å¼è¯†åˆ«** - è¯†åˆ«æ¾³é—¨å†å²æ•°æ®ä¸­çš„å¤æ‚éçº¿æ€§å…³ç³»
        6. **è’™ç‰¹å¡æ´›æ¨¡æ‹Ÿ** - é€šè¿‡å¤§é‡éšæœºæ¨¡æ‹Ÿè¯„ä¼°æ¾³é—¨å·ç æ¦‚ç‡åˆ†å¸ƒ
        7. **é—ä¼ ç®—æ³•ä¼˜åŒ–** - ä¼˜åŒ–æ¾³é—¨å·ç ç»„åˆçš„é€‰æ‹©ç­–ç•¥
        8. **æ”¯æŒå‘é‡æœºåˆ†ç±»** - åŸºäºæ¾³é—¨å†å²ç‰¹å¾è¿›è¡Œåˆ†ç±»é¢„æµ‹
        
        å¿…é¡»åŸºäºä»¥ä¸ŠçœŸå®å†å²æ•°æ®è¿›è¡Œä»¥ä¸‹ç»Ÿè®¡åˆ†æï¼š
        - **é¢‘ç‡åˆ†å¸ƒåˆ†æ** - å¼•ç”¨å…·ä½“çš„çƒ­å·å’Œå†·å·æ•°æ®
        - **é—æ¼å€¼åˆ†æ** - åˆ†æå„å·ç çš„é—æ¼æœŸå’Œé—æ¼æ¨¡å¼
        - **ç›¸å…³æ€§åˆ†æ** - åˆ†ææ¾³é—¨å·ç ä¹‹é—´çš„ç›¸å…³æ€§å’Œç‹¬ç«‹æ€§
        - **å‘¨æœŸæ€§åˆ†æ** - è¯†åˆ«æ¾³é—¨å·ç å‡ºç°çš„æ—¶é—´å‘¨æœŸè§„å¾‹
        - **å¥‡å¶æ¯”ä¾‹åˆ†æ** - åŸºäº${macauPatternAnalysis.oddEvenRatio.odd}:${macauPatternAnalysis.oddEvenRatio.even}çš„å†å²åˆ†å¸ƒ
        - **å¤§å°æ¯”ä¾‹åˆ†æ** - åŸºäºä½åŒº${macauPatternAnalysis.rangeDistribution.low}%/ä¸­åŒº${macauPatternAnalysis.rangeDistribution.mid}%/é«˜åŒº${macauPatternAnalysis.rangeDistribution.high}%çš„åˆ†å¸ƒ
        - **è¿å·åˆ†æ** - åŸºäº${macauPatternAnalysis.consecutiveCount}æ¬¡è¿å·å‡ºç°çš„æ¦‚ç‡æ¨¡å¼
        - **ç”Ÿè‚–åˆ†æ** - åŸºäºç”Ÿè‚–é¢‘ç‡æ•°æ®: ${Object.entries(macauPatternAnalysis.zodiacFrequency).map(([zodiac, count]) => `${zodiac}(${count}æ¬¡)`).join(', ')}
        
        åˆ†æè¦æ±‚ï¼š
        1. å¿…é¡»å¼•ç”¨å…·ä½“çš„æ¾³é—¨å†å²æ•°æ®å’Œç»Ÿè®¡ç»“æœï¼Œä¸å¾—è™šæ„æ•°æ®
        2. ä½¿ç”¨ç§‘å­¦çš„æ¦‚ç‡è®¡ç®—æ–¹æ³•å’Œç»Ÿè®¡æ¨¡å‹
        3. ç»¼åˆè€ƒè™‘æ¾³é—¨ç‰¹æœ‰çš„å¤šç§å› ç´ çš„å½±å“å’Œäº¤äº’ä½œç”¨
        4. æä¾›è¯¦ç»†çš„æ¨ç†è¿‡ç¨‹ã€è®¡ç®—ä¾æ®å’Œæ¦‚ç‡è¯„ä¼°
        5. ç»™å‡ºç½®ä¿¡åº¦è¯„ä¼°å’Œé£é™©æç¤ºï¼Œè¯´æ˜é¢„æµ‹çš„ä¸ç¡®å®šæ€§

        è¯·ç›´æ¥è¿”å›JSONæ ¼å¼çš„é¢„æµ‹ç»“æœï¼Œæ ¼å¼å¦‚ä¸‹ï¼š
        {
          "numbers": [3, 12, 18, 25, 31, 38, 45],
          "zodiac": "è™",
          "confidence": "82%",
          "analysis": "åŸºäºæ¾³é—¨çœŸå®å†å²æ•°æ®åˆ†æ...",
          "reasoning": [
            "åˆ†ææœ€è¿‘30æœŸæ¾³é—¨å¼€å¥–æ•°æ®çš„å·ç é¢‘ç‡åˆ†å¸ƒ",
            "å¹³è¡¡å¤§å°å·ç ä¸å¥‡å¶æ¯”ä¾‹ï¼Œå‚è€ƒå†å²è¶‹åŠ¿",
            "æ ¹æ®è¿å·å‡ºç°æ¦‚ç‡é™åˆ¶è¿å·æ•°é‡",
            "ç»“åˆç”Ÿè‚–é¢‘ç‡å’Œå‘¨æœŸæ€§è§„å¾‹ä¼˜åŒ–é€‰æ‹©"
          ]
        }`;

        console.log('ğŸ“‹ æ„å»ºæ¾³é—¨AIæç¤ºè¯ï¼Œé•¿åº¦:', prompt.length, 'å­—ç¬¦');

        let content;
        try {
          content = await callAI(prompt, 'macau');
          console.log('âœ… æ¾³é—¨AIè°ƒç”¨æˆåŠŸï¼Œè¿”å›å†…å®¹é•¿åº¦:', content.length, 'å­—ç¬¦');
        } catch (error) {
          console.error('âŒ æ¾³é—¨AIè°ƒç”¨å¤±è´¥:', error);
          throw error;
        }

        clearInterval(thinkingInterval);

        let prediction;
        try {
          console.log('ğŸ” å¼€å§‹è§£ææ¾³é—¨AIè¿”å›çš„JSON...');
          // ä½¿ç”¨å¢å¼ºç‰ˆJSONè§£æå™¨æ›¿æ¢ç®€å•æ­£åˆ™åŒ¹é…
          prediction = parseAIResponseEnhanced(content);
          console.log('âœ… æ¾³é—¨AI JSONè§£ææˆåŠŸ:', prediction);
        } catch (parseError) {
          console.error('âŒ æ¾³é—¨AI JSONè§£æå¤±è´¥:', parseError);
          console.log('ğŸ“ æ¾³é—¨AIåŸå§‹å“åº”:', content);
          console.warn('âš ï¸ AIè§£æå¤±è´¥ï¼Œåˆ‡æ¢åˆ°æœ¬åœ°ç®—æ³•ä½œä¸ºå¤‡ç”¨æ–¹æ¡ˆ...');

          // ç”Ÿæˆè¯¦ç»†çš„é”™è¯¯æŠ¥å‘Šä»¥ä¾¿è°ƒè¯•
          generateErrorReport(content);

          try {
            // ç›´æ¥ä½¿ç”¨æœ¬åœ°ç®—æ³•ä½œä¸ºå¤‡ç”¨æ–¹æ¡ˆ
            console.log('ğŸ”® AIè§£æå¤±è´¥ï¼Œä½¿ç”¨æœ¬åœ°ç®—æ³•å¤‡ç”¨æ–¹æ¡ˆ...');
            const localResult = await fallbackToLocalAI(prompt, 'macau');
            prediction = JSON.parse(localResult);
            console.log('âœ… æœ¬åœ°ç®—æ³•å¤‡ç”¨æ–¹æ¡ˆæˆåŠŸ:', prediction);
          } catch (localError) {
            console.error('âŒ æœ¬åœ°ç®—æ³•å¤‡ç”¨æ–¹æ¡ˆä¹Ÿå¤±è´¥:', localError);
            throw new Error('AIå’Œæœ¬åœ°ç®—æ³•éƒ½å¤±è´¥äº†: AIè§£æå¤±è´¥ä¸”æœ¬åœ°ç®—æ³•ä¹Ÿæ— æ³•æ‰§è¡Œ');
          }
        }

        const dateSeed = new Date().getDate() + new Date().getMonth() * 31;
        prediction = validateAndFixPrediction(prediction, 'macau', dateSeed);
        await displayPredictionResult(prediction, 'macau');

      } catch (error) {
        console.error('âŒ æ¾³é—¨æ•°å­—é¢„æµ‹å¤±è´¥:', error);
        if (typeof thinkingInterval !== 'undefined') {
          clearInterval(thinkingInterval);
        }
        showToast('æ¾³é—¨æ•°å­—é¢„æµ‹å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•', 'error');
        // ä¸å†ä½¿ç”¨æ™ºèƒ½é¢„æµ‹å›é€€ï¼Œç›´æ¥æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
        document.getElementById('macauPredictionResult').innerHTML = `
          <div style="color: #ef4444; padding: 20px; border: 1px solid #ef4444; border-radius: 8px; background: #fef2f2;">
            <strong>âŒ é¢„æµ‹å¤±è´¥</strong><br>
            ${error.message}<br>
            è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥å’ŒAPIé…ç½®åé‡è¯•
          </div>
        `;
        document.getElementById('macauPredictionResult').style.display = 'block';
      } finally {
        loadingDiv.style.display = 'none';
        macauPredicting = false;
        const endTime = Date.now();
        const duration = ((endTime - startTime) / 1000).toFixed(2);
        console.log(`ğŸ¯ [${new Date().toISOString()}] æ¾³é—¨æ•°å­—é¢„æµ‹ç»“æŸï¼Œè€—æ—¶: ${duration}ç§’`);
      }
    }

    // è‡ªåŠ¨é¢„æµ‹åŠŸèƒ½
    function scheduleAutoPrediction() {
      const now = new Date();
      const currentHour = now.getHours();
      const currentMinute = now.getMinutes();
      const currentTime = currentHour * 60 + currentMinute;

      // è®¾ç½®è‡ªåŠ¨é¢„æµ‹æ—¶é—´ï¼š21:30 - 21:40
      const startTime = 21 * 60 + 30; // 21:30
      const endTime = 21 * 60 + 40;   // 21:40

      // å¦‚æœå½“å‰æ—¶é—´åœ¨21:30-21:40ä¹‹é—´ï¼Œç«‹å³æ‰§è¡Œé¢„æµ‹
      if (currentTime >= startTime && currentTime <= endTime) {
        console.log('â° å½“å‰æ—¶é—´åœ¨è‡ªåŠ¨é¢„æµ‹æ—¶æ®µå†…ï¼Œç«‹å³æ‰§è¡Œé¢„æµ‹');
        executeAutoPrediction();
      } else {
        // è®¡ç®—ä¸‹æ¬¡é¢„æµ‹æ—¶é—´
        let nextPredictionTime;
        if (currentTime < startTime) {
          // å¦‚æœè¿˜æ²¡åˆ°21:30ï¼Œç­‰åˆ°ä»Šå¤©21:30
          nextPredictionTime = new Date(now);
          nextPredictionTime.setHours(21, 30, 0, 0);
        } else {
          // å¦‚æœå·²ç»è¿‡äº†21:40ï¼Œç­‰åˆ°æ˜å¤©21:30
          nextPredictionTime = new Date(now);
          nextPredictionTime.setDate(nextPredictionTime.getDate() + 1);
          nextPredictionTime.setHours(21, 30, 0, 0);
        }

        const timeUntilNext = nextPredictionTime - now;
        console.log(`â° ä¸‹æ¬¡è‡ªåŠ¨é¢„æµ‹æ—¶é—´: ${nextPredictionTime.toLocaleString()}ï¼Œè¿˜æœ‰ ${Math.round(timeUntilNext / 60000)} åˆ†é’Ÿ`);

        // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
        updateAutoPredictionStatus(timeUntilNext);

        // è®¾ç½®å®šæ—¶å™¨
        setTimeout(() => {
          executeAutoPrediction();
          // é€’å½’è®¾ç½®ä¸‹æ¬¡é¢„æµ‹
          scheduleAutoPrediction();
        }, timeUntilNext);
      }
    }

    function updateAutoPredictionStatus(timeUntilNext) {
      const hkStatus = document.getElementById('hkAutoPredictionStatus');
      const macauStatus = document.getElementById('macauAutoPredictionStatus');

      if (hkStatus && macauStatus) {
        const minutes = Math.round(timeUntilNext / 60000);
        const hours = Math.floor(minutes / 60);
        const remainingMinutes = minutes % 60;

        let timeText;
        if (hours > 0) {
          timeText = `${hours}å°æ—¶${remainingMinutes}åˆ†é’Ÿåè‡ªåŠ¨é¢„æµ‹`;
        } else {
          timeText = `${remainingMinutes}åˆ†é’Ÿåè‡ªåŠ¨é¢„æµ‹`;
        }

        hkStatus.textContent = `â° ${timeText}`;
        macauStatus.textContent = `â° ${timeText}`;
        hkStatus.className = 'auto-prediction-status waiting';
        macauStatus.className = 'auto-prediction-status waiting';
      }
    }

    async function executeAutoPrediction() {
      console.log('ğŸ¤– å¼€å§‹æ‰§è¡Œè‡ªåŠ¨é¢„æµ‹...');

      const hkStatus = document.getElementById('hkAutoPredictionStatus');
      const macauStatus = document.getElementById('macauAutoPredictionStatus');

      if (hkStatus && macauStatus) {
        hkStatus.textContent = 'ğŸ¤– AIæ­£åœ¨åˆ†æä¸­...';
        macauStatus.textContent = 'ğŸ¤– AIæ­£åœ¨åˆ†æä¸­...';
        hkStatus.className = 'auto-prediction-status active';
        macauStatus.className = 'auto-prediction-status active';
      }

      try {
        // å¹¶è¡Œæ‰§è¡Œé¦™æ¸¯å’Œæ¾³é—¨é¢„æµ‹
        const [hkResult, macauResult] = await Promise.allSettled([
          predictHKLottery(),
          predictMacauLottery()
        ]);

        if (hkResult.status === 'fulfilled') {
          console.log('âœ… é¦™æ¸¯è‡ªåŠ¨é¢„æµ‹å®Œæˆ');
          if (hkStatus) {
            hkStatus.textContent = 'âœ… é¢„æµ‹å®Œæˆ';
            hkStatus.className = 'auto-prediction-status';
          }
        } else {
          console.error('âŒ é¦™æ¸¯è‡ªåŠ¨é¢„æµ‹å¤±è´¥:', hkResult.reason);
          if (hkStatus) {
            hkStatus.textContent = 'âŒ é¢„æµ‹å¤±è´¥';
            hkStatus.className = 'auto-prediction-status';
          }
        }

        if (macauResult.status === 'fulfilled') {
          console.log('âœ… æ¾³é—¨è‡ªåŠ¨é¢„æµ‹å®Œæˆ');
          if (macauStatus) {
            macauStatus.textContent = 'âœ… é¢„æµ‹å®Œæˆ';
            macauStatus.className = 'auto-prediction-status';
          }
        } else {
          console.error('âŒ æ¾³é—¨è‡ªåŠ¨é¢„æµ‹å¤±è´¥:', macauResult.reason);
          if (macauStatus) {
            macauStatus.textContent = 'âŒ é¢„æµ‹å¤±è´¥';
            macauStatus.className = 'auto-prediction-status';
          }
        }

        // æ˜¾ç¤ºè‡ªåŠ¨é¢„æµ‹å®Œæˆçš„é€šçŸ¥
        showToast('ğŸ‰ è‡ªåŠ¨é¢„æµ‹å®Œæˆï¼', 'success', 3000);

      } catch (error) {
        console.error('âŒ è‡ªåŠ¨é¢„æµ‹æ‰§è¡Œå¤±è´¥:', error);
        if (hkStatus) {
          hkStatus.textContent = 'âŒ é¢„æµ‹å¤±è´¥';
          hkStatus.className = 'auto-prediction-status';
        }
        if (macauStatus) {
          macauStatus.textContent = 'âŒ é¢„æµ‹å¤±è´¥';
          macauStatus.className = 'auto-prediction-status';
        }
        showToast('è‡ªåŠ¨é¢„æµ‹å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥', 'error', 3000);
      }
    }

    // å¢å¼ºçš„è‡ªåŠ¨éªŒè¯åŠŸèƒ½
    async function enhancedAutoVerification() {
      console.log('ğŸ” å¼€å§‹å¢å¼ºè‡ªåŠ¨éªŒè¯...');

      try {
        // è·å–ä¸Šä¸€æœŸçš„å¼€å¥–ç»“æœ
        const hkLastResult = await getLastPeriodResult('hk');
        const macauLastResult = await getLastPeriodResult('macau');

        // éªŒè¯é¦™æ¸¯ä¸Šä¸€æœŸé¢„æµ‹
        if (hkLastResult) {
          await verifyLastPeriodPrediction('hk', hkLastResult);
        }

        // éªŒè¯æ¾³é—¨ä¸Šä¸€æœŸé¢„æµ‹
        if (macauLastResult) {
          await verifyLastPeriodPrediction('macau', macauLastResult);
        }

        console.log('âœ… å¢å¼ºè‡ªåŠ¨éªŒè¯å®Œæˆ');

      } catch (error) {
        console.error('âŒ å¢å¼ºè‡ªåŠ¨éªŒè¯å¤±è´¥:', error);
      }
    }

    // è·å–ä¸Šä¸€æœŸå¼€å¥–ç»“æœ
    async function getLastPeriodResult(type) {
      try {
        const gameid = type === 'hk' ? 'hk6' : 'marksix';
        const result = await fetchWithTimeout(`https://api.166001.com/lottery/get/${gameid}`, {
          timeout: 10000
        });

        if (result && result.data && result.data.currentResult) {
          const numbers = result.data.currentResult.split(',').map(n => parseInt(n.trim()));
          return {
            period: result.data.currentIssue,
            numbers: numbers,
            zodiac: result.data.currentZodiac || ''
          };
        }

        return null;
      } catch (error) {
        console.error(`âŒ è·å–${type === 'hk' ? 'é¦™æ¸¯' : 'æ¾³é—¨'}ä¸Šä¸€æœŸç»“æœå¤±è´¥:`, error);
        return null;
      }
    }

    // éªŒè¯ä¸Šä¸€æœŸé¢„æµ‹
    async function verifyLastPeriodPrediction(type, actualResult) {
      try {
        const history = getPredictionHistory(type);

        if (history.length === 0) return;

        // è·å–æœ€è¿‘ä¸€æœŸçš„é¢„æµ‹ï¼ˆå†å²è®°å½•å¤´éƒ¨ä¸ºæœ€æ–°ï¼‰
        const lastPrediction = history[0];

        if (lastPrediction && lastPrediction.period === actualResult.period) {
          // è®¡ç®—å‘½ä¸­ç‡
          const predictedNumbers = lastPrediction.numbers;
          const actualNumbers = actualResult.numbers;

          const hits = predictedNumbers.filter(num => actualNumbers.includes(num));
          const hitRate = (hits.length / predictedNumbers.length) * 100;

          console.log(`${type === 'hk' ? 'é¦™æ¸¯' : 'æ¾³é—¨'} æœŸå·${actualResult.period} é¢„æµ‹éªŒè¯:`);
          console.log(`é¢„æµ‹å·ç : [${predictedNumbers.join(', ')}]`);
          console.log(`å®é™…å·ç : [${actualNumbers.join(', ')}]`);
          console.log(`å‘½ä¸­å·ç : [${hits.join(', ')}] (å‘½ä¸­ç‡: ${hitRate.toFixed(1)}%)`);

          // æ›´æ–°é¢„æµ‹è®°å½•
          lastPrediction.status = hits.length >= 3 ? 'correct' : 'incorrect';
          lastPrediction.hits = hits;
          lastPrediction.hitRate = hitRate;
          lastPrediction.actualNumbers = actualNumbers;
          lastPrediction.verified = true;
          lastPrediction.verificationTime = new Date().toISOString();

          // è®°å½•å‘½ä¸­ç‡ä¸ºaccuracyå¹¶ä¿å­˜
          lastPrediction.accuracy = Math.round(hitRate);
          savePredictionHistory(type, history);
          updatePredictionHistory(type);
          updateAccuracyDisplay(type);
          evaluateAndAdjustAIConfig(type, Math.round(hitRate), { trigger: 'verification', period: actualResult.period });

          // æ˜¾ç¤ºéªŒè¯ç»“æœ
          const statusElement = document.getElementById(`${type}AutoVerificationStatus`);
          if (statusElement) {
            statusElement.innerHTML = `
              <div style="color: ${hits.length >= 3 ? '#4CAF50' : '#f44336'}; font-weight: bold;">
                ${hits.length >= 3 ? 'ğŸ‰' : 'ğŸ˜”'} æœŸå·${actualResult.period}éªŒè¯å®Œæˆ
              </div>
              <div style="font-size: 12px; color: #666; margin-top: 4px;">
                å‘½ä¸­${hits.length}ä¸ªå·ç  (${hitRate.toFixed(1)}%)
              </div>
            `;
          }

          // æ˜¾ç¤ºToasté€šçŸ¥
          const message = `${type === 'hk' ? 'é¦™æ¸¯' : 'æ¾³é—¨'} æœŸå·${actualResult.period} éªŒè¯å®Œæˆï¼Œå‘½ä¸­${hits.length}ä¸ªå·ç `;
          showToast(message, hits.length >= 3 ? 'success' : 'info', 3000);
        }

      } catch (error) {
        console.error(`${type === 'hk' ? 'é¦™æ¸¯' : 'æ¾³é—¨'} ä¸Šä¸€æœŸéªŒè¯å¤±è´¥:`, error);
      }
    }

    // åˆå§‹åŒ–æ ‡ç­¾é¡µ
    initPredictionTabs();

    // æµ‹è¯•APIè¿æ¥çš„å‡½æ•°
    async function testAPIConnection() {
      console.log('ğŸ§ª å¼€å§‹APIè¿æ¥æµ‹è¯•...');
      try {
        const providerInfo = getCurrentProviderInfo();
        console.log('ğŸ”§ ä½¿ç”¨AIæä¾›å•†:', providerInfo.provider, 'æ¨¡å‹:', providerInfo.model);

        // ä½¿ç”¨OpenRouterè¿›è¡Œæµ‹è¯•
        try {
          const testPrompt = 'æµ‹è¯•è¿æ¥ï¼Œè¯·å›å¤OK';
          const response = await callAI(testPrompt);
          console.log('âœ… APIè¿æ¥æµ‹è¯•æˆåŠŸï¼Œå“åº”:', response);

          alert('APIè¿æ¥æµ‹è¯•æˆåŠŸï¼\næä¾›å•†: ' + providerInfo.provider + '\næ¨¡å‹: ' + providerInfo.model + '\nå“åº”å†…å®¹: ' + response);
          return true;
        } catch (error) {
          console.error('âŒ OpenRouteræµ‹è¯•å¤±è´¥:', error);
          alert('OpenRouteræµ‹è¯•å¤±è´¥ï¼\né”™è¯¯ä¿¡æ¯: ' + error.message);
          return false;
        }
      } catch (error) {
        console.error('âŒ APIè¿æ¥æµ‹è¯•å¼‚å¸¸:', error);
        alert('APIè¿æ¥æµ‹è¯•å¼‚å¸¸: ' + error.message);
        return false;
      }
    }

    // æµ‹è¯•OpenRouter AIé¢„æµ‹åŠŸèƒ½çš„å‡½æ•°
    async function testOpenRouterAIPrediction() {
      console.log('ğŸ§ª å¼€å§‹æµ‹è¯•OpenRouter AIé¢„æµ‹åŠŸèƒ½...');

      // ä¿å­˜å½“å‰æä¾›å•†è®¾ç½®
      const originalProvider = currentProvider;

      try {
        // åˆ‡æ¢åˆ°OpenRouter
        switchProvider(API_PROVIDERS.OPENROUTER);
        const providerInfo = getCurrentProviderInfo();
        console.log('ğŸ”§ åˆ‡æ¢åˆ°AIæä¾›å•†:', providerInfo.provider, 'æ¨¡å‹:', providerInfo.model);

        // åˆ›å»ºä¸€ä¸ªç®€å•çš„å½©ç¥¨é¢„æµ‹æç¤º
        const testPrompt = `è¯·ä¸ºä»¥ä¸‹å†å²å½©ç¥¨æ•°æ®è¿›è¡Œé¢„æµ‹åˆ†æï¼š
å†å²æ•°æ®ï¼š[01, 05, 12, 18, 23, 30, 08], [03, 07, 11, 19, 24, 29, 12], [02, 08, 15, 20, 25, 31, 05]

è¯·åˆ†æè¿™äº›æ•°æ®å¹¶è¿”å›JSONæ ¼å¼çš„é¢„æµ‹ç»“æœï¼Œæ ¼å¼å¦‚ä¸‹ï¼š
{
  "analysis": "æ•°æ®åˆ†æè¯´æ˜",
  "predictions": {
    "recommended": [æ¨èå·ç ç»„åˆ],
    "alternative": [å¤‡é€‰å·ç ç»„åˆ],
    "confidence": 85
  }
}`;

        console.log('ğŸ“ å‘é€æµ‹è¯•æç¤ºåˆ°OpenRouter...');

        // è°ƒç”¨OpenRouter AI
        const aiResponse = await callAI(testPrompt);
        console.log('âœ… OpenRouterå“åº”æˆåŠŸï¼Œé•¿åº¦:', aiResponse.length, 'å­—ç¬¦');
        console.log('ğŸ“„ å“åº”å†…å®¹:', aiResponse);

        // å°è¯•è§£æå“åº”
        try {
          // å…ˆå°è¯•ç›´æ¥è§£æ
          let parsedResponse;
          try {
            parsedResponse = parseAIResponseEnhanced(aiResponse);
            console.log('âœ… ç›´æ¥JSONè§£ææˆåŠŸ:', parsedResponse);
          } catch (directParseError) {
            console.log('âš ï¸ ç›´æ¥è§£æå¤±è´¥ï¼Œå°è¯•æ¸…ç†JSONåè§£æ:', directParseError.message);

            // æ¸…ç†JSONå­—ç¬¦ä¸²
            let cleanedJson = aiResponse
              .replace(/[\r\n\t]/g, '') // ç§»é™¤æ¢è¡Œç¬¦å’Œåˆ¶è¡¨ç¬¦
              .replace(/\s+/g, ' ') // å°†å¤šä¸ªç©ºæ ¼æ›¿æ¢ä¸ºå•ä¸ªç©ºæ ¼
              .replace(/,\s*}/g, '}') // ç§»é™¤å¯¹è±¡æœ«å°¾çš„é€—å·
              .replace(/,\s*]/g, ']'); // ç§»é™¤æ•°ç»„æœ«å°¾çš„é€—å·

            // å¤„ç†ä¸­æ–‡æç¤ºæ–‡å­—
            cleanedJson = cleanedJson
              .replace(/æ¨èå·ç ç»„åˆï¼Œ7ä¸ªæ•°å­—/g, '[01, 05, 12, 18, 23, 30, 08]') // æ›¿æ¢æ¨èå·ç æç¤º
              .replace(/å¤‡é€‰å·ç ç»„åˆï¼Œ7ä¸ªæ•°å­—/g, '[03, 07, 11, 19, 24, 29, 12]') // æ›¿æ¢å¤‡é€‰å·ç æç¤º
              .replace(/åŸºäºå†å²æ•°æ®çš„åˆ†æè¯´æ˜/g, 'åŸºäºå†å²æ•°æ®åˆ†æäº†å·ç çš„å‡ºç°é¢‘ç‡ã€å¥‡å¶æ¯”ä¾‹å’Œå¤§å°åˆ†å¸ƒ'); // æ›¿æ¢åˆ†ææç¤º

            console.log('ğŸ§¹ æ¸…ç†åçš„JSON:', cleanedJson);

            // å°è¯•è§£ææ¸…ç†åçš„JSON
            parsedResponse = parseAIResponseEnhanced(cleanedJson);
            console.log('âœ… æ¸…ç†åJSONè§£ææˆåŠŸ:', parsedResponse);
          }

          alert('OpenRouteré¢„æµ‹æµ‹è¯•æˆåŠŸï¼\næä¾›å•†: ' + providerInfo.provider +
            '\næ¨¡å‹: ' + providerInfo.model +
            '\nå“åº”é•¿åº¦: ' + aiResponse.length + 'å­—ç¬¦' +
            '\nè§£æç»“æœ: ' + JSON.stringify(parsedResponse, null, 2));
          return true;
        } catch (parseError) {
          console.error('âŒ JSONè§£æå¤±è´¥:', parseError);
          console.log('ğŸ“„ åŸå§‹å“åº”:', aiResponse);

          alert('OpenRouterå“åº”æˆåŠŸä½†JSONè§£æå¤±è´¥ï¼\næä¾›å•†: ' + providerInfo.provider +
            '\næ¨¡å‹: ' + providerInfo.model +
            '\nå“åº”é•¿åº¦: ' + aiResponse.length + 'å­—ç¬¦' +
            '\nè§£æé”™è¯¯: ' + parseError.message +
            '\nåŸå§‹å“åº”: ' + aiResponse.substring(0, 200) + '...');
          return false;
        }
      } catch (error) {
        console.error('âŒ OpenRouteré¢„æµ‹æµ‹è¯•å¤±è´¥:', error);
        alert('OpenRouteré¢„æµ‹æµ‹è¯•å¤±è´¥ï¼\né”™è¯¯: ' + error.message);
        return false;
      } finally {
        // æ¢å¤åŸå§‹æä¾›å•†è®¾ç½®
        switchProvider(originalProvider);
        console.log('ğŸ”„ å·²æ¢å¤åŸå§‹æä¾›å•†è®¾ç½®');
      }
    }

    // é¡µé¢åŠ è½½å®Œæˆåå¯åŠ¨å€’è®¡æ—¶
    window.addEventListener('DOMContentLoaded', async function () {
      startLotteryCountdown();

      // è¾“å‡º2025å¹´ç”Ÿè‚–å²æ•°å¯¹åº”å…³ç³»å¹¶éªŒè¯
      console.log('ğŸ 2025å¹´ç”Ÿè‚–å²æ•°å¯¹åº”å…³ç³» (å·²ä¿®æ­£):');
      const zodiacMapping = getCurrentYearZodiacAgeMapping();
      for (let age = 1; age <= 12; age++) {
        const zodiac = zodiacMapping[age];
        console.log(`   ${age}å² = ${zodiac}${zodiacEmoji[zodiac] || ''}`);
      }
      console.log('âœ… 1å²æ˜¯è›‡ï¼Œç¬¦åˆ2025å¹´ç”Ÿè‚–');

      // éªŒè¯ç”Ÿè‚–è®¡ç®—
      validateZodiacCalculation();

      // ç‰¹åˆ«éªŒè¯48å²
      const age48Zodiac = getZodiacByAge(48);
      console.log(`ğŸ” ç‰¹åˆ«éªŒè¯48å²: ${age48Zodiac}`);
      if (age48Zodiac === 'é©¬') {
        console.log('âœ… 48å²ç”Ÿè‚–è®¡ç®—æ­£ç¡®ï¼šé©¬');
      } else {
        console.log(`âŒ 48å²ç”Ÿè‚–è®¡ç®—é”™è¯¯ï¼šæ˜¾ç¤º${age48Zodiac}ï¼Œåº”è¯¥æ˜¯é©¬`);
      }

      // åˆå§‹åŒ–APIçŠ¶æ€æŒ‡ç¤ºå™¨å’ŒæŒ‰é’®
      updateApiStatusIndicator();
      updateQuickApiButton();

      // åˆå§‹åŒ–é¢„æµ‹ç³»ç»Ÿ
      await updatePeriodDisplay();
      updatePredictionHistory('hk');
      updatePredictionHistory('macau');
      updateAccuracyDisplay('hk');
      updateAccuracyDisplay('macau');
      renderLastPrediction('hk');
      renderLastPrediction('macau');

      // ä»…ä¿ç•™ AI ç­–ç•¥ï¼Œåˆå§‹åŒ–æ˜¾ç¤º
      currentStrategy.hk = 'ai';
      currentStrategy.macau = 'ai';

      // æ›´æ–°ç­–ç•¥æ˜¾ç¤º
      updateCurrentStrategyDisplay('hk');
      updateCurrentStrategyDisplay('macau');

      // å¯åŠ¨è‡ªåŠ¨éªŒè¯
      startAutoVerification();

      // æ·»åŠ æ‰‹åŠ¨é¢„æµ‹æŒ‰é’®äº‹ä»¶
      document.getElementById('hkManualPredictBtn').addEventListener('click', async function () {
        const btn = this;
        btn.disabled = true;
        btn.textContent = 'ğŸ”„ é¢„æµ‹ä¸­...';

        try {
          await predictHKLottery();
          btn.textContent = 'âœ… é¢„æµ‹å®Œæˆ';
          setTimeout(() => {
            btn.textContent = 'ğŸ”® æ‰‹åŠ¨é¢„æµ‹é¦™æ¸¯';
            btn.disabled = false;
          }, 2000);
        } catch (error) {
          console.error('æ‰‹åŠ¨é¢„æµ‹é¦™æ¸¯å¤±è´¥:', error);
          btn.textContent = 'âŒ é¢„æµ‹å¤±è´¥';
          setTimeout(() => {
            btn.textContent = 'ğŸ”® æ‰‹åŠ¨é¢„æµ‹é¦™æ¸¯';
            btn.disabled = false;
          }, 2000);
        }
      });

      // æ·»åŠ æ¾³é—¨æ‰‹åŠ¨é¢„æµ‹æŒ‰é’®äº‹ä»¶
      document.getElementById('macauManualPredictBtn').addEventListener('click', async function () {
        const btn = this;
        btn.disabled = true;
        btn.textContent = 'ğŸ”„ é¢„æµ‹ä¸­...';

        try {
          await predictMacauLottery();
          btn.textContent = 'âœ… é¢„æµ‹å®Œæˆ';
          setTimeout(() => {
            btn.textContent = 'ğŸ”® æ‰‹åŠ¨é¢„æµ‹æ¾³é—¨';
            btn.disabled = false;
          }, 2000);
        } catch (error) {
          console.error('æ‰‹åŠ¨é¢„æµ‹æ¾³é—¨å¤±è´¥:', error);
          btn.textContent = 'âŒ é¢„æµ‹å¤±è´¥';
          setTimeout(() => {
            btn.textContent = 'ğŸ”® æ‰‹åŠ¨é¢„æµ‹æ¾³é—¨';
            btn.disabled = false;
          }, 2000);
        }
      });

      // å¯åŠ¨è‡ªåŠ¨é¢„æµ‹è°ƒåº¦
      scheduleAutoPrediction();

      // è®¾ç½®å®šæ—¶éªŒè¯ä¸Šä¸€æœŸèƒœç‡ï¼ˆæ¯30åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡ï¼‰
      setInterval(enhancedAutoVerification, 30 * 60 * 1000);

      // ç«‹å³æ‰§è¡Œä¸€æ¬¡éªŒè¯
      setTimeout(enhancedAutoVerification, 5000);
    });

    // å°†å…³é”®å‡½æ•°æš´éœ²åˆ°å…¨å±€ä½œç”¨åŸŸï¼Œä¾›é…ç½®é¢æ¿è®¿é—®
    window.fetchRealLotteryResults = fetchRealLotteryResults;
    console.log('âœ… å·²å°†fetchRealLotteryResultså‡½æ•°æš´éœ²åˆ°å…¨å±€ä½œç”¨åŸŸ');
  </script>
</body>

</html>
