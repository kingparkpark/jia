<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç®—æ³•å›æµ‹å·¥å…· - æ¾³é—¨ç¬¬335æœŸ</title>
    <script src="js/prediction-engine.js"></script>
    <script src="js/ai-analyst.js"></script>
    <style>
        body { font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; padding: 20px; background: #1a1a2e; color: #e0e0e0; }
        .card { background: #16213e; padding: 20px; border-radius: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.3); margin-bottom: 20px; border: 1px solid #2a2a4a; }
        h1 { margin-top: 0; color: #fff; }
        h2 { color: #a78bfa; }
        table { width: 100%; border-collapse: collapse; margin-top: 15px; }
        th, td { border: 1px solid #2a2a4a; padding: 12px; text-align: left; }
        th { background-color: #1f2937; color: #9ca3af; }
        tr:nth-child(even) { background-color: #0f3460; }
        .match { color: #4ade80; font-weight: bold; }
        .btn { padding: 12px 24px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold; transition: transform 0.2s; }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(118, 75, 162, 0.4); }
        .status-log { font-family: monospace; color: #9ca3af; margin-top: 10px; max-height: 200px; overflow-y: auto; background: #0f172a; padding: 10px; border-radius: 6px; }
        .rank-1 { color: #ffd700; font-weight: bold; }
        .rank-2 { color: #c0c0c0; font-weight: bold; }
        .rank-3 { color: #cd7f32; font-weight: bold; }
    </style>
</head>
<body>
    <div class="card">
        <h1>ğŸ”¬ ç®—æ³•å¯é æ€§å›æµ‹å·¥å…·</h1>
        <p>ç›®æ ‡ï¼š<strong>æ¾³é—¨å…­åˆå½© ç¬¬335æœŸ</strong></p>
        <p>å·²çŸ¥ç»“æœï¼š<span id="targetResult" style="color:#4ade80; font-size:1.2em; font-weight:bold;">34, 35, 46, 31, 13, 3, 44</span></p>
        
        <div style="margin: 20px 0; padding: 15px; background: rgba(255,255,255,0.05); border-radius: 8px;">
            <div style="margin-bottom: 10px; color: #a78bfa; font-weight: bold;">ğŸ¤– AI è®¾ç½®</div>
            <input type="text" id="apiKeyInput" placeholder="OpenRouter API Key (sk-or-..., è‹¥å†…ç½®Keyå¤±æ•ˆè¯·åœ¨æ­¤å¡«å…¥)" 
                   style="width: 100%; max-width: 500px; padding: 10px; background: #0f172a; border: 1px solid #334155; color: white; border-radius: 6px;">
            <div style="margin-top: 5px; font-size: 12px; color: #64748b;">* å°†è°ƒç”¨ LLM (Llama-3.3/Gemini) è¿›è¡Œæ·±åº¦åˆ†æï¼Œè€—æ—¶è¾ƒé•¿</div>
        </div>

        <div style="margin: 20px 0; display: flex; gap: 10px; flex-wrap: wrap;">
            <button class="btn" onclick="runBacktest()">ğŸš€ å•æœŸå›æµ‹ (å½“å‰é…ç½®)</button>
            
            <div style="display: flex; align-items: center; gap: 10px; background: rgba(255,255,255,0.05); padding: 0 15px; border-radius: 8px;">
                <span>ğŸ”„ æ‰¹é‡å›æµ‹: æœ€è¿‘</span>
                <select id="batchCount" style="background: #0f172a; color: white; border: 1px solid #334155; padding: 5px; border-radius: 4px;">
                    <option value="10">10 æœŸ</option>
                    <option value="30">30 æœŸ</option>
                    <option value="50">50 æœŸ</option>
                </select>
                <button class="btn" style="background: linear-gradient(135deg, #10b981 0%, #059669 100%);" onclick="runBatchBacktest()">ğŸ“Š å¼€å§‹å¤§æ•°æ®è¯„æµ‹</button>
            </div>
            
            <button class="btn" style="background: #3b82f6;" onclick="showRawData()">ğŸ” æ£€è§†åŸå§‹æ•°æ®æº</button>
        </div>
        <div id="status" class="status-log">ç­‰å¾…å¼€å§‹...</div>
    </div>

    <!-- æ–°å¢ï¼šå®æ—¶å›æµ‹ç›‘æ§é¢æ¿ -->
    <div class="card" id="monitorCard" style="display:none; border: 1px solid #f59e0b;">
        <h3 style="color: #f59e0b; margin-top:0;">ğŸ•µï¸â€â™‚ï¸ å›æµ‹å®æ—¶ç›‘æ§ (éªŒè¯çœŸå®æ€§)</h3>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
            <div>
                <div style="font-size:12px; color:#9ca3af;">å½“å‰å›æµ‹ç›®æ ‡</div>
                <div id="monitorPeriod" style="font-size:24px; font-weight:bold;">-</div>
            </div>
            <div>
                <div style="font-size:12px; color:#9ca3af;">çœŸå®å¼€å¥–ç»“æœ (æ¥è‡ªAPI)</div>
                <div id="monitorReal" style="font-size:18px; color:#4ade80; font-family:monospace;">-</div>
            </div>
        </div>
        <div style="margin-top: 10px; font-size:12px; color:#9ca3af;">
            æœ€ä½³é¢„æµ‹: <span id="monitorBest" style="color:#fff;">-</span>
        </div>
        <div style="margin-top: 5px; background: #334155; height: 4px; border-radius: 2px;">
            <div id="monitorProgress" style="width: 0%; height: 100%; background: #f59e0b; transition: width 0.1s;"></div>
        </div>
    </div>

    <div class="card" id="batchResultCard" style="display:none;">
        <h2>ğŸ† å¤§æ•°æ®è¯„æµ‹æ’è¡Œæ¦œ (åŸºäºå†å²å›æµ‹)</h2>
        <div id="batchResultTable"></div>
    </div>

    <div class="card" id="resultCard" style="display:none;">
        <h2>ğŸ“Š å•æœŸè¯¦æƒ… (æŒ‰å‘½ä¸­æ•°æ’åº)</h2>
        <div id="resultTable"></div>
    </div>

    <script>
        // æµ‹è¯•é¡µé¢å·²ç§»é™¤æ‰€æœ‰éšæœºå› ç´ ï¼Œç¡®ä¿çº¯ç¡®å®šæ€§ç®—æ³•æ‰§è¡Œ

        // é…ç½®ç›®æ ‡ï¼šé¦™æ¸¯æˆ–æ¾³é—¨
        // å½“å‰é…ç½®ï¼šæ¾³é—¨ ç¬¬335æœŸ
        const CONFIG = {
            type: 'macau', // 'hk' or 'macau'
            targetPeriod: 335,
            targetNumbers: [34, 35, 46, 31, 13, 3, 44]
        };

        const TARGET_PERIOD = CONFIG.targetPeriod;
        const TARGET_NUMBERS = CONFIG.targetNumbers;

        // Mock window.getCurrentApiConfig for ai-analyst.js
        window.getCurrentApiConfig = function() {
            const key = document.getElementById('apiKeyInput').value.trim();
            return key ? { apiKey: key } : null;
        };

        function log(msg) {
            const el = document.getElementById('status');
            el.innerHTML += `<div>[${new Date().toLocaleTimeString()}] ${msg}</div>`;
            el.scrollTop = el.scrollHeight;
        }

        async function fetchHistoryData() {
            log(`æ­£åœ¨å°è¯•è·å– ${CONFIG.type === 'hk' ? 'é¦™æ¸¯' : 'æ¾³é—¨'} å†å²æ•°æ®...`);
            const year = new Date().getFullYear(); 
            
            let urls = [];
            if (CONFIG.type === 'hk') {
                urls = [
                    `https://r.jina.ai/https://ttc5188.com/api/history/hongkong?year=${year}&page=1&pageSize=50`,
                    `https://r.jina.ai/https://ttc5188.com/api/history/hongkong?year=${year}&page=2&pageSize=50`,
                    `https://r.jina.ai/https://ttc5188.com/api/history/hongkong?year=${year}&page=3&pageSize=50`,
                    `https://r.jina.ai/https://ttc5188.com/api/history/hongkong?year=${year-1}&page=1&pageSize=50`
                ];
            } else {
                // æ¾³é—¨æ•°æ®æº (momarksix.org)
                // ç›´æ¥ä½¿ç”¨ä¸»ç¨‹åºä¸­éªŒè¯è¿‡çš„ API
                urls = [`https://momarksix.org/api/lottery/history/omsix`];
            }

            let allData = [];
            
            for (const url of urls) {
                try {
                    log(`Fetching: ...${url.slice(-30)}`);
                    const res = await fetch(url);
                    if (!res.ok) throw new Error(`HTTP ${res.status}`);
                    
                    const text = await res.text();
                    let parsed = [];
                    
                    if (CONFIG.type === 'hk') {
                        parsed = parseJinaResponse(text);
                    } else {
                        parsed = parseMacauResponse(text);
                    }
                    
                    if (parsed && parsed.length > 0) {
                        log(`æˆåŠŸè·å– ${parsed.length} æ¡æ•°æ® (æœ€æ–°: ${parsed[0].issue})`);
                        allData = allData.concat(parsed);
                    }
                } catch (e) {
                    log(`âš ï¸ Fetch failed: ${e.message}`);
                }
            }
            
            // å»é‡å¹¶æ’åº
            const uniqueData = [];
            const seenIssues = new Set();
            
            // æŒ‰æœŸå·é™åºæ’åº
            allData.sort((a, b) => parseInt(b.issue) - parseInt(a.issue));
            
            for (const item of allData) {
                if (!seenIssues.has(item.issue)) {
                    seenIssues.add(item.issue);
                    uniqueData.push(item);
                }
            }
            
            return uniqueData;
        }

        function parseMacauResponse(text) {
             try {
                const data = JSON.parse(text);
                if (data.code !== 200 || !data.data || !Array.isArray(data.data)) {
                    return [];
                }

                const draws = [];
                for (const item of data.data) {
                    if (item.issue && item.num && Array.isArray(item.num) && item.num.length >= 6) {
                        const numbers = item.num.slice(0, 7);
                        if (numbers.every(n => n >= 1 && n <= 49)) {
                            draws.push({
                                issue: item.issue.toString(),
                                numbers: numbers,
                                code: item.num.join(',')
                            });
                        }
                    }
                }
                return draws;
             } catch (e) {
                 console.warn('Macau parse error', e);
                 return [];
             }
        }

        function parseJinaResponse(text) {
            try {
                // å¤„ç†r.jina.aiè¿”å›çš„Markdownæ ¼å¼
                let jsonText = text;
                if (text.includes('Markdown Content:')) {
                    // ä»Markdownä¸­æå–JSONéƒ¨åˆ†
                    const jsonMatch = text.match(/Markdown Content:\s*(\{[\s\S]*\})/s);
                    if (jsonMatch) {
                        jsonText = jsonMatch[1];
                    } else {
                        const firstBrace = text.indexOf('{');
                        if (firstBrace !== -1) {
                            jsonText = text.substring(firstBrace);
                        }
                    }
                }

                // æ¸…ç†å¯èƒ½çš„Markdownä»£ç å—æ ‡è®°
                jsonText = jsonText.replace(/```json/g, '').replace(/```/g, '').trim();

                const data = JSON.parse(jsonText);
                const list = data && Array.isArray(data.data) ? data.data : [];
                const draws = [];
                
                for (const item of list) {
                    const codes = typeof item.open_code === 'string'
                        ? item.open_code.split(',').map(s => parseInt(s, 10)).filter(n => !isNaN(n))
                        : [];
                    
                    const numbers = codes.slice(0, 7);
                    
                    if (numbers.length >= 6 && numbers.every(n => n >= 1 && n <= 49)) {
                        draws.push({
                            issue: String(item.expect || ''),
                            numbers: numbers,
                            code: item.open_code
                        });
                    }
                }
                return draws;
            } catch (e) {
                return [];
            }
        }

        async function runBacktest() {
            const btn = document.querySelector('.btn');
            btn.disabled = true;
            btn.innerText = 'æ­£åœ¨æ‰§è¡Œå›æµ‹...';
            document.getElementById('status').innerHTML = '';
            
            try {
                log('æ­£åœ¨è·å–å†å²æ•°æ®...');
                const rawData = await fetchHistoryData();
                log(`æ€»è®¡è·å–åˆ° ${rawData.length} æ¡æœ‰æ•ˆå†å²æ•°æ®`);

                if (rawData.length === 0) {
                    throw new Error('æœªè·å–åˆ°å†å²æ•°æ®ï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ– API');
                }

                // æ™ºèƒ½è¯†åˆ«æœŸå·æ ¼å¼
                const sampleIssue = rawData[0].issue;
                log(`æ•°æ®æ ·æœ¬æœŸå·: ${sampleIssue}`);
                
                let targetIssue = TARGET_PERIOD;
                // å¦‚æœæ•°æ®æ˜¯ 2025125 (7ä½) è€Œç›®æ ‡æ˜¯ 125 (3ä½)ï¼Œåˆ™è‡ªåŠ¨è¡¥å…¨å¹´ä»½
                if (String(sampleIssue).length === 7 && String(TARGET_PERIOD).length <= 3) {
                    // å°è¯•åŒ¹é…æ•°æ®ä¸­çš„å¹´ä»½å‰ç¼€
                    const yearPrefix = String(sampleIssue).substring(0, 4);
                    targetIssue = parseInt(yearPrefix + String(TARGET_PERIOD).padStart(3, '0'));
                    log(`è‡ªåŠ¨è°ƒæ•´ç›®æ ‡æœŸå·ä¸º: ${targetIssue} (åŒ¹é…æ•°æ®æ ¼å¼)`);
                }

                // æŸ¥æ‰¾ç›®æ ‡æœŸå·
                const periodTarget = rawData.find(d => parseInt(d.issue) === targetIssue);
                if (periodTarget) {
                    log(`âœ… éªŒè¯æ•°æ®æº: ç¬¬${targetIssue}æœŸæ•°æ®å·²å­˜åœ¨ -> ${periodTarget.numbers.join(',')}`);
                    
                    // éªŒè¯å·²çŸ¥ç»“æœæ˜¯å¦åŒ¹é…
                    const targetStr = TARGET_NUMBERS.join(',');
                    const dataStr = periodTarget.numbers.join(',');
                    if (targetStr !== dataStr) {
                        log(`âš ï¸ è­¦å‘Š: APIæ•°æ® (${dataStr}) ä¸é¢„è®¾å·²çŸ¥ç»“æœ (${targetStr}) ä¸ä¸€è‡´! ä»¥APIæ•°æ®ä¸ºå‡†? ä¸ï¼Œä»¥é¢„è®¾ä¸ºå‡†ã€‚`);
                    }
                } else {
                    log(`âš ï¸ è­¦å‘Š: æ•°æ®æºä¸­æœªæ‰¾åˆ°ç¬¬${targetIssue}æœŸï¼Œå°†åŸºäºæœ€æ–°å¯ç”¨æ•°æ®è¿›è¡Œæ¨¡æ‹Ÿ`);
                }

                // è¿‡æ»¤æ•°æ®ï¼šåªä¿ç•™ç›®æ ‡æœŸå·ä¹‹å‰çš„æ•°æ®
                const trainingData = rawData.filter(d => parseInt(d.issue) < targetIssue);
                
                if (trainingData.length < 10) {
                    throw new Error(`æœ‰æ•ˆå†å²æ•°æ®ä¸è¶³ (ç›®æ ‡æœŸå· ${targetIssue} ä¹‹å‰çš„æ•°æ®å°‘äº10æ¡)`);
                }

                log(`ç­›é€‰å‡º ${trainingData.length} æœŸè®­ç»ƒæ•°æ® (æˆªæ­¢åˆ° ${trainingData[0].issue} æœŸ)`);

                // åˆå§‹åŒ–å¼•æ“
                const engine = new AdvancedPredictionEngine();
                
                // è¿è¡Œæ ¸å¿ƒé€»è¾‘
                const results = await evaluatePeriod(engine, trainingData, TARGET_NUMBERS, true);

                // æ’åºç»“æœ
                results.sort((a, b) => b.hitCount - a.hitCount || b.confidence - a.confidence);

                renderResults(results);
                log('âœ… å•æœŸå›æµ‹å®Œæˆï¼');

            } catch (e) {
                log(`âŒ é”™è¯¯: ${e.message}`);
                console.error(e);
            } finally {
                btn.disabled = false;
                btn.innerText = 'ğŸš€ å•æœŸå›æµ‹ (å½“å‰é…ç½®)';
            }
        }

        // æ ¸å¿ƒè¯„ä¼°é€»è¾‘ï¼šç»™å®šè®­ç»ƒæ•°æ®ï¼Œé¢„æµ‹ä¸‹ä¸€æœŸï¼Œå¹¶ä¸ç›®æ ‡å·ç å¯¹æ¯”
        // enableAI: æ˜¯å¦å¯ç”¨ LLM åˆ†æ (æ‰¹é‡å›æµ‹æ—¶é€šå¸¸å…³é—­ä»¥èŠ‚çœæ—¶é—´)
        async function evaluatePeriod(engine, trainingData, targetNumbers, enableAI = false) {
            // é¢„å¤„ç†æ•°æ®
            const processedData = engine.preprocessData(trainingData.map(d => ({
                period: d.issue,
                numbers: d.numbers
            })));

            const algorithms = engine.algorithms;
            const results = [];
            
            // é€ä¸ªè¿è¡Œç®—æ³• - çº¯ç¡®å®šæ€§æ‰§è¡Œ
            for (const [name, algo] of Object.entries(algorithms)) {
                try {
                    const prediction = await algo.analyze(processedData);
                    const predictedNums = prediction.recommended || [];
                    const hits = predictedNums.filter(n => targetNumbers.includes(n));
                    
                    results.push({
                        name: name,
                        predicted: predictedNums,
                        hits: hits,
                        hitCount: hits.length,
                        confidence: prediction.confidence
                    });
                } catch (e) {
                    console.warn(`Algo ${name} failed:`, e);
                }
            }

            // æ’åºç”¨äºèåˆ
            results.sort((a, b) => b.hitCount - a.hitCount || b.confidence - a.confidence);

            // ç­–ç•¥ä¼˜åŒ–ï¼šä¸ä»…ä½¿ç”¨ Top 3ï¼Œå°è¯•ä½¿ç”¨åŠ æƒå…¨å‘˜æŠ•ç¥¨ (Weighted Ensemble)
            const fusionResult = calculateWeightedFusion(results); 
            const fusionPrediction = fusionResult.recommended;
            const fusionSystemBet = fusionResult.systemBet; // è·å–9ç 
            const fusionSystemBet12 = fusionResult.systemBet12; // è·å–12ç 
            const fusionHits = fusionPrediction.filter(n => targetNumbers.includes(n));
            
            results.unshift({
                name: 'weighted_ensemble',
                predicted: fusionPrediction,
                systemBet9: fusionSystemBet, 
                systemBet12: fusionSystemBet12, // ä¼ é€’12ç å¤å¼æ•°æ®
                hits: fusionHits,
                hitCount: fusionHits.length,
                confidence: 99
            });

            // ä¿ç•™åŸæœ‰çš„ Top 3 (ä½œä¸ºå¯¹æ¯”)
            if (results.length >= 4) { 
                const top3 = results.slice(1, 4);
                const top3Prediction = calculateFusion(top3);
                const top3Hits = top3Prediction.filter(n => targetNumbers.includes(n));

                results.splice(1, 0, {
                    name: 'top3_fusion',
                    predicted: top3Prediction,
                    systemBet9: top3Prediction, // Top3 fusion æš‚æ—¶æ²¡æœ‰ä¸“é—¨çš„9ç é€»è¾‘ï¼Œç›´æ¥ç”¨6ç ä»£æ›¿(æˆ–éœ€è¦å•ç‹¬å®ç°)
                    hits: top3Hits,
                    hitCount: top3Hits.length,
                    confidence: 98
                });
            }

            // AI åˆ†æ (ä»…å•æœŸæ¨¡å¼æˆ–æ˜¾å¼å¼€å¯æ—¶è¿è¡Œ)
            if (enableAI) {
                try {
                    log('ğŸ§  æ­£åœ¨å”¤é†’ AI åˆ†æå¸ˆ (è°ƒç”¨ LLM)...');
                    const aiAnalyst = new window.AIAnalyst(engine);
                    // ä¸ºäº†èŠ‚çœ Token å’Œæ—¶é—´ï¼Œè¿™é‡Œä¸è¿›è¡Œå®Œæ•´çš„ fetch/parse æµç¨‹ï¼Œ
                    // è€Œæ˜¯ç®€å•æ¨¡æ‹Ÿæˆ–è€…å¦‚æœéœ€è¦çœŸå®è°ƒç”¨ï¼Œè¯·ç¡®ä¿ API Key å­˜åœ¨
                    // è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œç›´æ¥è°ƒç”¨
                    const aiResponse = await aiAnalyst.analyze(trainingData, CONFIG.type);
                    
                    if (aiResponse && aiResponse.predictions) {
                        const predictedNums = aiResponse.predictions.recommended;
                        const hits = predictedNums.filter(n => targetNumbers.includes(n));
                        
                        results.push({
                            name: 'ai_ensemble',
                            predicted: predictedNums,
                            systemBet9: aiResponse.predictions.systemBet9 || [],
                            systemBet12: aiResponse.predictions.systemBet12 || [],
                            hits: hits,
                            hitCount: hits.length,
                            confidence: aiResponse.confidence || 85
                        });
                    }
                } catch (e) {
                    log(`âš ï¸ AI Analyst è·³è¿‡: ${e.message}`);
                }
            }

            return results;
        }

        function showRawData() {
            fetchHistoryData().then(data => {
                const win = window.open('', '_blank', 'width=800,height=600');
                if (!win) {
                    alert('è¯·å…è®¸å¼¹å‡ºçª—å£ä»¥æŸ¥çœ‹åŸå§‹æ•°æ®');
                    return;
                }
                win.document.write(`
                    <html>
                    <head>
                        <title>åŸå§‹æ•°æ®æºæ£€è§†</title>
                        <style>
                            body { font-family: monospace; background: #1a1a2e; color: #e0e0e0; padding: 20px; }
                            table { width: 100%; border-collapse: collapse; }
                            th, td { border: 1px solid #334155; padding: 8px; text-align: left; }
                            th { background: #0f172a; color: #a78bfa; }
                            tr:nth-child(even) { background: #1e293b; }
                            h2 { color: #f59e0b; }
                            .source-badge { 
                                display: inline-block; 
                                padding: 4px 8px; 
                                background: #334155; 
                                border-radius: 4px; 
                                color: #4ade80; 
                                font-size: 0.9em;
                            }
                        </style>
                    </head>
                    <body>
                        <h2>ğŸ” åŸå§‹æ•°æ®æº (æœ€è¿‘50æœŸ)</h2>
                        <p>
                            <span class="source-badge">æ¥æº: ${CONFIG.type === 'hk' ? 'ttc5188 (via Jina)' : 'momarksix.org (æ¾³é—¨å®˜æ–¹æ•°æ®)'}</span>
                        </p>
                        <p><strong>æ•°æ®å®Œæ•´æ€§:</strong> å…±è·å– ${data.length} æ¡å†å²è®°å½•</p>
                        <p style="color: #94a3b8; font-size: 0.9em;">è¯´æ˜: ä¸‹è¡¨å±•ç¤ºäº†æœªç»ä»»ä½•ä¿®æ”¹çš„åŸå§‹APIè¿”å›æ•°æ®ï¼Œç”¨äºéªŒè¯å›æµ‹çš„çœŸå®æ€§ã€‚æ¯ä¸€è¡Œä»£è¡¨ä¸€æœŸçœŸå®çš„å¼€å¥–è®°å½•ã€‚</p>
                        <table>
                            <thead>
                                <tr>
                                    <th>æœŸå· (Issue)</th>
                                    <th>å¼€å¥–å·ç  (Numbers)</th>
                                    <th>åŸå§‹ä»£ç  (Code)</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${data.slice(0, 50).map(d => `
                                    <tr>
                                        <td>${d.issue}</td>
                                        <td style="color:#4ade80; font-weight:bold;">${d.numbers.join(', ')}</td>
                                        <td style="color:#94a3b8">${d.code || '-'}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </body>
                    </html>
                `);
            });
        }

        async function runBatchBacktest() {
            const count = parseInt(document.getElementById('batchCount').value);
            const btn = document.querySelector('button[onclick="runBatchBacktest()"]');
            btn.disabled = true;
            btn.innerText = 'â³ æ­£åœ¨è¯„æµ‹...';
            document.getElementById('status').innerHTML = '';
            document.getElementById('batchResultCard').style.display = 'none';
            document.getElementById('resultCard').style.display = 'none';

            // æ˜¾ç¤ºç›‘æ§é¢æ¿
            const monitorCard = document.getElementById('monitorCard');
            monitorCard.style.display = 'block';
            const elPeriod = document.getElementById('monitorPeriod');
            const elReal = document.getElementById('monitorReal');
            const elBest = document.getElementById('monitorBest');
            const elProgress = document.getElementById('monitorProgress');
            
            // é‡ç½®è¿›åº¦æ¡
            elProgress.style.width = '0%';
            elPeriod.innerText = 'å‡†å¤‡ä¸­...';
            elReal.innerText = '-';
            elBest.innerText = '-';

            try {
                log('ğŸ“¦ å¼€å§‹è·å–å…¨é‡å†å²æ•°æ®...');
                const rawData = await fetchHistoryData();
                
                if (rawData.length < count + 10) {
                    throw new Error(`æ•°æ®ä¸è¶³ï¼Œæ— æ³•å›æµ‹æœ€è¿‘ ${count} æœŸ (ä»…æœ‰ ${rawData.length} æ¡)`);
                }

                log(`âœ… æ•°æ®å‡†å¤‡å°±ç»ªï¼Œå³å°†å¯¹æœ€è¿‘ ${count} æœŸè¿›è¡Œå›æµ‹...`);
                log(`âš ï¸ æ³¨æ„ï¼šæ‰¹é‡æ¨¡å¼å°†è‡ªåŠ¨è·³è¿‡ LLM AI åˆ†æä»¥èŠ‚çœæ—¶é—´`);

                const engine = new AdvancedPredictionEngine();
                const stats = {}; // { algoName: { totalHits: 0, wins: 0, runs: 0 } }

                // å¾ªç¯å›æµ‹
                for (let i = 0; i < count; i++) {
                    const targetPeriodData = rawData[i];
                    const targetIssue = targetPeriodData.issue;
                    const targetNums = targetPeriodData.numbers;
                    
                    // æ›´æ–°ç›‘æ§é¢æ¿ UI
                    elPeriod.innerText = `ç¬¬ ${targetIssue} æœŸ`;
                    elReal.innerText = targetNums.join(', ');
                    elProgress.style.width = `${((i + 1) / count) * 100}%`;
                    
                    // è®­ç»ƒæ•°æ®
                    const trainingData = rawData.slice(i + 1);
                    
                    if (trainingData.length < 10) break; 

                    // è¿è¡Œå•æœŸè¯„ä¼°
                    const results = await evaluatePeriod(engine, trainingData, targetNums, false);

                    // æ‰¾åˆ°å½“æœŸæœ€ä½³ç»“æœç”¨äºå±•ç¤º
                    if (results.length > 0) {
                        const bestResult = results[0]; 
                        elBest.innerHTML = `${getAlgoName(bestResult.name)} <span style="color:${getHitColor(bestResult.hitCount)}; font-weight:bold;">[${bestResult.hitCount}ä¸­]</span>`;
                    }

                    // ç»Ÿè®¡ç»“æœ
                    results.forEach(r => {
                        if (!stats[r.name]) {
                            stats[r.name] = { totalHits: 0, wins: 0, runs: 0, hitsList: [], systemBetWins: 0, systemBet12Wins: 0 };
                        }
                        stats[r.name].totalHits += r.hitCount;
                        stats[r.name].runs += 1;
                        if (r.hitCount >= 3) stats[r.name].wins += 1; 
                        stats[r.name].hitsList.push(r.hitCount);

                        // ç»Ÿè®¡9ç å¤å¼èƒœç‡
                        let systemHits = 0;
                        if (r.systemBet9) {
                             systemHits = r.systemBet9.filter(n => targetNums.includes(n)).length;
                        } else if (r.predicted.length >= 6) {
                             systemHits = r.hitCount;
                        }
                        
                        if (systemHits >= 3) {
                            stats[r.name].systemBetWins += 1;
                        }

                        // ç»Ÿè®¡12ç å¤å¼èƒœç‡
                        let system12Hits = 0;
                        if (r.systemBet12) {
                             system12Hits = r.systemBet12.filter(n => targetNums.includes(n)).length;
                        } else if (r.predicted.length >= 6) {
                             system12Hits = r.hitCount;
                        }

                        if (system12Hits >= 3) {
                            stats[r.name].systemBet12Wins += 1;
                        }
                    });

                    // å¢åŠ äººä¸ºå»¶è¿Ÿï¼Œè®©ç”¨æˆ·çœ‹æ¸…è¿‡ç¨‹ (150ms)
                    await new Promise(resolve => setTimeout(resolve, 150));
                }

                renderBatchResults(stats, count);
                log('ğŸ‰ å¤§æ•°æ®è¯„æµ‹å®Œæˆï¼');
                elPeriod.innerText = "âœ… å›æµ‹å®Œæˆ";

            } catch (e) {
                log(`âŒ æ‰¹é‡å›æµ‹å¤±è´¥: ${e.message}`);
                console.error(e);
                elPeriod.innerText = "âŒ å¤±è´¥";
            } finally {
                btn.disabled = false;
                btn.innerText = 'ğŸ“Š å¼€å§‹å¤§æ•°æ®è¯„æµ‹';
            }
        }

        function renderBatchResults(stats, totalRuns) {
            const list = Object.entries(stats).map(([name, data]) => {
                return {
                    name,
                    avgHits: (data.totalHits / data.runs).toFixed(2),
                    winRate: ((data.wins / data.runs) * 100).toFixed(1) + '%',
                    maxHits: Math.max(...data.hitsList),
                    totalHits: data.totalHits,
                    runs: data.runs,
                    systemBetWinRate: data.systemBetWins ? ((data.systemBetWins / data.runs) * 100).toFixed(1) + '%' : 'N/A',
                    systemBet12WinRate: data.systemBet12Wins ? ((data.systemBet12Wins / data.runs) * 100).toFixed(1) + '%' : 'N/A'
                };
            });

            // æ’åºï¼šä¼˜å…ˆæŒ‰12ç å¤å¼èƒœç‡é™åº
            list.sort((a, b) => parseFloat(b.systemBet12WinRate) - parseFloat(a.systemBet12WinRate) || parseFloat(b.avgHits) - parseFloat(a.avgHits));

            const table = document.createElement('table');
            table.innerHTML = `
                <thead>
                    <tr>
                        <th width="50">æ’å</th>
                        <th>ç®—æ³•ç­–ç•¥</th>
                        <th>å¹³å‡å‘½ä¸­ (6ç )</th>
                        <th>èƒœç‡ (6ç ä¸­3+)</th>
                        <th style="background:#3730a3; color:#a5b4fc">ğŸ”¥ 9ç èƒœç‡</th>
                        <th style="background:#4c1d95; color:#c4b5fd">ğŸš€ 12ç èƒœç‡</th>
                        <th>å•æœŸæœ€é«˜</th>
                    </tr>
                </thead>
                <tbody>
                    ${list.map((item, i) => `
                        <tr>
                            <td class="rank-${i+1}">${i+1}</td>
                            <td style="font-weight:bold; color:${item.name.includes('weighted') ? '#f472b6' : '#fff'}">
                                ${getAlgoName(item.name)}
                            </td>
                            <td style="font-size:18px; color:#4ade80; font-weight:bold;">${item.avgHits}</td>
                            <td>${item.winRate}</td>
                            <td style="background:rgba(55, 48, 163, 0.3); font-size:16px; font-weight:bold; color:#fbbf24;">${item.systemBetWinRate}</td>
                            <td style="background:rgba(76, 29, 149, 0.3); font-size:16px; font-weight:bold; color:#e879f9;">${item.systemBet12WinRate}</td>
                            <td>${item.maxHits}</td>
                        </tr>
                    `).join('')}
                </tbody>
            `;

            const container = document.getElementById('batchResultTable');
            container.innerHTML = '';
            container.appendChild(table);
            document.getElementById('batchResultCard').style.display = 'block';
        }

        function parseNumbers(d) {
            // å¤„ç† API å¯èƒ½çš„æ ¼å¼å·®å¼‚
            // å‡è®¾ d.numbers æ˜¯æ•°ç»„ï¼Œæˆ–è€… d.code æ˜¯ "01,02,..." å­—ç¬¦ä¸²
            if (Array.isArray(d.numbers)) return d.numbers.map(Number);
            if (typeof d.code === 'string') return d.code.split(',').map(Number);
            if (typeof d.opencode === 'string') return d.opencode.split('+').join(',').split(',').map(Number);
            return [];
        }

        function calculateWeightedFusion(allResults) {
            // ç»¼åˆæ‰€æœ‰ç®—æ³•çš„æ„è§ï¼Œæ ¹æ®ç½®ä¿¡åº¦åŠ æƒ
            const frequency = {};
            
            allResults.forEach(algo => {
                // æƒé‡ = ç½®ä¿¡åº¦ (60-90) / 100
                let weight = (algo.confidence || 70) / 100;
                
                // å¦‚æœè¯¥ç®—æ³•æœ‰è¯¦ç»†çš„ systemBet9 (9ç )ï¼Œåˆ™å¯¹è¿™9ç éƒ½è¿›è¡ŒåŠ æƒ
                // å¦‚æœåªæœ‰ predicted (6ç )ï¼Œåˆ™åªå¯¹è¿™6ç åŠ æƒ
                const numsToVote = algo.systemBet9 || algo.predicted;
                
                numsToVote.forEach(num => {
                    frequency[num] = (frequency[num] || 0) + weight;
                });
            });

            // æ’åºå–å‡ºå‰9å
            const sorted = Object.entries(frequency)
                .map(([num, score]) => ({ num: parseInt(num), score }))
                .sort((a, b) => b.score - a.score);
            
            const recommended = sorted.slice(0, 6).map(i => i.num);
            const systemBet = sorted.slice(0, 9).map(i => i.num);
            const systemBet12 = sorted.slice(0, 12).map(i => i.num);

            return { recommended, systemBet, systemBet12 };
        }

        function calculateFusion(topAlgorithms) {
            // ç»Ÿè®¡å‰ä¸‰åç®—æ³•æ¨èçš„æ‰€æœ‰å·ç çš„é¢‘ç‡
            const frequency = {};
            const allRecommended = [];
            
            topAlgorithms.forEach(algo => {
                algo.predicted.forEach(num => {
                    frequency[num] = (frequency[num] || 0) + 1;
                    allRecommended.push(num);
                });
            });

            // ç­–ç•¥ï¼š
            // 1. ä¼˜å…ˆé€‰æ‹©å‡ºç°2æ¬¡åŠä»¥ä¸Šçš„å·ç  (å…±æŒ¯å·)
            // 2. å¦‚æœä¸è¶³6ä¸ªï¼Œä»æ’åç¬¬ä¸€çš„ç®—æ³•ä¸­è¡¥è¶³
            
            const candidates = Object.entries(frequency)
                .map(([num, count]) => ({ num: parseInt(num), count }))
                .sort((a, b) => b.count - a.count); // æŒ‰å‡ºç°é¢‘ç‡æ’åº

            const result = new Set();
            
            // 1. å…ˆå–å…±æŒ¯å· (å‡ºç°æ¬¡æ•° > 1)
            candidates.forEach(c => {
                if (c.count >= 2 && result.size < 6) {
                    result.add(c.num);
                }
            });

            // 2. å¦‚æœä¸å¤Ÿï¼Œä»ç¬¬ä¸€åç®—æ³•çš„æ¨èä¸­è¡¥é½
            if (result.size < 6) {
                const top1Nums = topAlgorithms[0].predicted;
                for (const num of top1Nums) {
                    if (result.size >= 6) break;
                    result.add(num);
                }
            }

            // 3. è¿˜æ˜¯ä¸å¤Ÿï¼Ÿ(ç†è®ºä¸Šæå°‘å‘ç”Ÿ)ï¼Œä»ç¬¬äºŒåè¡¥
            if (result.size < 6) {
                const top2Nums = topAlgorithms[1].predicted;
                for (const num of top2Nums) {
                    if (result.size >= 6) break;
                    result.add(num);
                }
            }

            return Array.from(result);
        }

        function getAlgoName(key) {
            const names = {
                weighted_ensemble: "ğŸŒŒ å…¨æ¨¡æ€åŠ æƒèåˆ (Weighted Ensemble)",
                top3_fusion: "ğŸ† å† å†›ç®—æ³•èåˆ (Top 3 Fusion)",
                markov: "é©¬å°”å¯å¤«é“¾ (Markov)",
                bayesian: "è´å¶æ–¯æ¨æ–­ (Bayesian)",
                timeSeries: "æ—¶é—´åºåˆ— (Time Series)",
                cluster: "èšç±»åˆ†æ (Clustering)",
                neural: "ç¥ç»ç½‘ç»œ (Neural Net)",
                monteCarlo: "è’™ç‰¹å¡æ´› (Monte Carlo)",
                genetic: "é—ä¼ ç®—æ³• (Genetic)",
                svm: "æ”¯æŒå‘é‡æœº (SVM)",
                pattern: "æ¨¡å¼å½¢æ€åˆ†æ (Pattern)",
                omission: "é—æ¼å›è¡¥åˆ†æ (Omission)",
                golden: "ğŸ”± é»„é‡‘ä¸‰è§’ç­–ç•¥ (Kill+Banker)",
                association: "ğŸ“Š å…³è”è§„åˆ™æŒ–æ˜ (Apriori)",
                ai_ensemble: "ğŸ§  AI æ·±åº¦åˆ†æ (LLM)"
            };
            return names[key] || key;
        }

        function renderResults(results) {
            const table = document.createElement('table');
            table.innerHTML = `
                <thead>
                    <tr>
                        <th width="50">æ’å</th>
                        <th width="120">ç®—æ³•åç§°</th>
                        <th>é¢„æµ‹å·ç  (å‰6ç )</th>
                        <th width="100">å‘½ä¸­æ•°</th>
                        <th>å‘½ä¸­è¯¦æƒ…</th>
                    </tr>
                </thead>
                <tbody>
                    ${results.map((r, i) => `
                        <tr>
                            <td class="rank-${i+1}">${i+1}</td>
                            <td style="font-weight:bold; color:#fff;">${getAlgoName(r.name)}</td>
                            <td>${formatNumbers(r.predicted, r.hits)}</td>
                            <td style="font-size:18px; font-weight:bold; color:${getHitColor(r.hitCount)}">${r.hitCount}</td>
                            <td>${r.hits.join(', ')}</td>
                        </tr>
                    `).join('')}
                </tbody>
            `;
            
            const container = document.getElementById('resultTable');
            container.innerHTML = '';
            container.appendChild(table);
            document.getElementById('resultCard').style.display = 'block';
        }

        function formatNumbers(nums, hits) {
            return nums.map(n => {
                const isHit = hits.includes(n);
                return `<span style="
                    display:inline-block; 
                    width:24px; 
                    height:24px; 
                    line-height:24px; 
                    text-align:center; 
                    border-radius:50%; 
                    background:${isHit ? '#ef4444' : '#334155'}; 
                    color:white; 
                    margin-right:4px;
                    font-weight:${isHit ? 'bold' : 'normal'};
                ">${String(n).padStart(2, '0')}</span>`;
            }).join('');
        }

        function getHitColor(count) {
            if (count >= 4) return '#ef4444'; // Red
            if (count >= 3) return '#f59e0b'; // Orange
            if (count >= 1) return '#3b82f6'; // Blue
            return '#6b7280'; // Gray
        }
    </script>
</body>
</html>
